# ./_ddexC.py
# -*- coding: utf-8 -*-
# PyXB bindings for NM:bd3011a5b4365de65473dbafb591a813dcf669bd
# Generated 2015-07-06 15:09:50.920552 by PyXB version 1.2.4 using Python 2.7.6.final.0
# Namespace http://ddex.net/xml/20100712/ddexC [xmlns:ddexC]

from __future__ import unicode_literals
import pyxb
import pyxb.binding
import pyxb.binding.saxer
import io
import pyxb.utils.utility
import pyxb.utils.domutils
import sys
import pyxb.utils.six as _six

# Unique identifier for bindings created at the same time
_GenerationUID = pyxb.utils.utility.UniqueIdentifier('urn:uuid:f7997896-23f0-11e5-bc58-080027960975')

# Version of PyXB used to generate the bindings
_PyXBVersion = '1.2.4'
# Generated bindings are not compatible across PyXB versions
if pyxb.__version__ != _PyXBVersion:
    raise pyxb.PyXBVersionError(_PyXBVersion)

# Import bindings for namespaces imported into schema
import _iso4217a as _ImportedBinding__iso4217a
import pyxb.binding.datatypes
import _iso639a2 as _ImportedBinding__iso639a2
import _ddex as _ImportedBinding__ddex
import _iso3166a2 as _ImportedBinding__iso3166a2

# NOTE: All namespace declarations are reserved within the binding
Namespace = pyxb.namespace.NamespaceForURI('http://ddex.net/xml/20100712/ddexC', create_if_missing=True)
Namespace.configureCategories(['typeBinding', 'elementBinding'])

def CreateFromDocument (xml_text, default_namespace=None, location_base=None):
    """Parse the given XML and use the document element to create a
    Python instance.

    @param xml_text An XML document.  This should be data (Python 2
    str or Python 3 bytes), or a text (Python 2 unicode or Python 3
    str) in the L{pyxb._InputEncoding} encoding.

    @keyword default_namespace The L{pyxb.Namespace} instance to use as the
    default namespace where there is no default namespace in scope.
    If unspecified or C{None}, the namespace of the module containing
    this function will be used.

    @keyword location_base: An object to be recorded as the base of all
    L{pyxb.utils.utility.Location} instances associated with events and
    objects handled by the parser.  You might pass the URI from which
    the document was obtained.
    """

    if pyxb.XMLStyle_saxer != pyxb._XMLStyle:
        dom = pyxb.utils.domutils.StringToDOM(xml_text)
        return CreateFromDOM(dom.documentElement, default_namespace=default_namespace)
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    saxer = pyxb.binding.saxer.make_parser(fallback_namespace=default_namespace, location_base=location_base)
    handler = saxer.getContentHandler()
    xmld = xml_text
    if isinstance(xmld, _six.text_type):
        xmld = xmld.encode(pyxb._InputEncoding)
    saxer.parse(io.BytesIO(xmld))
    instance = handler.rootObject()
    return instance

def CreateFromDOM (node, default_namespace=None):
    """Create a Python instance from the given DOM node.
    The node tag must correspond to an element declaration in this module.

    @deprecated: Forcing use of DOM interface is unnecessary; use L{CreateFromDocument}."""
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    return pyxb.binding.basis.element.AnyCreateFromDOM(node, default_namespace)


# Union simple type: {http://ddex.net/xml/20100712/ddexC}TerritoryCode
# superclasses pyxb.binding.datatypes.anySimpleType
class TerritoryCode (pyxb.binding.basis.STD_union):

    """A code representing a Territory. This includes ISO 3166-1 two-letter codes plus a code for Worldwide."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TerritoryCode')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4461, 4)
    _Documentation = 'A code representing a Territory. This includes ISO 3166-1 two-letter codes plus a code for Worldwide.'

    _MemberTypes = ( _ImportedBinding__ddex.NonIsoTerritoryCode, _ImportedBinding__iso3166a2.TerritoryCode, )
TerritoryCode._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=TerritoryCode)
TerritoryCode._CF_pattern = pyxb.binding.facets.CF_pattern()
TerritoryCode.Worldwide = 'Worldwide'             # originally _ImportedBinding__ddex.NonIsoTerritoryCode.Worldwide
TerritoryCode.AD = 'AD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AD
TerritoryCode.AE = 'AE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AE
TerritoryCode.AF = 'AF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AF
TerritoryCode.AG = 'AG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AG
TerritoryCode.AI = 'AI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AI
TerritoryCode.AL = 'AL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AL
TerritoryCode.AM = 'AM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AM
TerritoryCode.AN = 'AN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AN
TerritoryCode.AO = 'AO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AO
TerritoryCode.AQ = 'AQ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AQ
TerritoryCode.AR = 'AR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AR
TerritoryCode.AS = 'AS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AS
TerritoryCode.AT = 'AT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AT
TerritoryCode.AU = 'AU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AU
TerritoryCode.AW = 'AW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AW
TerritoryCode.AX = 'AX'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AX
TerritoryCode.AZ = 'AZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AZ
TerritoryCode.BA = 'BA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BA
TerritoryCode.BB = 'BB'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BB
TerritoryCode.BD = 'BD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BD
TerritoryCode.BE = 'BE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BE
TerritoryCode.BF = 'BF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BF
TerritoryCode.BG = 'BG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BG
TerritoryCode.BH = 'BH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BH
TerritoryCode.BI = 'BI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BI
TerritoryCode.BJ = 'BJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BJ
TerritoryCode.BM = 'BM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BM
TerritoryCode.BN = 'BN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BN
TerritoryCode.BO = 'BO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BO
TerritoryCode.BR = 'BR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BR
TerritoryCode.BS = 'BS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BS
TerritoryCode.BT = 'BT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BT
TerritoryCode.BV = 'BV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BV
TerritoryCode.BW = 'BW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BW
TerritoryCode.BY = 'BY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BY
TerritoryCode.BZ = 'BZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BZ
TerritoryCode.CA = 'CA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CA
TerritoryCode.CC = 'CC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CC
TerritoryCode.CD = 'CD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CD
TerritoryCode.CF = 'CF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CF
TerritoryCode.CG = 'CG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CG
TerritoryCode.CH = 'CH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CH
TerritoryCode.CI = 'CI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CI
TerritoryCode.CK = 'CK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CK
TerritoryCode.CL = 'CL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CL
TerritoryCode.CM = 'CM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CM
TerritoryCode.CN = 'CN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CN
TerritoryCode.CO = 'CO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CO
TerritoryCode.CR = 'CR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CR
TerritoryCode.CU = 'CU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CU
TerritoryCode.CV = 'CV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CV
TerritoryCode.CX = 'CX'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CX
TerritoryCode.CY = 'CY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CY
TerritoryCode.CZ = 'CZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CZ
TerritoryCode.DE = 'DE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DE
TerritoryCode.DJ = 'DJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DJ
TerritoryCode.DK = 'DK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DK
TerritoryCode.DM = 'DM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DM
TerritoryCode.DO = 'DO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DO
TerritoryCode.DZ = 'DZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DZ
TerritoryCode.EC = 'EC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.EC
TerritoryCode.EE = 'EE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.EE
TerritoryCode.EG = 'EG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.EG
TerritoryCode.EH = 'EH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.EH
TerritoryCode.ER = 'ER'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ER
TerritoryCode.ES = 'ES'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ES
TerritoryCode.ET = 'ET'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ET
TerritoryCode.FI = 'FI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FI
TerritoryCode.FJ = 'FJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FJ
TerritoryCode.FK = 'FK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FK
TerritoryCode.FM = 'FM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FM
TerritoryCode.FO = 'FO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FO
TerritoryCode.FR = 'FR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FR
TerritoryCode.GA = 'GA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GA
TerritoryCode.GB = 'GB'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GB
TerritoryCode.GD = 'GD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GD
TerritoryCode.GE = 'GE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GE
TerritoryCode.GF = 'GF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GF
TerritoryCode.GG = 'GG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GG
TerritoryCode.GH = 'GH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GH
TerritoryCode.GI = 'GI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GI
TerritoryCode.GL = 'GL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GL
TerritoryCode.GM = 'GM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GM
TerritoryCode.GN = 'GN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GN
TerritoryCode.GP = 'GP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GP
TerritoryCode.GQ = 'GQ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GQ
TerritoryCode.GR = 'GR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GR
TerritoryCode.GS = 'GS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GS
TerritoryCode.GT = 'GT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GT
TerritoryCode.GU = 'GU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GU
TerritoryCode.GW = 'GW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GW
TerritoryCode.GY = 'GY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GY
TerritoryCode.HK = 'HK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HK
TerritoryCode.HM = 'HM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HM
TerritoryCode.HN = 'HN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HN
TerritoryCode.HR = 'HR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HR
TerritoryCode.HT = 'HT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HT
TerritoryCode.HU = 'HU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HU
TerritoryCode.ID = 'ID'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ID
TerritoryCode.IE = 'IE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IE
TerritoryCode.IL = 'IL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IL
TerritoryCode.IM = 'IM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IM
TerritoryCode.IN = 'IN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IN
TerritoryCode.IO = 'IO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IO
TerritoryCode.IQ = 'IQ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IQ
TerritoryCode.IR = 'IR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IR
TerritoryCode.IS = 'IS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IS
TerritoryCode.IT = 'IT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IT
TerritoryCode.JE = 'JE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.JE
TerritoryCode.JM = 'JM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.JM
TerritoryCode.JO = 'JO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.JO
TerritoryCode.JP = 'JP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.JP
TerritoryCode.KE = 'KE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KE
TerritoryCode.KG = 'KG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KG
TerritoryCode.KH = 'KH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KH
TerritoryCode.KI = 'KI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KI
TerritoryCode.KM = 'KM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KM
TerritoryCode.KN = 'KN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KN
TerritoryCode.KP = 'KP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KP
TerritoryCode.KR = 'KR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KR
TerritoryCode.KW = 'KW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KW
TerritoryCode.KY = 'KY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KY
TerritoryCode.KZ = 'KZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KZ
TerritoryCode.LA = 'LA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LA
TerritoryCode.LB = 'LB'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LB
TerritoryCode.LC = 'LC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LC
TerritoryCode.LI = 'LI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LI
TerritoryCode.LK = 'LK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LK
TerritoryCode.LR = 'LR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LR
TerritoryCode.LS = 'LS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LS
TerritoryCode.LT = 'LT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LT
TerritoryCode.LU = 'LU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LU
TerritoryCode.LV = 'LV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LV
TerritoryCode.LY = 'LY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LY
TerritoryCode.MA = 'MA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MA
TerritoryCode.MC = 'MC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MC
TerritoryCode.MD = 'MD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MD
TerritoryCode.ME = 'ME'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ME
TerritoryCode.MG = 'MG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MG
TerritoryCode.MH = 'MH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MH
TerritoryCode.MK = 'MK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MK
TerritoryCode.ML = 'ML'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ML
TerritoryCode.MM = 'MM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MM
TerritoryCode.MN = 'MN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MN
TerritoryCode.MO = 'MO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MO
TerritoryCode.MP = 'MP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MP
TerritoryCode.MQ = 'MQ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MQ
TerritoryCode.MR = 'MR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MR
TerritoryCode.MS = 'MS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MS
TerritoryCode.MT = 'MT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MT
TerritoryCode.MU = 'MU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MU
TerritoryCode.MV = 'MV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MV
TerritoryCode.MW = 'MW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MW
TerritoryCode.MX = 'MX'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MX
TerritoryCode.MY = 'MY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MY
TerritoryCode.MZ = 'MZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MZ
TerritoryCode.NA = 'NA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NA
TerritoryCode.NC = 'NC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NC
TerritoryCode.NE = 'NE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NE
TerritoryCode.NF = 'NF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NF
TerritoryCode.NG = 'NG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NG
TerritoryCode.NI = 'NI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NI
TerritoryCode.NL = 'NL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NL
TerritoryCode.NO = 'NO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NO
TerritoryCode.NP = 'NP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NP
TerritoryCode.NR = 'NR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NR
TerritoryCode.NU = 'NU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NU
TerritoryCode.NZ = 'NZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NZ
TerritoryCode.OM = 'OM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.OM
TerritoryCode.PA = 'PA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PA
TerritoryCode.PE = 'PE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PE
TerritoryCode.PF = 'PF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PF
TerritoryCode.PG = 'PG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PG
TerritoryCode.PH = 'PH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PH
TerritoryCode.PK = 'PK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PK
TerritoryCode.PL = 'PL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PL
TerritoryCode.PM = 'PM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PM
TerritoryCode.PN = 'PN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PN
TerritoryCode.PR = 'PR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PR
TerritoryCode.PS = 'PS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PS
TerritoryCode.PT = 'PT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PT
TerritoryCode.PW = 'PW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PW
TerritoryCode.PY = 'PY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PY
TerritoryCode.QA = 'QA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.QA
TerritoryCode.RE = 'RE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RE
TerritoryCode.RO = 'RO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RO
TerritoryCode.RS = 'RS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RS
TerritoryCode.RU = 'RU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RU
TerritoryCode.RW = 'RW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RW
TerritoryCode.SA = 'SA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SA
TerritoryCode.SB = 'SB'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SB
TerritoryCode.SC = 'SC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SC
TerritoryCode.SD = 'SD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SD
TerritoryCode.SE = 'SE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SE
TerritoryCode.SG = 'SG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SG
TerritoryCode.SH = 'SH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SH
TerritoryCode.SI = 'SI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SI
TerritoryCode.SJ = 'SJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SJ
TerritoryCode.SK = 'SK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SK
TerritoryCode.SL = 'SL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SL
TerritoryCode.SM = 'SM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SM
TerritoryCode.SN = 'SN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SN
TerritoryCode.SO = 'SO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SO
TerritoryCode.SR = 'SR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SR
TerritoryCode.ST = 'ST'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ST
TerritoryCode.SV = 'SV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SV
TerritoryCode.SY = 'SY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SY
TerritoryCode.SZ = 'SZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SZ
TerritoryCode.TC = 'TC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TC
TerritoryCode.TD = 'TD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TD
TerritoryCode.TF = 'TF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TF
TerritoryCode.TG = 'TG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TG
TerritoryCode.TH = 'TH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TH
TerritoryCode.TJ = 'TJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TJ
TerritoryCode.TK = 'TK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TK
TerritoryCode.TL = 'TL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TL
TerritoryCode.TM = 'TM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TM
TerritoryCode.TN = 'TN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TN
TerritoryCode.TO = 'TO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TO
TerritoryCode.TR = 'TR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TR
TerritoryCode.TT = 'TT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TT
TerritoryCode.TV = 'TV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TV
TerritoryCode.TW = 'TW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TW
TerritoryCode.TZ = 'TZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TZ
TerritoryCode.UA = 'UA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UA
TerritoryCode.UG = 'UG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UG
TerritoryCode.UM = 'UM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UM
TerritoryCode.US = 'US'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.US
TerritoryCode.UY = 'UY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UY
TerritoryCode.UZ = 'UZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UZ
TerritoryCode.VA = 'VA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VA
TerritoryCode.VC = 'VC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VC
TerritoryCode.VE = 'VE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VE
TerritoryCode.VG = 'VG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VG
TerritoryCode.VI = 'VI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VI
TerritoryCode.VN = 'VN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VN
TerritoryCode.VU = 'VU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VU
TerritoryCode.WF = 'WF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.WF
TerritoryCode.WS = 'WS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.WS
TerritoryCode.YE = 'YE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.YE
TerritoryCode.YT = 'YT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.YT
TerritoryCode.ZA = 'ZA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ZA
TerritoryCode.ZM = 'ZM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ZM
TerritoryCode.ZW = 'ZW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ZW
TerritoryCode._InitializeFacetMap(TerritoryCode._CF_enumeration,
   TerritoryCode._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'TerritoryCode', TerritoryCode)

# Complex type {http://ddex.net/xml/20100712/ddexC}AdditionalInformation with content type SIMPLE
class AdditionalInformation (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an AdditionalInformation."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AdditionalInformation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_AdditionalInformation_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 16, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 16, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the AdditionalInformation as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'AdditionalInformation', AdditionalInformation)


# Complex type {http://ddex.net/xml/20100712/ddexC}AmountByUseAndDistributionChannelType with content type ELEMENT_ONLY
class AmountByUseAndDistributionChannelType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an Amount specified for a UseType and a DistributionChannelType."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AmountByUseAndDistributionChannelType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 38, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Amount uses Python identifier Amount
    __Amount = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Amount'), 'Amount', '__httpddex_netxml20100712ddexC_AmountByUseAndDistributionChannelType_Amount', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 43, 12), )

    
    Amount = property(__Amount.value, __Amount.set, None, 'The Amount specified for the UseType and the DistributionChannelType.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20100712ddexC_AmountByUseAndDistributionChannelType_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 48, 12), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20100712ddexC_AmountByUseAndDistributionChannelType_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 53, 12), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A Composite containing details of a physical interface by which a Consumer uses a Service or Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20100712ddexC_AmountByUseAndDistributionChannelType_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 58, 12), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20100712ddexC_AmountByUseAndDistributionChannelType_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 63, 12), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A Composite containing details of a Carrier.')

    _ElementMap.update({
        __Amount.name() : __Amount,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'AmountByUseAndDistributionChannelType', AmountByUseAndDistributionChannelType)


# Complex type {http://ddex.net/xml/20100712/ddexC}AmountPerCollection with content type ELEMENT_ONLY
class AmountPerCollection (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an Amount that has to be paid per Collection."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AmountPerCollection')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 70, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Amount uses Python identifier Amount
    __Amount = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Amount'), 'Amount', '__httpddex_netxml20100712ddexC_AmountPerCollection_Amount', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 75, 12), )

    
    Amount = property(__Amount.value, __Amount.set, None, 'The Amount specified for the CollectionType.')

    
    # Element CollectionType uses Python identifier CollectionType
    __CollectionType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionType'), 'CollectionType', '__httpddex_netxml20100712ddexC_AmountPerCollection_CollectionType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 80, 12), )

    
    CollectionType = property(__CollectionType.value, __CollectionType.set, None, 'A Composite containing details of the Type of the Collection.')

    _ElementMap.update({
        __Amount.name() : __Amount,
        __CollectionType.name() : __CollectionType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'AmountPerCollection', AmountPerCollection)


# Complex type {http://ddex.net/xml/20100712/ddexC}Annotation with content type SIMPLE
class Annotation (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an Annotation."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Annotation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 87, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Annotation_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 93, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 93, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the Annotation as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Annotation', Annotation)


# Complex type {http://ddex.net/xml/20100712/ddexC}AvRating with content type ELEMENT_ONLY
class AvRating (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a rating for an audio-visual Creation."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AvRating')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 173, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element RatingText uses Python identifier RatingText
    __RatingText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RatingText'), 'RatingText', '__httpddex_netxml20100712ddexC_AvRating_RatingText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 178, 12), )

    
    RatingText = property(__RatingText.value, __RatingText.set, None, 'The text of the AvRating.')

    
    # Element RatingAgency uses Python identifier RatingAgency
    __RatingAgency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RatingAgency'), 'RatingAgency', '__httpddex_netxml20100712ddexC_AvRating_RatingAgency', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 183, 12), )

    
    RatingAgency = property(__RatingAgency.value, __RatingAgency.set, None, 'A Composite containing details of an Organization that issues the AvRating.')

    _ElementMap.update({
        __RatingText.name() : __RatingText,
        __RatingAgency.name() : __RatingAgency
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'AvRating', AvRating)


# Complex type {http://ddex.net/xml/20100712/ddexC}CatalogNumber with content type SIMPLE
class CatalogNumber (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CatalogNumber."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CatalogNumber')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 237, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CatalogNumber_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 243, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 243, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the CatalogNumber. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'CatalogNumber', CatalogNumber)


# Complex type {http://ddex.net/xml/20100712/ddexC}CLine with content type ELEMENT_ONLY
class CLine (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CLine."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CLine')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 272, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Year uses Python identifier Year
    __Year = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Year'), 'Year', '__httpddex_netxml20100712ddexC_CLine_Year', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 277, 12), )

    
    Year = property(__Year.value, __Year.set, None, 'The Year of the CLine.')

    
    # Element CLineText uses Python identifier CLineText
    __CLineText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLineText'), 'CLineText', '__httpddex_netxml20100712ddexC_CLine_CLineText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 282, 12), )

    
    CLineText = property(__CLineText.value, __CLineText.set, None, 'The text of the CLine.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_CLine_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 288, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 288, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the CLineText as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __Year.name() : __Year,
        __CLineText.name() : __CLineText
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'CLine', CLine)


# Complex type {http://ddex.net/xml/20100712/ddexC}Collection with content type ELEMENT_ONLY
class Collection (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Collection."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Collection')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 294, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element CollectionId uses Python identifier CollectionId
    __CollectionId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionId'), 'CollectionId', '__httpddex_netxml20100712ddexC_Collection_CollectionId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 299, 12), )

    
    CollectionId = property(__CollectionId.value, __CollectionId.set, None, 'A Composite containing details of an Identifier of the Collection.')

    
    # Element CollectionType uses Python identifier CollectionType
    __CollectionType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionType'), 'CollectionType', '__httpddex_netxml20100712ddexC_Collection_CollectionType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 304, 12), )

    
    CollectionType = property(__CollectionType.value, __CollectionType.set, None, 'A Composite containing details of the Type of the Collection.')

    
    # Element CollectionReference uses Python identifier CollectionReference
    __CollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionReference'), 'CollectionReference', '__httpddex_netxml20100712ddexC_Collection_CollectionReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 309, 12), )

    
    CollectionReference = property(__CollectionReference.value, __CollectionReference.set, None, 'The Identifier (specific to the Message) of the Collection within the Release which contains it. This LocalAnchor is a string starting with the letter X.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_Collection_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 314, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the Collection.')

    
    # Element Contributor uses Python identifier Contributor
    __Contributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Contributor'), 'Contributor', '__httpddex_netxml20100712ddexC_Collection_Contributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 319, 12), )

    
    Contributor = property(__Contributor.value, __Contributor.set, None, 'A Composite containing details a Contributor to the Collection.')

    
    # Element CollectionCollectionReferenceList uses Python identifier CollectionCollectionReferenceList
    __CollectionCollectionReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReferenceList'), 'CollectionCollectionReferenceList', '__httpddex_netxml20100712ddexC_Collection_CollectionCollectionReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 324, 12), )

    
    CollectionCollectionReferenceList = property(__CollectionCollectionReferenceList.value, __CollectionCollectionReferenceList.set, None, 'A Composite containing a list of CollectionCollectionReferences for a Collection (specific to this Message).')

    
    # Element IsComplete uses Python identifier IsComplete
    __IsComplete = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsComplete'), 'IsComplete', '__httpddex_netxml20100712ddexC_Collection_IsComplete', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 329, 12), )

    
    IsComplete = property(__IsComplete.value, __IsComplete.set, None, 'The Flag indicating whether the Collection is complete (=True) or not (=False). Only one of the Elements IsComplete here and in the CollectionDetailsByTerritory is valid for a given Collection.')

    
    # Element DurationOfMusicalContent uses Python identifier DurationOfMusicalContent
    __DurationOfMusicalContent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DurationOfMusicalContent'), 'DurationOfMusicalContent', '__httpddex_netxml20100712ddexC_Collection_DurationOfMusicalContent', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 334, 12), )

    
    DurationOfMusicalContent = property(__DurationOfMusicalContent.value, __DurationOfMusicalContent.set, None, 'The Duration of the musical content (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element CreationDate uses Python identifier CreationDate
    __CreationDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CreationDate'), 'CreationDate', '__httpddex_netxml20100712ddexC_Collection_CreationDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 339, 12), )

    
    CreationDate = property(__CreationDate.value, __CreationDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Collection was created.')

    
    # Element OriginalReleaseDate uses Python identifier OriginalReleaseDate
    __OriginalReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate'), 'OriginalReleaseDate', '__httpddex_netxml20100712ddexC_Collection_OriginalReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 344, 12), )

    
    OriginalReleaseDate = property(__OriginalReleaseDate.value, __OriginalReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Collection was or will be first made available for Usage, whether for physical or electronic/online distribution (in ISO 8601:2004 format: YYYY-MM-DD).')

    
    # Element OriginalLanguage uses Python identifier OriginalLanguage
    __OriginalLanguage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalLanguage'), 'OriginalLanguage', '__httpddex_netxml20100712ddexC_Collection_OriginalLanguage', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 349, 12), )

    
    OriginalLanguage = property(__OriginalLanguage.value, __OriginalLanguage.set, None, 'The orignal Language of the Collection (represented by an ISO 639-2 LanguageCode).')

    
    # Element CollectionDetailsByTerritory uses Python identifier CollectionDetailsByTerritory
    __CollectionDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionDetailsByTerritory'), 'CollectionDetailsByTerritory', '__httpddex_netxml20100712ddexC_Collection_CollectionDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 354, 12), )

    
    CollectionDetailsByTerritory = property(__CollectionDetailsByTerritory.value, __CollectionDetailsByTerritory.set, None, 'A Composite containing details of Descriptors and other attributes of the Collection which may vary according to Territory of release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Collection_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 360, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 360, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the Collection as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __CollectionId.name() : __CollectionId,
        __CollectionType.name() : __CollectionType,
        __CollectionReference.name() : __CollectionReference,
        __Title.name() : __Title,
        __Contributor.name() : __Contributor,
        __CollectionCollectionReferenceList.name() : __CollectionCollectionReferenceList,
        __IsComplete.name() : __IsComplete,
        __DurationOfMusicalContent.name() : __DurationOfMusicalContent,
        __CreationDate.name() : __CreationDate,
        __OriginalReleaseDate.name() : __OriginalReleaseDate,
        __OriginalLanguage.name() : __OriginalLanguage,
        __CollectionDetailsByTerritory.name() : __CollectionDetailsByTerritory
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Collection', Collection)


# Complex type {http://ddex.net/xml/20100712/ddexC}CollectionCollectionReference with content type ELEMENT_ONLY
class CollectionCollectionReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a CollectionCollectionReference."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionCollectionReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 366, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_CollectionCollectionReference_SequenceNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 371, 12), )

    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the Collection in a group of Collections within a Medley, SoundRecording or other Collection.')

    
    # Element CollectionCollectionReference uses Python identifier CollectionCollectionReference
    __CollectionCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference'), 'CollectionCollectionReference', '__httpddex_netxml20100712ddexC_CollectionCollectionReference_CollectionCollectionReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 376, 12), )

    
    CollectionCollectionReference = property(__CollectionCollectionReference.value, __CollectionCollectionReference.set, None, 'A Reference for a Collection (specific to this Message). This LocalAnchorReference is a string starting with the letter X. The referenced Collection has to be of CollectionType Series, Season or Episode.')

    
    # Element StartTime uses Python identifier StartTime
    __StartTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartTime'), 'StartTime', '__httpddex_netxml20100712ddexC_CollectionCollectionReference_StartTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 381, 12), )

    
    StartTime = property(__StartTime.value, __StartTime.set, None, 'The start time of the Creation, measured from the start of the Resource from which the CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20100712ddexC_CollectionCollectionReference_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 386, 12), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The Duration of the use of the Creation that is referenced in the CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element EndTime uses Python identifier EndTime
    __EndTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndTime'), 'EndTime', '__httpddex_netxml20100712ddexC_CollectionCollectionReference_EndTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 391, 12), )

    
    EndTime = property(__EndTime.value, __EndTime.set, None, 'The end time of the Creation, measured from the start of the Resource from which the CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element InclusionDate uses Python identifier InclusionDate
    __InclusionDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'InclusionDate'), 'InclusionDate', '__httpddex_netxml20100712ddexC_CollectionCollectionReference_InclusionDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 396, 12), )

    
    InclusionDate = property(__InclusionDate.value, __InclusionDate.set, None, 'A Date on which the Collection or Resource was included in the parent Collection.')

    _ElementMap.update({
        __SequenceNumber.name() : __SequenceNumber,
        __CollectionCollectionReference.name() : __CollectionCollectionReference,
        __StartTime.name() : __StartTime,
        __Duration.name() : __Duration,
        __EndTime.name() : __EndTime,
        __InclusionDate.name() : __InclusionDate
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CollectionCollectionReference', CollectionCollectionReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}CollectionCollectionReferenceList with content type ELEMENT_ONLY
class CollectionCollectionReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a list of CollectionCollectionReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionCollectionReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 403, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element NumberOfCollections uses Python identifier NumberOfCollections
    __NumberOfCollections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), 'NumberOfCollections', '__httpddex_netxml20100712ddexC_CollectionCollectionReferenceList_NumberOfCollections', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 408, 12), )

    
    NumberOfCollections = property(__NumberOfCollections.value, __NumberOfCollections.set, None, 'The number of referenced Collections (typically Chapters).')

    
    # Element CollectionCollectionReference uses Python identifier CollectionCollectionReference
    __CollectionCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference'), 'CollectionCollectionReference', '__httpddex_netxml20100712ddexC_CollectionCollectionReferenceList_CollectionCollectionReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 413, 12), )

    
    CollectionCollectionReference = property(__CollectionCollectionReference.value, __CollectionCollectionReference.set, None, 'A Composite containing a CollectionCollectionReference for a Collection (specific to this Message).')

    _ElementMap.update({
        __NumberOfCollections.name() : __NumberOfCollections,
        __CollectionCollectionReference.name() : __CollectionCollectionReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CollectionCollectionReferenceList', CollectionCollectionReferenceList)


# Complex type {http://ddex.net/xml/20100712/ddexC}CollectionDetailsByTerritory with content type ELEMENT_ONLY
class CollectionDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Descriptors and other attributes of a Collection which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 420, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_CollectionDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 426, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the Collection details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_CollectionDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 431, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the Collection details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_CollectionDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 437, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the Collection.')

    
    # Element Contributor uses Python identifier Contributor
    __Contributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Contributor'), 'Contributor', '__httpddex_netxml20100712ddexC_CollectionDetailsByTerritory_Contributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 442, 12), )

    
    Contributor = property(__Contributor.value, __Contributor.set, None, 'A Composite containing details of a Contributor to the Collection.')

    
    # Element IsComplete uses Python identifier IsComplete
    __IsComplete = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsComplete'), 'IsComplete', '__httpddex_netxml20100712ddexC_CollectionDetailsByTerritory_IsComplete', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 447, 12), )

    
    IsComplete = property(__IsComplete.value, __IsComplete.set, None, 'The Flag indicating whether the Collection is complete (=True) or not (=False). Only one of the Elements IsComplete here and in the Collection is valid for a given Collection.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __Title.name() : __Title,
        __Contributor.name() : __Contributor,
        __IsComplete.name() : __IsComplete
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CollectionDetailsByTerritory', CollectionDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}CollectionId with content type ELEMENT_ONLY
class CollectionId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CollectionId."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 454, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element GRid uses Python identifier GRid
    __GRid = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'GRid'), 'GRid', '__httpddex_netxml20100712ddexC_CollectionId_GRid', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 459, 12), )

    
    GRid = property(__GRid.value, __GRid.set, None, 'The GRid identifying the Collection. This is the preferred Element and is mandatory if a GRid is available. A GRid comprises four parts: the string "A1", followed by five alphanumeric characters, ten alphanumeric characters and and one alphanumeric character.')

    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20100712ddexC_CollectionId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 464, 12), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ISRC (International Standard Recording Code as defined in ISO 3901) for the Collection. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.')

    
    # Element ISAN uses Python identifier ISAN
    __ISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISAN'), 'ISAN', '__httpddex_netxml20100712ddexC_CollectionId_ISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 469, 12), )

    
    ISAN = property(__ISAN.value, __ISAN.set, None, 'The ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the Collection. An ISAN comprises four blocks of four hexadecimal charaters followed by a check character.')

    
    # Element VISAN uses Python identifier VISAN
    __VISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VISAN'), 'VISAN', '__httpddex_netxml20100712ddexC_CollectionId_VISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 474, 12), )

    
    VISAN = property(__VISAN.value, __VISAN.set, None, 'The V-ISAN (Version Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the Collection. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.')

    
    # Element ICPN uses Python identifier ICPN
    __ICPN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ICPN'), 'ICPN', '__httpddex_netxml20100712ddexC_CollectionId_ICPN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 479, 12), )

    
    ICPN = property(__ICPN.value, __ICPN.set, None, 'A Composite containing details of the ICPN used as proxy for identification of the Collection. Only applicable when the Collection is an abstraction of a complete PhysicalProduct. An ICPN comprises 12 or 13 digits, depending whether it is an EAN (13) or a UPC (12).')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20100712ddexC_CollectionId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 484, 12), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A Composite containing details of the CatalogNumber of the Collection.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_CollectionId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 489, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the Collection (usually one per society involved in the messaging).')

    _ElementMap.update({
        __GRid.name() : __GRid,
        __ISRC.name() : __ISRC,
        __ISAN.name() : __ISAN,
        __VISAN.name() : __VISAN,
        __ICPN.name() : __ICPN,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CollectionId', CollectionId)


# Complex type {http://ddex.net/xml/20100712/ddexC}CollectionResourceReferenceList with content type ELEMENT_ONLY
class CollectionResourceReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a list of CollectionResourceReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionResourceReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 496, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element CollectionResourceReference uses Python identifier CollectionResourceReference
    __CollectionResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionResourceReference'), 'CollectionResourceReference', '__httpddex_netxml20100712ddexC_CollectionResourceReferenceList_CollectionResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 501, 12), )

    
    CollectionResourceReference = property(__CollectionResourceReference.value, __CollectionResourceReference.set, None, 'A Reference for a Resource (specific to this Message). This LocalAnchorReference is a string starting with the letter A.')

    _ElementMap.update({
        __CollectionResourceReference.name() : __CollectionResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CollectionResourceReferenceList', CollectionResourceReferenceList)


# Complex type {http://ddex.net/xml/20100712/ddexC}Comment with content type SIMPLE
class Comment (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an Comment."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Comment')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 527, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Comment_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 533, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 533, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the Comment as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Comment', Comment)


# Complex type {http://ddex.net/xml/20100712/ddexC}ConsumerRentalPeriod with content type SIMPLE
class ConsumerRentalPeriod (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Period a DSP may rent something to a Customer."""
    _TypeDefinition = pyxb.binding.datatypes.duration
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ConsumerRentalPeriod')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 560, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.duration
    
    # Attribute IsExtensible uses Python identifier IsExtensible
    __IsExtensible = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsExtensible'), 'IsExtensible', '__httpddex_netxml20100712ddexC_ConsumerRentalPeriod_IsExtensible', pyxb.binding.datatypes.boolean)
    __IsExtensible._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 566, 16)
    __IsExtensible._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 566, 16)
    
    IsExtensible = property(__IsExtensible.value, __IsExtensible.set, None, 'A Flag indicating whether a Period can be extended after the end of a Deal (=True) or not (=False).')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __IsExtensible.name() : __IsExtensible
    })
Namespace.addCategoryObject('typeBinding', 'ConsumerRentalPeriod', ConsumerRentalPeriod)


# Complex type {http://ddex.net/xml/20100712/ddexC}CourtesyLine with content type SIMPLE
class CourtesyLine (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an CourtesyLine."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CourtesyLine')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 590, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_CourtesyLine_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 596, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 596, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the CourtesyLine as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'CourtesyLine', CourtesyLine)


# Complex type {http://ddex.net/xml/20100712/ddexC}CueCreationReference with content type ELEMENT_ONLY
class CueCreationReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a CueCreationReference."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueCreationReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 604, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element CueWorkReference uses Python identifier CueWorkReference
    __CueWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueWorkReference'), 'CueWorkReference', '__httpddex_netxml20100712ddexC_CueCreationReference_CueWorkReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 610, 16), )

    
    CueWorkReference = property(__CueWorkReference.value, __CueWorkReference.set, None, 'A Reference for a Work (specific to this Message). This LocalAnchorReference is a string starting with the letter W.')

    
    # Element CueResourceReference uses Python identifier CueResourceReference
    __CueResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueResourceReference'), 'CueResourceReference', '__httpddex_netxml20100712ddexC_CueCreationReference_CueResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 615, 16), )

    
    CueResourceReference = property(__CueResourceReference.value, __CueResourceReference.set, None, 'A Reference for a Resource (specific to this Message). This LocalAnchorReference is a string starting with the letter A.')

    _ElementMap.update({
        __CueWorkReference.name() : __CueWorkReference,
        __CueResourceReference.name() : __CueResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CueCreationReference', CueCreationReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}DealReference with content type SIMPLE
class DealReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a DealReference."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DealReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 737, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_DealReference_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 743, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 743, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the DealReference as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'DealReference', DealReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}Description with content type SIMPLE
class Description (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an Description."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Description')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 775, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Description_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 781, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 781, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the Description as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Description', Description)


# Complex type {http://ddex.net/xml/20100712/ddexC}DistributionChannelDescriptor with content type SIMPLE
class DistributionChannelDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a DistributionChannelDescriptor."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DistributionChannelDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 810, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_DistributionChannelDescriptor_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 816, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 816, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the DistributionChannelDescriptor as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'DistributionChannelDescriptor', DistributionChannelDescriptor)


# Complex type {http://ddex.net/xml/20100712/ddexC}DurationByUseType with content type ELEMENT_ONLY
class DurationByUseType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Duration specified for a UseType."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DurationByUseType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 898, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20100712ddexC_DurationByUseType_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 903, 12), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The Duration specified for the UseType.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20100712ddexC_DurationByUseType_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 908, 12), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20100712ddexC_DurationByUseType_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 913, 12), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A Composite containing details of a physical interface by which a Consumer uses a Service or Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20100712ddexC_DurationByUseType_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 918, 12), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20100712ddexC_DurationByUseType_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 923, 12), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A Composite containing details of a Carrier.')

    _ElementMap.update({
        __Duration.name() : __Duration,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'DurationByUseType', DurationByUseType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ExternalResourceLink with content type ELEMENT_ONLY
class ExternalResourceLink (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of promotional or other material in digital form related to a Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ExternalResourceLink')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1016, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element URL uses Python identifier URL
    __URL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'URL'), 'URL', '__httpddex_netxml20100712ddexC_ExternalResourceLink_URL', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1021, 12), )

    
    URL = property(__URL.value, __URL.set, None, 'A URL of the linked external Resource.')

    
    # Element ValidityPeriod uses Python identifier ValidityPeriod
    __ValidityPeriod = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ValidityPeriod'), 'ValidityPeriod', '__httpddex_netxml20100712ddexC_ExternalResourceLink_ValidityPeriod', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1026, 12), )

    
    ValidityPeriod = property(__ValidityPeriod.value, __ValidityPeriod.set, None, 'A Composite containing details about the Period of Time during which the ExternalResourceLink is active.')

    
    # Element ExternalLink uses Python identifier ExternalLink
    __ExternalLink = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExternalLink'), 'ExternalLink', '__httpddex_netxml20100712ddexC_ExternalResourceLink_ExternalLink', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1031, 12), )

    
    ExternalLink = property(__ExternalLink.value, __ExternalLink.set, None, 'The Identifier which provides a communication link to the related external Resource.')

    
    # Element ExternallyLinkedResourceType uses Python identifier ExternallyLinkedResourceType
    __ExternallyLinkedResourceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExternallyLinkedResourceType'), 'ExternallyLinkedResourceType', '__httpddex_netxml20100712ddexC_ExternalResourceLink_ExternallyLinkedResourceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1036, 12), )

    
    ExternallyLinkedResourceType = property(__ExternallyLinkedResourceType.value, __ExternallyLinkedResourceType.set, None, 'A Composite containing details of the Type of a Resource pointed to by the ExternalResourceLink.')

    
    # Element FileFormat uses Python identifier FileFormat
    __FileFormat = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FileFormat'), 'FileFormat', '__httpddex_netxml20100712ddexC_ExternalResourceLink_FileFormat', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1041, 12), )

    
    FileFormat = property(__FileFormat.value, __FileFormat.set, None, 'The FileFormat of the external Resource.')

    _ElementMap.update({
        __URL.name() : __URL,
        __ValidityPeriod.name() : __ValidityPeriod,
        __ExternalLink.name() : __ExternalLink,
        __ExternallyLinkedResourceType.name() : __ExternallyLinkedResourceType,
        __FileFormat.name() : __FileFormat
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ExternalResourceLink', ExternalResourceLink)


# Complex type {http://ddex.net/xml/20100712/ddexC}File with content type ELEMENT_ONLY
class File (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a File."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'File')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1048, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element FileName uses Python identifier FileName
    __FileName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FileName'), 'FileName', '__httpddex_netxml20100712ddexC_File_FileName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1055, 20), )

    
    FileName = property(__FileName.value, __FileName.set, None, 'A Name of the File.')

    
    # Element FilePath uses Python identifier FilePath
    __FilePath = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FilePath'), 'FilePath', '__httpddex_netxml20100712ddexC_File_FilePath', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1060, 20), )

    
    FilePath = property(__FilePath.value, __FilePath.set, None, 'A location of the File.')

    
    # Element URL uses Python identifier URL
    __URL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'URL'), 'URL', '__httpddex_netxml20100712ddexC_File_URL', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1066, 16), )

    
    URL = property(__URL.value, __URL.set, None, 'A URL of the File.')

    
    # Element HashSum uses Python identifier HashSum
    __HashSum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HashSum'), 'HashSum', '__httpddex_netxml20100712ddexC_File_HashSum', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1072, 12), )

    
    HashSum = property(__HashSum.value, __HashSum.set, None, 'A Composite containing a HashSum of the File and information about the algorithm with which it has been generated.')

    _ElementMap.update({
        __FileName.name() : __FileName,
        __FilePath.name() : __FilePath,
        __URL.name() : __URL,
        __HashSum.name() : __HashSum
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'File', File)


# Complex type {http://ddex.net/xml/20100712/ddexC}FulfillmentDate with content type ELEMENT_ONLY
class FulfillmentDate (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a FulfillmentDate."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'FulfillmentDate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1093, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element FulfillmentDate uses Python identifier FulfillmentDate
    __FulfillmentDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FulfillmentDate'), 'FulfillmentDate', '__httpddex_netxml20100712ddexC_FulfillmentDate_FulfillmentDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1098, 12), )

    
    FulfillmentDate = property(__FulfillmentDate.value, __FulfillmentDate.set, None, 'A Date after which an end user can receive the Resource (in ISO 8601:2004 format: YYYY-MM-DD). If no FulfillmentDate is provided the FulfillmentDate is the StartDate of the respective Deal.')

    
    # Element ResourceReleaseReference uses Python identifier ResourceReleaseReference
    __ResourceReleaseReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReleaseReference'), 'ResourceReleaseReference', '__httpddex_netxml20100712ddexC_FulfillmentDate_ResourceReleaseReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1103, 12), )

    
    ResourceReleaseReference = property(__ResourceReleaseReference.value, __ResourceReleaseReference.set, None, 'The Identifier (specific to the Message) of a Release for a Resource. This LocalAnchorReference is a string starting with the letter R.')

    _ElementMap.update({
        __FulfillmentDate.name() : __FulfillmentDate,
        __ResourceReleaseReference.name() : __ResourceReleaseReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'FulfillmentDate', FulfillmentDate)


# Complex type {http://ddex.net/xml/20100712/ddexC}Genre with content type ELEMENT_ONLY
class Genre (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Genre."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Genre')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1110, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element GenreText uses Python identifier GenreText
    __GenreText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'GenreText'), 'GenreText', '__httpddex_netxml20100712ddexC_Genre_GenreText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1115, 12), )

    
    GenreText = property(__GenreText.value, __GenreText.set, None, 'A Composite containing a Description of a genre or style (such as Musical, literary or audio-visual) with which a Creation is associated.')

    
    # Element SubGenre uses Python identifier SubGenre
    __SubGenre = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SubGenre'), 'SubGenre', '__httpddex_netxml20100712ddexC_Genre_SubGenre', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1120, 12), )

    
    SubGenre = property(__SubGenre.value, __SubGenre.set, None, 'A Composite containing a Description of a secondary genre or style with which a Creation is associated.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Genre_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1126, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1126, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the Genre as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __GenreText.name() : __GenreText,
        __SubGenre.name() : __SubGenre
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Genre', Genre)


# Complex type {http://ddex.net/xml/20100712/ddexC}HashSum with content type ELEMENT_ONLY
class HashSum (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a HashSum and its governing algorithm."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'HashSum')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1151, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element HashSum uses Python identifier HashSum
    __HashSum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HashSum'), 'HashSum', '__httpddex_netxml20100712ddexC_HashSum_HashSum', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1156, 12), )

    
    HashSum = property(__HashSum.value, __HashSum.set, None, 'The value of the HashSum.')

    
    # Element HashSumAlgorithmType uses Python identifier HashSumAlgorithmType
    __HashSumAlgorithmType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HashSumAlgorithmType'), 'HashSumAlgorithmType', '__httpddex_netxml20100712ddexC_HashSum_HashSumAlgorithmType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1161, 12), )

    
    HashSumAlgorithmType = property(__HashSumAlgorithmType.value, __HashSumAlgorithmType.set, None, 'A Composite containing details of the Type of HashSumAlgorithm governing the HashSum.')

    _ElementMap.update({
        __HashSum.name() : __HashSum,
        __HashSumAlgorithmType.name() : __HashSumAlgorithmType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'HashSum', HashSum)


# Complex type {http://ddex.net/xml/20100712/ddexC}HostSoundCarrier with content type ELEMENT_ONLY
class HostSoundCarrier (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a HostSoundCarrier of a SoundRecording. This Composite exists in the ERN MessageSuite to support the identification and matching of SoundRecording information."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'HostSoundCarrier')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1187, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20100712ddexC_HostSoundCarrier_ReleaseId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1192, 12), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A Composite containing details of ReleaseIds of the HostSoundCarrier. If available, a GRid has to be used. If the HostSoundCarrier contains only one SoundRecording, the ISRC of the SoundRecording may be used instead.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_HostSoundCarrier_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1197, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the HostSoundCarrier.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_HostSoundCarrier_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1202, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the HostSoundCarrier.')

    
    # Element DisplayArtist uses Python identifier DisplayArtist
    __DisplayArtist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), 'DisplayArtist', '__httpddex_netxml20100712ddexC_HostSoundCarrier_DisplayArtist', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1207, 12), )

    
    DisplayArtist = property(__DisplayArtist.value, __DisplayArtist.set, None, 'A Composite containing details of the DisplayArtist for the HostSoundCarrier. The DisplayArtist may be described through Name, Identifier and Roles.')

    
    # Element AdministratingRecordCompany uses Python identifier AdministratingRecordCompany
    __AdministratingRecordCompany = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany'), 'AdministratingRecordCompany', '__httpddex_netxml20100712ddexC_HostSoundCarrier_AdministratingRecordCompany', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1212, 12), )

    
    AdministratingRecordCompany = property(__AdministratingRecordCompany.value, __AdministratingRecordCompany.set, None, 'A Composite containing details of the AdministratingRecordCompany for the Rights in the HostSoundCarrier.')

    
    # Element TrackNumber uses Python identifier TrackNumber
    __TrackNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TrackNumber'), 'TrackNumber', '__httpddex_netxml20100712ddexC_HostSoundCarrier_TrackNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1217, 12), )

    
    TrackNumber = property(__TrackNumber.value, __TrackNumber.set, None, 'The TrackNumber of the SoundRecording within the HostSoundCarrier.')

    
    # Element VolumeNumberInSet uses Python identifier VolumeNumberInSet
    __VolumeNumberInSet = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VolumeNumberInSet'), 'VolumeNumberInSet', '__httpddex_netxml20100712ddexC_HostSoundCarrier_VolumeNumberInSet', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1222, 12), )

    
    VolumeNumberInSet = property(__VolumeNumberInSet.value, __VolumeNumberInSet.set, None, 'The SequenceNumber within the Set of the volume containing the SoundRecording, where the HostSoundCarrier is a Set (such as a "box set" of CDs).')

    _ElementMap.update({
        __ReleaseId.name() : __ReleaseId,
        __RightsAgreementId.name() : __RightsAgreementId,
        __Title.name() : __Title,
        __DisplayArtist.name() : __DisplayArtist,
        __AdministratingRecordCompany.name() : __AdministratingRecordCompany,
        __TrackNumber.name() : __TrackNumber,
        __VolumeNumberInSet.name() : __VolumeNumberInSet
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'HostSoundCarrier', HostSoundCarrier)


# Complex type {http://ddex.net/xml/20100712/ddexC}ICPN with content type SIMPLE
class ICPN (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an ICPN."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ICPN')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1229, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute IsEan uses Python identifier IsEan
    __IsEan = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsEan'), 'IsEan', '__httpddex_netxml20100712ddexC_ICPN_IsEan', pyxb.binding.datatypes.boolean, required=True)
    __IsEan._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1235, 16)
    __IsEan._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1235, 16)
    
    IsEan = property(__IsEan.value, __IsEan.set, None, 'The Flag indicating whether the ICPN is specifically an EAN (=True) or a UPC (=False). This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __IsEan.name() : __IsEan
    })
Namespace.addCategoryObject('typeBinding', 'ICPN', ICPN)


# Complex type {http://ddex.net/xml/20100712/ddexC}Image with content type ELEMENT_ONLY
class Image (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an Image."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Image')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1243, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ImageType uses Python identifier ImageType
    __ImageType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ImageType'), 'ImageType', '__httpddex_netxml20100712ddexC_Image_ImageType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1248, 12), )

    
    ImageType = property(__ImageType.value, __ImageType.set, None, 'A Composite containing details of the Type of the Image.')

    
    # Element IsArtistRelated uses Python identifier IsArtistRelated
    __IsArtistRelated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), 'IsArtistRelated', '__httpddex_netxml20100712ddexC_Image_IsArtistRelated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1253, 12), )

    
    IsArtistRelated = property(__IsArtistRelated.value, __IsArtistRelated.set, None, 'The Flag indicating whether the Image is related to an Artist (=True) or not (=False).')

    
    # Element ImageId uses Python identifier ImageId
    __ImageId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ImageId'), 'ImageId', '__httpddex_netxml20100712ddexC_Image_ImageId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1258, 12), )

    
    ImageId = property(__ImageId.value, __ImageId.set, None, 'A Composite containing details of Identifiers of the Image.')

    
    # Element ResourceReference uses Python identifier ResourceReference
    __ResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReference'), 'ResourceReference', '__httpddex_netxml20100712ddexC_Image_ResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1263, 12), )

    
    ResourceReference = property(__ResourceReference.value, __ResourceReference.set, None, 'The Identifier (specific to the Message) of the Image within the Release which contains it. This LocalAnchor is a string starting with the letter A.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_Image_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1268, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the Image.')

    
    # Element CreationDate uses Python identifier CreationDate
    __CreationDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CreationDate'), 'CreationDate', '__httpddex_netxml20100712ddexC_Image_CreationDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1273, 12), )

    
    CreationDate = property(__CreationDate.value, __CreationDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Image was created.')

    
    # Element ImageDetailsByTerritory uses Python identifier ImageDetailsByTerritory
    __ImageDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ImageDetailsByTerritory'), 'ImageDetailsByTerritory', '__httpddex_netxml20100712ddexC_Image_ImageDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1278, 12), )

    
    ImageDetailsByTerritory = property(__ImageDetailsByTerritory.value, __ImageDetailsByTerritory.set, None, 'A Composite containing details of the Image which may vary according to Territory of release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Image_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1284, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1284, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the Image as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __ImageType.name() : __ImageType,
        __IsArtistRelated.name() : __IsArtistRelated,
        __ImageId.name() : __ImageId,
        __ResourceReference.name() : __ResourceReference,
        __Title.name() : __Title,
        __CreationDate.name() : __CreationDate,
        __ImageDetailsByTerritory.name() : __ImageDetailsByTerritory
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Image', Image)


# Complex type {http://ddex.net/xml/20100712/ddexC}ImageDetailsByTerritory with content type ELEMENT_ONLY
class ImageDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Descriptors, Dates and other attributes of an Image which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ImageDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1314, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_ImageDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1320, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the Image details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_ImageDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1325, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the Image details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20100712ddexC_ImageDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1331, 12), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A Composite containing details of a Contributor to the Image.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20100712ddexC_ImageDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1336, 12), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A Composite containing details of an indirect Contributor to the Image.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20100712ddexC_ImageDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1341, 12), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A Composite containing details of the CLine for the Image.')

    
    # Element Description uses Python identifier Description
    __Description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Description'), 'Description', '__httpddex_netxml20100712ddexC_ImageDetailsByTerritory_Description', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1346, 12), )

    
    Description = property(__Description.value, __Description.set, None, 'A Composite containing a Description of the subject of the Image.')

    
    # Element CourtesyLine uses Python identifier CourtesyLine
    __CourtesyLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), 'CourtesyLine', '__httpddex_netxml20100712ddexC_ImageDetailsByTerritory_CourtesyLine', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1351, 12), )

    
    CourtesyLine = property(__CourtesyLine.value, __CourtesyLine.set, None, 'A Composite containing an Annotation which acknowledges record companies and/or other Parties giving permission for Artists or others featured on the Image.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20100712ddexC_ImageDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1356, 12), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Image was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_ImageDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1362, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1362, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the ImageDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __CLine.name() : __CLine,
        __Description.name() : __Description,
        __CourtesyLine.name() : __CourtesyLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'ImageDetailsByTerritory', ImageDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}ImageId with content type ELEMENT_ONLY
class ImageId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Identifiers of an Image."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ImageId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1368, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_ImageId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1373, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the Image.')

    _ElementMap.update({
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ImageId', ImageId)


# Complex type {http://ddex.net/xml/20100712/ddexC}Keywords with content type SIMPLE
class Keywords (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Description containing Keywords."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Keywords')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1420, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Keywords_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1426, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1426, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the Keywords as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Keywords', Keywords)


# Complex type {http://ddex.net/xml/20100712/ddexC}MessageAuditTrail with content type ELEMENT_ONLY
class MessageAuditTrail (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing information about Parties in between the original MessageSender and ultimate MessageRecipient."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageAuditTrail')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1491, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MessageAuditTrailEvent uses Python identifier MessageAuditTrailEvent
    __MessageAuditTrailEvent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageAuditTrailEvent'), 'MessageAuditTrailEvent', '__httpddex_netxml20100712ddexC_MessageAuditTrail_MessageAuditTrailEvent', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1496, 12), )

    
    MessageAuditTrailEvent = property(__MessageAuditTrailEvent.value, __MessageAuditTrailEvent.set, None, 'A Composite containing details of a Party handling the Message and the Time at which the handling took place.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_MessageAuditTrail_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1502, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1502, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the MessageAuditTrail as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __MessageAuditTrailEvent.name() : __MessageAuditTrailEvent
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MessageAuditTrail', MessageAuditTrail)


# Complex type {http://ddex.net/xml/20100712/ddexC}MessageAuditTrailEvent with content type ELEMENT_ONLY
class MessageAuditTrailEvent (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Party handling a Message and the Time at which the handling took place."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageAuditTrailEvent')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1508, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MessagingPartyDescriptor uses Python identifier MessagingPartyDescriptor
    __MessagingPartyDescriptor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessagingPartyDescriptor'), 'MessagingPartyDescriptor', '__httpddex_netxml20100712ddexC_MessageAuditTrailEvent_MessagingPartyDescriptor', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1513, 12), )

    
    MessagingPartyDescriptor = property(__MessagingPartyDescriptor.value, __MessagingPartyDescriptor.set, None, 'A Composite containing details of a MessagingParty.')

    
    # Element DateTime uses Python identifier DateTime
    __DateTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DateTime'), 'DateTime', '__httpddex_netxml20100712ddexC_MessageAuditTrailEvent_DateTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1518, 12), )

    
    DateTime = property(__DateTime.value, __DateTime.set, None, 'The DateTime at which the Message was handled by the MessagingParty (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).')

    _ElementMap.update({
        __MessagingPartyDescriptor.name() : __MessagingPartyDescriptor,
        __DateTime.name() : __DateTime
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'MessageAuditTrailEvent', MessageAuditTrailEvent)


# Complex type {http://ddex.net/xml/20100712/ddexC}MessageHeader with content type ELEMENT_ONLY
class MessageHeader (pyxb.binding.basis.complexTypeDefinition):
    """A Composite placed at the beginning of each DdexMessage providing information about the Message, such as MessageSender, MessageRecipient and a Message creation time stamp."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageHeader')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1525, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MessageThreadId uses Python identifier MessageThreadId
    __MessageThreadId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageThreadId'), 'MessageThreadId', '__httpddex_netxml20100712ddexC_MessageHeader_MessageThreadId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1530, 12), )

    
    MessageThreadId = property(__MessageThreadId.value, __MessageThreadId.set, None, 'A string used to uniquely identify the thread of Messages of which the current Message is a part.')

    
    # Element MessageId uses Python identifier MessageId
    __MessageId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageId'), 'MessageId', '__httpddex_netxml20100712ddexC_MessageHeader_MessageId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1535, 12), )

    
    MessageId = property(__MessageId.value, __MessageId.set, None, 'A string used to uniquely identify the current Message.')

    
    # Element MessageFileName uses Python identifier MessageFileName
    __MessageFileName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageFileName'), 'MessageFileName', '__httpddex_netxml20100712ddexC_MessageHeader_MessageFileName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1540, 12), )

    
    MessageFileName = property(__MessageFileName.value, __MessageFileName.set, None, 'The FileName, possibly including the FilePath, of the XML File containing the current Message.')

    
    # Element MessageSender uses Python identifier MessageSender
    __MessageSender = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageSender'), 'MessageSender', '__httpddex_netxml20100712ddexC_MessageHeader_MessageSender', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1545, 12), )

    
    MessageSender = property(__MessageSender.value, __MessageSender.set, None, 'A Composite containing details of the MessageSender.')

    
    # Element SentOnBehalfOf uses Python identifier SentOnBehalfOf
    __SentOnBehalfOf = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SentOnBehalfOf'), 'SentOnBehalfOf', '__httpddex_netxml20100712ddexC_MessageHeader_SentOnBehalfOf', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1550, 12), )

    
    SentOnBehalfOf = property(__SentOnBehalfOf.value, __SentOnBehalfOf.set, None, 'A Composite containing details of the Party on whose behalf the Message is sent.')

    
    # Element MessageRecipient uses Python identifier MessageRecipient
    __MessageRecipient = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageRecipient'), 'MessageRecipient', '__httpddex_netxml20100712ddexC_MessageHeader_MessageRecipient', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1555, 12), )

    
    MessageRecipient = property(__MessageRecipient.value, __MessageRecipient.set, None, 'A Composite containing details of the MessageRecipient.')

    
    # Element MessageCreatedDateTime uses Python identifier MessageCreatedDateTime
    __MessageCreatedDateTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageCreatedDateTime'), 'MessageCreatedDateTime', '__httpddex_netxml20100712ddexC_MessageHeader_MessageCreatedDateTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1560, 12), )

    
    MessageCreatedDateTime = property(__MessageCreatedDateTime.value, __MessageCreatedDateTime.set, None, 'The DateTime on which the Message was created (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).')

    
    # Element MessageAuditTrail uses Python identifier MessageAuditTrail
    __MessageAuditTrail = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageAuditTrail'), 'MessageAuditTrail', '__httpddex_netxml20100712ddexC_MessageHeader_MessageAuditTrail', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1565, 12), )

    
    MessageAuditTrail = property(__MessageAuditTrail.value, __MessageAuditTrail.set, None, 'A Composite containing information about Parties in between the original MessageSender and ultimate MessageRecipient.')

    
    # Element Comment uses Python identifier Comment
    __Comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Comment'), 'Comment', '__httpddex_netxml20100712ddexC_MessageHeader_Comment', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1570, 12), )

    
    Comment = property(__Comment.value, __Comment.set, None, 'A Composite containing a human-readable Comment about the Message.')

    
    # Element MessageControlType uses Python identifier MessageControlType
    __MessageControlType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageControlType'), 'MessageControlType', '__httpddex_netxml20100712ddexC_MessageHeader_MessageControlType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1575, 12), )

    
    MessageControlType = property(__MessageControlType.value, __MessageControlType.set, None, 'The indicator used to distinguish a live Message from a test Message.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_MessageHeader_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1581, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1581, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the MessageHeader as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __MessageThreadId.name() : __MessageThreadId,
        __MessageId.name() : __MessageId,
        __MessageFileName.name() : __MessageFileName,
        __MessageSender.name() : __MessageSender,
        __SentOnBehalfOf.name() : __SentOnBehalfOf,
        __MessageRecipient.name() : __MessageRecipient,
        __MessageCreatedDateTime.name() : __MessageCreatedDateTime,
        __MessageAuditTrail.name() : __MessageAuditTrail,
        __Comment.name() : __Comment,
        __MessageControlType.name() : __MessageControlType
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MessageHeader', MessageHeader)


# Complex type {http://ddex.net/xml/20100712/ddexC}MessageNotificationPeriod with content type ELEMENT_ONLY
class MessageNotificationPeriod (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a reporting Period covered by a Message. It must contain at least one out of StartDate or EndDate. The StartDate must be earlier than the EndDate if both are provided."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageNotificationPeriod')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1587, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element StartDate uses Python identifier StartDate
    __StartDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartDate'), 'StartDate', '__httpddex_netxml20100712ddexC_MessageNotificationPeriod_StartDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1592, 12), )

    
    StartDate = property(__StartDate.value, __StartDate.set, None, 'The Date that marks the beginning of the Period (in ISO 8601:2004 format: YYYY-MM-DD). This cannot be a Date in the future.')

    
    # Element EndDate uses Python identifier EndDate
    __EndDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndDate'), 'EndDate', '__httpddex_netxml20100712ddexC_MessageNotificationPeriod_EndDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1597, 12), )

    
    EndDate = property(__EndDate.value, __EndDate.set, None, 'The Date that marks the end of the Period (in ISO 8601:2004 format: YYYY-MM-DD). This cannot be a Date in the future.')

    _ElementMap.update({
        __StartDate.name() : __StartDate,
        __EndDate.name() : __EndDate
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'MessageNotificationPeriod', MessageNotificationPeriod)


# Complex type {http://ddex.net/xml/20100712/ddexC}MessagingParty with content type ELEMENT_ONLY
class MessagingParty (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a MessagingParty."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessagingParty')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1604, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20100712ddexC_MessagingParty_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1609, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A Composite containing details of the PartyId for the Party handling the Message. If no Namespace is given, the Identifier is a DdexPartyId (DPID). Note that DPIDs are not normally used to identify Artists, Producers or other Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20100712ddexC_MessagingParty_PartyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1614, 12), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A Composite containing details of the PartyNames for the Party handling the Message.')

    
    # Element TradingName uses Python identifier TradingName
    __TradingName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TradingName'), 'TradingName', '__httpddex_netxml20100712ddexC_MessagingParty_TradingName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1619, 12), )

    
    TradingName = property(__TradingName.value, __TradingName.set, None, 'A Composite containing a TradingName for the Party handling the Message.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_MessagingParty_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1625, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1625, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the MessagingParty as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName,
        __TradingName.name() : __TradingName
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MessagingParty', MessagingParty)


# Complex type {http://ddex.net/xml/20100712/ddexC}MIDI with content type ELEMENT_ONLY
class MIDI (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a MIDI."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MIDI')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1631, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MidiType uses Python identifier MidiType
    __MidiType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MidiType'), 'MidiType', '__httpddex_netxml20100712ddexC_MIDI_MidiType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1636, 12), )

    
    MidiType = property(__MidiType.value, __MidiType.set, None, 'A Composite containing details of the Type of the MIDI.')

    
    # Element IsArtistRelated uses Python identifier IsArtistRelated
    __IsArtistRelated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), 'IsArtistRelated', '__httpddex_netxml20100712ddexC_MIDI_IsArtistRelated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1641, 12), )

    
    IsArtistRelated = property(__IsArtistRelated.value, __IsArtistRelated.set, None, 'The Flag indicating whether the MIDI is related to an Artist (=True) or not (=False).')

    
    # Element MidiId uses Python identifier MidiId
    __MidiId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MidiId'), 'MidiId', '__httpddex_netxml20100712ddexC_MIDI_MidiId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1646, 12), )

    
    MidiId = property(__MidiId.value, __MidiId.set, None, 'A Composite containing details of Identifiers of the Midi.')

    
    # Element IndirectMidiId uses Python identifier IndirectMidiId
    __IndirectMidiId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectMidiId'), 'IndirectMidiId', '__httpddex_netxml20100712ddexC_MIDI_IndirectMidiId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1651, 12), )

    
    IndirectMidiId = property(__IndirectMidiId.value, __IndirectMidiId.set, None, 'A Composite containing details of a MusicalWorkId of a MusicalWork used in the MIDI.')

    
    # Element ResourceReference uses Python identifier ResourceReference
    __ResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReference'), 'ResourceReference', '__httpddex_netxml20100712ddexC_MIDI_ResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1656, 12), )

    
    ResourceReference = property(__ResourceReference.value, __ResourceReference.set, None, 'The Identifier (specific to the Message) of the MIDI within the Release which contains it. This LocalAnchor is a string starting with the letter A.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20100712ddexC_MIDI_ReferenceTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1661, 12), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A Composite containing details of the ReferenceTitle of the MIDI.')

    
    # Element InstrumentationDescription uses Python identifier InstrumentationDescription
    __InstrumentationDescription = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'InstrumentationDescription'), 'InstrumentationDescription', '__httpddex_netxml20100712ddexC_MIDI_InstrumentationDescription', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1666, 12), )

    
    InstrumentationDescription = property(__InstrumentationDescription.value, __InstrumentationDescription.set, None, 'A Composite containing a Description of the Type of instrumentation of the MusicalWork(s) in the MIDI.')

    
    # Element IsMedley uses Python identifier IsMedley
    __IsMedley = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsMedley'), 'IsMedley', '__httpddex_netxml20100712ddexC_MIDI_IsMedley', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1671, 12), )

    
    IsMedley = property(__IsMedley.value, __IsMedley.set, None, 'The Flag indicating whether the MIDI is a Medley (=True) or not (=False).')

    
    # Element IsPotpourri uses Python identifier IsPotpourri
    __IsPotpourri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsPotpourri'), 'IsPotpourri', '__httpddex_netxml20100712ddexC_MIDI_IsPotpourri', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1676, 12), )

    
    IsPotpourri = property(__IsPotpourri.value, __IsPotpourri.set, None, 'The Flag indicating whether the MIDI is a Potpourri (=True) or not (=False).')

    
    # Element IsInstrumental uses Python identifier IsInstrumental
    __IsInstrumental = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsInstrumental'), 'IsInstrumental', '__httpddex_netxml20100712ddexC_MIDI_IsInstrumental', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1681, 12), )

    
    IsInstrumental = property(__IsInstrumental.value, __IsInstrumental.set, None, 'The Flag indicating whether the MIDI is instrumental (=True) or not (=False).')

    
    # Element IsBackground uses Python identifier IsBackground
    __IsBackground = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsBackground'), 'IsBackground', '__httpddex_netxml20100712ddexC_MIDI_IsBackground', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1686, 12), )

    
    IsBackground = property(__IsBackground.value, __IsBackground.set, None, 'The Flag indicating whether the MIDI is used as background to other audio or audiovisual material (=True) or not (=False).')

    
    # Element IsHiddenResource uses Python identifier IsHiddenResource
    __IsHiddenResource = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsHiddenResource'), 'IsHiddenResource', '__httpddex_netxml20100712ddexC_MIDI_IsHiddenResource', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1691, 12), )

    
    IsHiddenResource = property(__IsHiddenResource.value, __IsHiddenResource.set, None, 'The Flag indicating whether the MIDI is hidden in some way from the Consumer (=True) or not (=False).')

    
    # Element IsBonusResource uses Python identifier IsBonusResource
    __IsBonusResource = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsBonusResource'), 'IsBonusResource', '__httpddex_netxml20100712ddexC_MIDI_IsBonusResource', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1696, 12), )

    
    IsBonusResource = property(__IsBonusResource.value, __IsBonusResource.set, None, 'The Flag indicating whether the MIDI is additional to those on the original Release of which this is a Version (=True) or not (=False).')

    
    # Element IsComputerGenerated uses Python identifier IsComputerGenerated
    __IsComputerGenerated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsComputerGenerated'), 'IsComputerGenerated', '__httpddex_netxml20100712ddexC_MIDI_IsComputerGenerated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1701, 12), )

    
    IsComputerGenerated = property(__IsComputerGenerated.value, __IsComputerGenerated.set, None, 'The Flag indicating whether the MIDI is generated by a computer (=True) or not (=False).')

    
    # Element LanguageOfPerformance uses Python identifier LanguageOfPerformance
    __LanguageOfPerformance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LanguageOfPerformance'), 'LanguageOfPerformance', '__httpddex_netxml20100712ddexC_MIDI_LanguageOfPerformance', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1706, 12), )

    
    LanguageOfPerformance = property(__LanguageOfPerformance.value, __LanguageOfPerformance.set, None, 'The Language of the Performance recorded in the MIDI (represented by an ISO 639-2 LanguageCode).')

    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20100712ddexC_MIDI_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1711, 12), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The Duration of the MIDI (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_MIDI_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1716, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the MIDI.')

    
    # Element ResourceMusicalWorkReferenceList uses Python identifier ResourceMusicalWorkReferenceList
    __ResourceMusicalWorkReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), 'ResourceMusicalWorkReferenceList', '__httpddex_netxml20100712ddexC_MIDI_ResourceMusicalWorkReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1721, 12), )

    
    ResourceMusicalWorkReferenceList = property(__ResourceMusicalWorkReferenceList.value, __ResourceMusicalWorkReferenceList.set, None, 'A Composite containing details of one or more MusicalWorks contained in the MIDI.')

    
    # Element ResourceContainedResourceReferenceList uses Python identifier ResourceContainedResourceReferenceList
    __ResourceContainedResourceReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), 'ResourceContainedResourceReferenceList', '__httpddex_netxml20100712ddexC_MIDI_ResourceContainedResourceReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1726, 12), )

    
    ResourceContainedResourceReferenceList = property(__ResourceContainedResourceReferenceList.value, __ResourceContainedResourceReferenceList.set, None, 'A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current MIDI.')

    
    # Element CreationDate uses Python identifier CreationDate
    __CreationDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CreationDate'), 'CreationDate', '__httpddex_netxml20100712ddexC_MIDI_CreationDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1731, 12), )

    
    CreationDate = property(__CreationDate.value, __CreationDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the MIDI was created.')

    
    # Element MasteredDate uses Python identifier MasteredDate
    __MasteredDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MasteredDate'), 'MasteredDate', '__httpddex_netxml20100712ddexC_MIDI_MasteredDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1736, 12), )

    
    MasteredDate = property(__MasteredDate.value, __MasteredDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the MIDI was originally mastered (either in analogue or digital form).')

    
    # Element MidiDetailsByTerritory uses Python identifier MidiDetailsByTerritory
    __MidiDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MidiDetailsByTerritory'), 'MidiDetailsByTerritory', '__httpddex_netxml20100712ddexC_MIDI_MidiDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1741, 12), )

    
    MidiDetailsByTerritory = property(__MidiDetailsByTerritory.value, __MidiDetailsByTerritory.set, None, 'A Composite containing details of Descriptors and other attributes of the MIDI which may vary according to Territory of release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_MIDI_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1747, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1747, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the MIDI as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __MidiType.name() : __MidiType,
        __IsArtistRelated.name() : __IsArtistRelated,
        __MidiId.name() : __MidiId,
        __IndirectMidiId.name() : __IndirectMidiId,
        __ResourceReference.name() : __ResourceReference,
        __ReferenceTitle.name() : __ReferenceTitle,
        __InstrumentationDescription.name() : __InstrumentationDescription,
        __IsMedley.name() : __IsMedley,
        __IsPotpourri.name() : __IsPotpourri,
        __IsInstrumental.name() : __IsInstrumental,
        __IsBackground.name() : __IsBackground,
        __IsHiddenResource.name() : __IsHiddenResource,
        __IsBonusResource.name() : __IsBonusResource,
        __IsComputerGenerated.name() : __IsComputerGenerated,
        __LanguageOfPerformance.name() : __LanguageOfPerformance,
        __Duration.name() : __Duration,
        __RightsAgreementId.name() : __RightsAgreementId,
        __ResourceMusicalWorkReferenceList.name() : __ResourceMusicalWorkReferenceList,
        __ResourceContainedResourceReferenceList.name() : __ResourceContainedResourceReferenceList,
        __CreationDate.name() : __CreationDate,
        __MasteredDate.name() : __MasteredDate,
        __MidiDetailsByTerritory.name() : __MidiDetailsByTerritory
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MIDI', MIDI)


# Complex type {http://ddex.net/xml/20100712/ddexC}MidiDetailsByTerritory with content type ELEMENT_ONLY
class MidiDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Descriptors and other attributes of a MIDI which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MidiDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1753, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1759, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the MIDI details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1764, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the MIDI details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1770, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the MIDI.')

    
    # Element DisplayArtist uses Python identifier DisplayArtist
    __DisplayArtist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), 'DisplayArtist', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_DisplayArtist', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1775, 12), )

    
    DisplayArtist = property(__DisplayArtist.value, __DisplayArtist.set, None, 'A Composite containing details of the DisplayArtist for the MIDI. The DisplayArtist may be described through Name, Identifier and Roles.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1780, 12), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A Composite containing details of a Contributor to the MIDI.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1785, 12), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A Composite containing details of an indirect Contributor to the MIDI.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1790, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the MIDI.')

    
    # Element LabelName uses Python identifier LabelName
    __LabelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LabelName'), 'LabelName', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_LabelName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1795, 12), )

    
    LabelName = property(__LabelName.value, __LabelName.set, None, 'A Composite containing the Name of the Label under which the Release is to be marketed.')

    
    # Element RightsController uses Python identifier RightsController
    __RightsController = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsController'), 'RightsController', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_RightsController', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1800, 12), )

    
    RightsController = property(__RightsController.value, __RightsController.set, None, 'A Composite containing details of RightsController of Rights in the MIDI.')

    
    # Element RemasteredDate uses Python identifier RemasteredDate
    __RemasteredDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), 'RemasteredDate', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_RemasteredDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1805, 12), )

    
    RemasteredDate = property(__RemasteredDate.value, __RemasteredDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the MIDI was re-mastered (usually digitally).')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1810, 12), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the MIDI was originally published, whether for physical or electronic/online distribution.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1815, 12), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A Composite containing details of the CLine for the MIDI.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_MidiDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1821, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1821, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the MidiDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __Title.name() : __Title,
        __DisplayArtist.name() : __DisplayArtist,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __RightsAgreementId.name() : __RightsAgreementId,
        __LabelName.name() : __LabelName,
        __RightsController.name() : __RightsController,
        __RemasteredDate.name() : __RemasteredDate,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate,
        __CLine.name() : __CLine
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MidiDetailsByTerritory', MidiDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}MidiId with content type ELEMENT_ONLY
class MidiId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Identifiers of a Midi."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MidiId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1827, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_MidiId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1832, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the Midi.')

    _ElementMap.update({
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'MidiId', MidiId)


# Complex type {http://ddex.net/xml/20100712/ddexC}MusicalWork with content type ELEMENT_ONLY
class MusicalWork (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a MusicalWork."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWork')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1858, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MusicalWorkId uses Python identifier MusicalWorkId
    __MusicalWorkId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkId'), 'MusicalWorkId', '__httpddex_netxml20100712ddexC_MusicalWork_MusicalWorkId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1863, 12), )

    
    MusicalWorkId = property(__MusicalWorkId.value, __MusicalWorkId.set, None, 'A Composite containing details of a MusicalWorkId of the MusicalWork.')

    
    # Element MusicalWorkReference uses Python identifier MusicalWorkReference
    __MusicalWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkReference'), 'MusicalWorkReference', '__httpddex_netxml20100712ddexC_MusicalWork_MusicalWorkReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1868, 12), )

    
    MusicalWorkReference = property(__MusicalWorkReference.value, __MusicalWorkReference.set, None, 'The Identifier (specific to the Message) of the MusicalWork within the Release which contains it. This LocalAnchor is a string starting with the letter W.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20100712ddexC_MusicalWork_ReferenceTitle', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1873, 12), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A Composite containing details of a ReferenceTitle of the MusicalWork.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_MusicalWork_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1878, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork.')

    
    # Element MusicalWorkContributor uses Python identifier MusicalWorkContributor
    __MusicalWorkContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor'), 'MusicalWorkContributor', '__httpddex_netxml20100712ddexC_MusicalWork_MusicalWorkContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1883, 12), )

    
    MusicalWorkContributor = property(__MusicalWorkContributor.value, __MusicalWorkContributor.set, None, 'A Composite containing details a MusicalWorkContributor to the MusicalWork.')

    
    # Element MusicalWorkType uses Python identifier MusicalWorkType
    __MusicalWorkType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkType'), 'MusicalWorkType', '__httpddex_netxml20100712ddexC_MusicalWork_MusicalWorkType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1888, 12), )

    
    MusicalWorkType = property(__MusicalWorkType.value, __MusicalWorkType.set, None, 'A Composite containing details of the Type of the MusicalWork.')

    
    # Element RightShare uses Python identifier RightShare
    __RightShare = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShare'), 'RightShare', '__httpddex_netxml20100712ddexC_MusicalWork_RightShare', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1893, 12), )

    
    RightShare = property(__RightShare.value, __RightShare.set, None, 'A Composite containing details of a RightShare for the MusicalWork.')

    
    # Element MusicalWorkDetailsByTerritory uses Python identifier MusicalWorkDetailsByTerritory
    __MusicalWorkDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkDetailsByTerritory'), 'MusicalWorkDetailsByTerritory', '__httpddex_netxml20100712ddexC_MusicalWork_MusicalWorkDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1898, 12), )

    
    MusicalWorkDetailsByTerritory = property(__MusicalWorkDetailsByTerritory.value, __MusicalWorkDetailsByTerritory.set, None, 'A Composite containing details of Descriptors and other attributes of the MusicalWork which may vary according to Territory of release.')

    
    # Attribute IsUpdated uses Python identifier IsUpdated
    __IsUpdated = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsUpdated'), 'IsUpdated', '__httpddex_netxml20100712ddexC_MusicalWork_IsUpdated', pyxb.binding.datatypes.boolean)
    __IsUpdated._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1904, 8)
    __IsUpdated._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1904, 8)
    
    IsUpdated = property(__IsUpdated.value, __IsUpdated.set, None, 'The Flag indicating whether the MusicalWork Element was updated (=True) or not (=False). The Flag may only be used when the UpdateIndicator is set to UpdateMessage. When this Boolean Flag is set to true, the MessageRecipient is expected to replace any previously provided MusicalWork data with the now provided data.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_MusicalWork_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1909, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1909, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the MusicalWork as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __MusicalWorkId.name() : __MusicalWorkId,
        __MusicalWorkReference.name() : __MusicalWorkReference,
        __ReferenceTitle.name() : __ReferenceTitle,
        __RightsAgreementId.name() : __RightsAgreementId,
        __MusicalWorkContributor.name() : __MusicalWorkContributor,
        __MusicalWorkType.name() : __MusicalWorkType,
        __RightShare.name() : __RightShare,
        __MusicalWorkDetailsByTerritory.name() : __MusicalWorkDetailsByTerritory
    })
    _AttributeMap.update({
        __IsUpdated.name() : __IsUpdated,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWork', MusicalWork)


# Complex type {http://ddex.net/xml/20100712/ddexC}MusicalWorkDetailsByTerritory with content type ELEMENT_ONLY
class MusicalWorkDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Descriptors and other attributes of a MusicalWork which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1960, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_MusicalWorkDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1966, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the MusicalWork details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_MusicalWorkDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1971, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the MusicalWork details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element MusicalWorkContributor uses Python identifier MusicalWorkContributor
    __MusicalWorkContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor'), 'MusicalWorkContributor', '__httpddex_netxml20100712ddexC_MusicalWorkDetailsByTerritory_MusicalWorkContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1977, 12), )

    
    MusicalWorkContributor = property(__MusicalWorkContributor.value, __MusicalWorkContributor.set, None, 'A Composite containing details a MusicalWorkContributor to the MusicalWork.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_MusicalWorkDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1983, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1983, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the MusicalWorkDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __MusicalWorkContributor.name() : __MusicalWorkContributor
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkDetailsByTerritory', MusicalWorkDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}MusicalWorkId with content type ELEMENT_ONLY
class MusicalWorkId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a MusicalWorkId."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1989, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISWC uses Python identifier ISWC
    __ISWC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISWC'), 'ISWC', '__httpddex_netxml20100712ddexC_MusicalWorkId_ISWC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1994, 12), )

    
    ISWC = property(__ISWC.value, __ISWC.set, None, 'The ISWC (International Standard Musical Work Code defined in ISO 15707) identifying the MusicalWork. An ISWC comprises three parts: the letter "T", followed by nine digits and then one check digit.')

    
    # Element OpusNumber uses Python identifier OpusNumber
    __OpusNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OpusNumber'), 'OpusNumber', '__httpddex_netxml20100712ddexC_MusicalWorkId_OpusNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1999, 12), )

    
    OpusNumber = property(__OpusNumber.value, __OpusNumber.set, None, 'The MusicalWorkId identifying the MusicalWork within the catalog of its Composer (typically of classical music) as an opus number.')

    
    # Element ComposerCatalogNumber uses Python identifier ComposerCatalogNumber
    __ComposerCatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ComposerCatalogNumber'), 'ComposerCatalogNumber', '__httpddex_netxml20100712ddexC_MusicalWorkId_ComposerCatalogNumber', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2004, 12), )

    
    ComposerCatalogNumber = property(__ComposerCatalogNumber.value, __ComposerCatalogNumber.set, None, 'A MusicalWorkId identifying a MusicalWork within the catalog of its Composer (typically of classical music) according to a standardized numbering (e.g. "K" numbers for Koechel\'s catalog of Mozart).')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_MusicalWorkId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2009, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the MusicalWork.')

    _ElementMap.update({
        __ISWC.name() : __ISWC,
        __OpusNumber.name() : __OpusNumber,
        __ComposerCatalogNumber.name() : __ComposerCatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkId', MusicalWorkId)


# Complex type {http://ddex.net/xml/20100712/ddexC}Name with content type SIMPLE
class Name (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Name."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Name')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2035, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Name_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2041, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2041, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the Name as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Name', Name)


# Complex type {http://ddex.net/xml/20100712/ddexC}NumberOfSubscribers with content type ELEMENT_ONLY
class NumberOfSubscribers (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a NumberOfSubscribers (applicable only where a Subscription Service is employed)."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'NumberOfSubscribers')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2063, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Quantity uses Python identifier Quantity
    __Quantity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Quantity'), 'Quantity', '__httpddex_netxml20100712ddexC_NumberOfSubscribers_Quantity', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2068, 12), )

    
    Quantity = property(__Quantity.value, __Quantity.set, None, 'The number of Consumers using the DSP service specified for the UseType.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20100712ddexC_NumberOfSubscribers_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2073, 12), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20100712ddexC_NumberOfSubscribers_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2078, 12), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A Composite containing details of a physical interface by which a Consumer uses a Service or Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20100712ddexC_NumberOfSubscribers_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2083, 12), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20100712ddexC_NumberOfSubscribers_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2088, 12), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A Composite containing details of a Carrier.')

    _ElementMap.update({
        __Quantity.name() : __Quantity,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'NumberOfSubscribers', NumberOfSubscribers)


# Complex type {http://ddex.net/xml/20100712/ddexC}PartyDescriptor with content type ELEMENT_ONLY
class PartyDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Party. Parties are typically described through Names and/or Identifiers."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PartyDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2157, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20100712ddexC_PartyDescriptor_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A Composite containing details of the PartyId for the Party. If no Namespace is given, the Identifier is a DdexPartyId (DPID). Note that DPIDs are not normally used to identify Artists, Producers or other Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20100712ddexC_PartyDescriptor_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A Composite containing details of the PartyName(s).')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'PartyDescriptor', PartyDescriptor)


# Complex type {http://ddex.net/xml/20100712/ddexC}PartyId with content type SIMPLE
class PartyId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a PartyId. If no Namespace is given, the Identifier is a DdexPartyId (DPID). Note that DPIDs are not normally used to identify Artists, Producers or other Creators."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PartyId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2181, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_PartyId_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2187, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2187, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the PartyId if it belongs to a proprietary Party ID scheme. If the PartyId is a DPID, the Namespace Element must not be used. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'PartyId', PartyId)


# Complex type {http://ddex.net/xml/20100712/ddexC}PartyName with content type ELEMENT_ONLY
class PartyName (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a PartyName. Name details for a Party typically either contain a FullName or a KeyName."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PartyName')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2195, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element FullName uses Python identifier FullName
    __FullName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FullName'), 'FullName', '__httpddex_netxml20100712ddexC_PartyName_FullName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2200, 12), )

    
    FullName = property(__FullName.value, __FullName.set, None, 'A Composite containing the complete Name of the Party, in its normal form of presentation (e.g. John H. Smith, Acme Music Inc, A Composite containing the Beatles).')

    
    # Element FullNameAsciiTranscribed uses Python identifier FullNameAsciiTranscribed
    __FullNameAsciiTranscribed = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FullNameAsciiTranscribed'), 'FullNameAsciiTranscribed', '__httpddex_netxml20100712ddexC_PartyName_FullNameAsciiTranscribed', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2205, 12), )

    
    FullNameAsciiTranscribed = property(__FullNameAsciiTranscribed.value, __FullNameAsciiTranscribed.set, None, 'The FullName transcribed using 7-bit ASCII code.')

    
    # Element FullNameIndexed uses Python identifier FullNameIndexed
    __FullNameIndexed = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FullNameIndexed'), 'FullNameIndexed', '__httpddex_netxml20100712ddexC_PartyName_FullNameIndexed', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2210, 12), )

    
    FullNameIndexed = property(__FullNameIndexed.value, __FullNameIndexed.set, None, 'A Composite containing the complete Name of the Party in the form in which it normally appears in an alphabetic index, with the KeyName first (e.g. Smith, John H.; Beatles, A Composite containing the).')

    
    # Element NamesBeforeKeyName uses Python identifier NamesBeforeKeyName
    __NamesBeforeKeyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NamesBeforeKeyName'), 'NamesBeforeKeyName', '__httpddex_netxml20100712ddexC_PartyName_NamesBeforeKeyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2215, 12), )

    
    NamesBeforeKeyName = property(__NamesBeforeKeyName.value, __NamesBeforeKeyName.set, None, 'A Composite containing the Name(s) preceding the KeyName in the FullName (and that is placed after it in a FullNameIndexed). Examples: "George" in "George Michael"; "John Fitzgerald" in "John Fitzgerald Kennedy". Not all PartyNames have a NamesBeforeKeyName (e.g. Madonna, EMI Music Inc).')

    
    # Element KeyName uses Python identifier KeyName
    __KeyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'KeyName'), 'KeyName', '__httpddex_netxml20100712ddexC_PartyName_KeyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2220, 12), )

    
    KeyName = property(__KeyName.value, __KeyName.set, None, 'A Composite containing the Part of a Name of the Party normally used to index an entry in an alphabetical list, such as "Smith" (in John Smith) or "Garcia Marquez" or "Madonna" or "Francis de Sales" (in Saint Francis de Sales). For persons, this normally corresponds to the "family name" or names, which in Western name forms usually comes as a surname at the end of a FullName, and in Asian name forms often at the beginning of a FullName.')

    
    # Element NamesAfterKeyName uses Python identifier NamesAfterKeyName
    __NamesAfterKeyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NamesAfterKeyName'), 'NamesAfterKeyName', '__httpddex_netxml20100712ddexC_PartyName_NamesAfterKeyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2225, 12), )

    
    NamesAfterKeyName = property(__NamesAfterKeyName.value, __NamesAfterKeyName.set, None, 'A Composite containing the Name(s) following the KeyName. Example:"Ibrahim" (in Anwar Ibrahim). This is common, e.g., in many Asian personal name forms where a FullName begins with the KeyName, which is followed by other names.')

    
    # Element AbbreviatedName uses Python identifier AbbreviatedName
    __AbbreviatedName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AbbreviatedName'), 'AbbreviatedName', '__httpddex_netxml20100712ddexC_PartyName_AbbreviatedName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2230, 12), )

    
    AbbreviatedName = property(__AbbreviatedName.value, __AbbreviatedName.set, None, 'A Composite containing a short version of the PartyName (e.g. for use on devices with a small display).')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_PartyName_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2236, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2236, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the PartyName as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __FullName.name() : __FullName,
        __FullNameAsciiTranscribed.name() : __FullNameAsciiTranscribed,
        __FullNameIndexed.name() : __FullNameIndexed,
        __NamesBeforeKeyName.name() : __NamesBeforeKeyName,
        __KeyName.name() : __KeyName,
        __NamesAfterKeyName.name() : __NamesAfterKeyName,
        __AbbreviatedName.name() : __AbbreviatedName
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'PartyName', PartyName)


# Complex type {http://ddex.net/xml/20100712/ddexC}Period with content type ELEMENT_ONLY
class Period (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details about a Period of Time. Periods are typically described by at least a StartDate or EndDate."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Period')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2242, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element StartDate uses Python identifier StartDate
    __StartDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartDate'), 'StartDate', '__httpddex_netxml20100712ddexC_Period_StartDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2247, 12), )

    
    StartDate = property(__StartDate.value, __StartDate.set, None, 'A Composite containing details of the Date and Place of an Event that marks the beginning of the Period (in ISO 8601:2004 format: YYYY-MM-DD). The StartDate must be earlier than the EndDate if both are provided.')

    
    # Element EndDate uses Python identifier EndDate
    __EndDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndDate'), 'EndDate', '__httpddex_netxml20100712ddexC_Period_EndDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2252, 12), )

    
    EndDate = property(__EndDate.value, __EndDate.set, None, 'A Composite containing details of the Date and Place of an Event that marks the end of the Period (in ISO 8601:2004 format: YYYY-MM-DD). The EndDate must be later than the StartDate if both are provided.')

    _ElementMap.update({
        __StartDate.name() : __StartDate,
        __EndDate.name() : __EndDate
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'Period', Period)


# Complex type {http://ddex.net/xml/20100712/ddexC}PLine with content type ELEMENT_ONLY
class PLine (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a PLine."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PLine')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2259, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Year uses Python identifier Year
    __Year = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Year'), 'Year', '__httpddex_netxml20100712ddexC_PLine_Year', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2264, 12), )

    
    Year = property(__Year.value, __Year.set, None, 'The Year of the PLine.')

    
    # Element PLineText uses Python identifier PLineText
    __PLineText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLineText'), 'PLineText', '__httpddex_netxml20100712ddexC_PLine_PLineText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2269, 12), )

    
    PLineText = property(__PLineText.value, __PLineText.set, None, 'The text of the PLine.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_PLine_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2275, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2275, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the PLineText as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __Year.name() : __Year,
        __PLineText.name() : __PLineText
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'PLine', PLine)


# Complex type {http://ddex.net/xml/20100712/ddexC}PriceInformation with content type ELEMENT_ONLY
class PriceInformation (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Price."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PriceInformation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2309, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PriceRangeType uses Python identifier PriceRangeType
    __PriceRangeType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PriceRangeType'), 'PriceRangeType', '__httpddex_netxml20100712ddexC_PriceInformation_PriceRangeType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2314, 12), )

    
    PriceRangeType = property(__PriceRangeType.value, __PriceRangeType.set, None, 'A Composite containing a Type of Price according to its value range. Typical examples include "budget" and "front line".')

    
    # Element PriceType uses Python identifier PriceType
    __PriceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PriceType'), 'PriceType', '__httpddex_netxml20100712ddexC_PriceInformation_PriceType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2319, 12), )

    
    PriceType = property(__PriceType.value, __PriceType.set, None, 'A Composite containing further details of the Price. Often used to refine the PriceRangeType.')

    
    # Element WholesalePricePerUnit uses Python identifier WholesalePricePerUnit
    __WholesalePricePerUnit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'WholesalePricePerUnit'), 'WholesalePricePerUnit', '__httpddex_netxml20100712ddexC_PriceInformation_WholesalePricePerUnit', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2324, 12), )

    
    WholesalePricePerUnit = property(__WholesalePricePerUnit.value, __WholesalePricePerUnit.set, None, 'A Composite containing details of a wholesale Price for a single unit of Usage. Note that this Price applies to all UseTypes referenced in a DealTerm Composite.')

    
    # Element BulkOrderWholesalePricePerUnit uses Python identifier BulkOrderWholesalePricePerUnit
    __BulkOrderWholesalePricePerUnit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'BulkOrderWholesalePricePerUnit'), 'BulkOrderWholesalePricePerUnit', '__httpddex_netxml20100712ddexC_PriceInformation_BulkOrderWholesalePricePerUnit', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2329, 12), )

    
    BulkOrderWholesalePricePerUnit = property(__BulkOrderWholesalePricePerUnit.value, __BulkOrderWholesalePricePerUnit.set, None, 'A Composite containing details of a wholesale Price for a single unit. Note that the size of a bulk order is defined in the contract between MessageSender and the MessageRecipient.')

    
    # Element SuggestedRetailPrice uses Python identifier SuggestedRetailPrice
    __SuggestedRetailPrice = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SuggestedRetailPrice'), 'SuggestedRetailPrice', '__httpddex_netxml20100712ddexC_PriceInformation_SuggestedRetailPrice', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2334, 12), )

    
    SuggestedRetailPrice = property(__SuggestedRetailPrice.value, __SuggestedRetailPrice.set, None, 'A Composite containing details of a suggested retail Price.')

    _ElementMap.update({
        __PriceRangeType.name() : __PriceRangeType,
        __PriceType.name() : __PriceType,
        __WholesalePricePerUnit.name() : __WholesalePricePerUnit,
        __BulkOrderWholesalePricePerUnit.name() : __BulkOrderWholesalePricePerUnit,
        __SuggestedRetailPrice.name() : __SuggestedRetailPrice
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'PriceInformation', PriceInformation)


# Complex type {http://ddex.net/xml/20100712/ddexC}PromotionalCode with content type SIMPLE
class PromotionalCode (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a PromotionalCode."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PromotionalCode')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2388, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_PromotionalCode_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2394, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2394, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the PromotionalCode. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'PromotionalCode', PromotionalCode)


# Complex type {http://ddex.net/xml/20100712/ddexC}ProprietaryId with content type SIMPLE
class ProprietaryId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ProprietaryIdentifier."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ProprietaryId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2402, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ProprietaryId_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2408, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2408, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ProprietaryId. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'ProprietaryId', ProprietaryId)


# Complex type {http://ddex.net/xml/20100712/ddexC}Reason with content type SIMPLE
class Reason (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Reason."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Reason')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2454, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Reason_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2460, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2460, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the Reason as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Reason', Reason)


# Complex type {http://ddex.net/xml/20100712/ddexC}RecordCompanyMarketShareData with content type ELEMENT_ONLY
class RecordCompanyMarketShareData (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing information to support the calculation of a record company's market share of all Releases provided by a DSP to Consumers for a specified UseType."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RecordCompanyMarketShareData')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2487, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseType uses Python identifier ReleaseType
    __ReleaseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseType'), 'ReleaseType', '__httpddex_netxml20100712ddexC_RecordCompanyMarketShareData_ReleaseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2492, 12), )

    
    ReleaseType = property(__ReleaseType.value, __ReleaseType.set, None, 'A Composite containing details of the form in which a ReleaseCreator anticipates offering the Release to Consumers.')

    
    # Element UnitsSoldTotal uses Python identifier UnitsSoldTotal
    __UnitsSoldTotal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UnitsSoldTotal'), 'UnitsSoldTotal', '__httpddex_netxml20100712ddexC_RecordCompanyMarketShareData_UnitsSoldTotal', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2497, 12), )

    
    UnitsSoldTotal = property(__UnitsSoldTotal.value, __UnitsSoldTotal.set, None, 'The total number of Releases sold of the ReleaseType.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20100712ddexC_RecordCompanyMarketShareData_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2502, 12), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20100712ddexC_RecordCompanyMarketShareData_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2507, 12), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A Composite containing details of a physical interface by which a Consumer uses a Service or Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20100712ddexC_RecordCompanyMarketShareData_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2512, 12), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20100712ddexC_RecordCompanyMarketShareData_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2517, 12), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A Composite containing details of a Carrier.')

    _ElementMap.update({
        __ReleaseType.name() : __ReleaseType,
        __UnitsSoldTotal.name() : __UnitsSoldTotal,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'RecordCompanyMarketShareData', RecordCompanyMarketShareData)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReferenceTitle with content type ELEMENT_ONLY
class ReferenceTitle (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReferenceTitle."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReferenceTitle')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2543, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TitleText uses Python identifier TitleText
    __TitleText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TitleText'), 'TitleText', '__httpddex_netxml20100712ddexC_ReferenceTitle_TitleText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2548, 12), )

    
    TitleText = property(__TitleText.value, __TitleText.set, None, 'A Composite containing the text of the ReferenceTitle.')

    
    # Element SubTitle uses Python identifier SubTitle
    __SubTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SubTitle'), 'SubTitle', '__httpddex_netxml20100712ddexC_ReferenceTitle_SubTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2553, 12), )

    
    SubTitle = property(__SubTitle.value, __SubTitle.set, None, 'A Composite containing details of a SubTitle of the ReferenceTitle, including Titles of Versions used to differentiate different versions of the same Title, as required by the GRId and ISRC ReferenceDescriptiveMetadataSets.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_ReferenceTitle_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2559, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2559, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the ReferenceTitle as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TitleText.name() : __TitleText,
        __SubTitle.name() : __SubTitle
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'ReferenceTitle', ReferenceTitle)


# Complex type {http://ddex.net/xml/20100712/ddexC}RelatedRelease with content type ELEMENT_ONLY
class RelatedRelease (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Release (or a PhysicalProduct or a DigitalProduct derived from such a Release) which is related to a Resource, Release or Product."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RelatedRelease')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2565, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20100712ddexC_RelatedRelease_ReleaseId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2570, 12), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A Composite containing details of ReleaseIds. If available, a GRid shall always to be used. If the Release contains only one SoundRecording, the ISRC of the SoundRecording may be used instead. If the Release is an abstraction of a complete PhysicalProduct (such as a CD Album), the ICPN of the PhysicalProduct may be used instead. More than one of these identifiers may be provided.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20100712ddexC_RelatedRelease_ReferenceTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2575, 12), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A Composite containing details of the ReferenceTitle of the Release.')

    
    # Element ReleaseSummaryDetailsByTerritory uses Python identifier ReleaseSummaryDetailsByTerritory
    __ReleaseSummaryDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory'), 'ReleaseSummaryDetailsByTerritory', '__httpddex_netxml20100712ddexC_RelatedRelease_ReleaseSummaryDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2580, 12), )

    
    ReleaseSummaryDetailsByTerritory = property(__ReleaseSummaryDetailsByTerritory.value, __ReleaseSummaryDetailsByTerritory.set, None, 'A Composite containing summary details of Descriptors and other attributes of the Release which may vary according to Territory of Release. Territory of Release may be the world.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_RelatedRelease_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2585, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Release.')

    
    # Element ReleaseRelationshipType uses Python identifier ReleaseRelationshipType
    __ReleaseRelationshipType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseRelationshipType'), 'ReleaseRelationshipType', '__httpddex_netxml20100712ddexC_RelatedRelease_ReleaseRelationshipType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2590, 12), )

    
    ReleaseRelationshipType = property(__ReleaseRelationshipType.value, __ReleaseRelationshipType.set, None, 'A Composite containing details of the Type of the relationship between the two Releases.')

    
    # Element ReleaseDate uses Python identifier ReleaseDate
    __ReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseDate'), 'ReleaseDate', '__httpddex_netxml20100712ddexC_RelatedRelease_ReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2595, 12), )

    
    ReleaseDate = property(__ReleaseDate.value, __ReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the related Release is made available for Usage.')

    
    # Element OriginalReleaseDate uses Python identifier OriginalReleaseDate
    __OriginalReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate'), 'OriginalReleaseDate', '__httpddex_netxml20100712ddexC_RelatedRelease_OriginalReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2600, 12), )

    
    OriginalReleaseDate = property(__OriginalReleaseDate.value, __OriginalReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Release was or will be first made available for Usage, whether for physical or electronic/online distribution (in ISO 8601:2004 format: YYYY-MM-DD).')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_RelatedRelease_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2606, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2606, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the ReleatedRelease as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __ReleaseId.name() : __ReleaseId,
        __ReferenceTitle.name() : __ReferenceTitle,
        __ReleaseSummaryDetailsByTerritory.name() : __ReleaseSummaryDetailsByTerritory,
        __RightsAgreementId.name() : __RightsAgreementId,
        __ReleaseRelationshipType.name() : __ReleaseRelationshipType,
        __ReleaseDate.name() : __ReleaseDate,
        __OriginalReleaseDate.name() : __OriginalReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'RelatedRelease', RelatedRelease)


# Complex type {http://ddex.net/xml/20100712/ddexC}Release with content type ELEMENT_ONLY
class Release (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a DDEX Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Release')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2612, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20100712ddexC_Release_ReleaseId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2617, 12), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A Composite containing details of ReleaseIds. If available, a GRid shall always to be used. If the Release contains only one SoundRecording, the ISRC of the SoundRecording may be used instead. If the Release is an abstraction of a complete PhysicalProduct (such as a CD Album), the ICPN of the PhysicalProduct may be used instead. More than one of these identifiers may be provided.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20100712ddexC_Release_ReferenceTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2622, 12), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A Composite containing details of the ReferenceTitle of the Release.')

    
    # Element ReleaseResourceReferenceList uses Python identifier ReleaseResourceReferenceList
    __ReleaseResourceReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseResourceReferenceList'), 'ReleaseResourceReferenceList', '__httpddex_netxml20100712ddexC_Release_ReleaseResourceReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2627, 12), )

    
    ReleaseResourceReferenceList = property(__ReleaseResourceReferenceList.value, __ReleaseResourceReferenceList.set, None, 'A Composite containing details of one or more Resources contained in the Release.')

    
    # Element ReleaseType uses Python identifier ReleaseType
    __ReleaseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseType'), 'ReleaseType', '__httpddex_netxml20100712ddexC_Release_ReleaseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2632, 12), )

    
    ReleaseType = property(__ReleaseType.value, __ReleaseType.set, None, 'A Composite containing details of the form in which a ReleaseCreator anticipates offering the Release to Consumers. This may be overridden by the ReleaseType for specific Territories as specified in the ReleaseDetailsByTerritory Composite.')

    
    # Element ReleaseDetailsByTerritory uses Python identifier ReleaseDetailsByTerritory
    __ReleaseDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseDetailsByTerritory'), 'ReleaseDetailsByTerritory', '__httpddex_netxml20100712ddexC_Release_ReleaseDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2637, 12), )

    
    ReleaseDetailsByTerritory = property(__ReleaseDetailsByTerritory.value, __ReleaseDetailsByTerritory.set, None, 'A Composite containing details of Descriptors and other attributes of the Release which may vary according to Territory of release.')

    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20100712ddexC_Release_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2642, 12), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The sum of the Durations of all Resources contained in the Release (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_Release_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2647, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Release.')

    
    # Element PLine uses Python identifier PLine
    __PLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLine'), 'PLine', '__httpddex_netxml20100712ddexC_Release_PLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2652, 12), )

    
    PLine = property(__PLine.value, __PLine.set, None, 'A Composite containing details of the PLine for the Release.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20100712ddexC_Release_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2657, 12), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A Composite containing details of the CLine for the Release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Release_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2663, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2663, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the Release as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __ReleaseId.name() : __ReleaseId,
        __ReferenceTitle.name() : __ReferenceTitle,
        __ReleaseResourceReferenceList.name() : __ReleaseResourceReferenceList,
        __ReleaseType.name() : __ReleaseType,
        __ReleaseDetailsByTerritory.name() : __ReleaseDetailsByTerritory,
        __Duration.name() : __Duration,
        __RightsAgreementId.name() : __RightsAgreementId,
        __PLine.name() : __PLine,
        __CLine.name() : __CLine
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Release', Release)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseCollectionReferenceList with content type ELEMENT_ONLY
class ReleaseCollectionReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a list of ReleaseCollectionReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseCollectionReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2702, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element NumberOfCollections uses Python identifier NumberOfCollections
    __NumberOfCollections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), 'NumberOfCollections', '__httpddex_netxml20100712ddexC_ReleaseCollectionReferenceList_NumberOfCollections', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2707, 12), )

    
    NumberOfCollections = property(__NumberOfCollections.value, __NumberOfCollections.set, None, 'The number of referenced Collections (typically Chapters).')

    
    # Element ReleaseCollectionReference uses Python identifier ReleaseCollectionReference
    __ReleaseCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseCollectionReference'), 'ReleaseCollectionReference', '__httpddex_netxml20100712ddexC_ReleaseCollectionReferenceList_ReleaseCollectionReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2712, 12), )

    
    ReleaseCollectionReference = property(__ReleaseCollectionReference.value, __ReleaseCollectionReference.set, None, 'A Composite containing a ReleaseCollectionReference for a Collection (specific to this Message). The referenced Collection has to be of CollectionType Series, Season or Episode.')

    _ElementMap.update({
        __NumberOfCollections.name() : __NumberOfCollections,
        __ReleaseCollectionReference.name() : __ReleaseCollectionReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseCollectionReferenceList', ReleaseCollectionReferenceList)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseId with content type ELEMENT_ONLY
class ReleaseId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReleaseId. If available, a GRid should always to be used. If the Release contains only one SoundRecording, the ISRC of the SoundRecording may be used instead. If the Release is an abstraction of a complete PhysicalProduct (such as a CD Album), the ICPN of the PhysicalProduct may be used instead."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2760, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element GRid uses Python identifier GRid
    __GRid = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'GRid'), 'GRid', '__httpddex_netxml20100712ddexC_ReleaseId_GRid', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2765, 12), )

    
    GRid = property(__GRid.value, __GRid.set, None, 'The GRid identifying the Release. This is the preferred Element and is mandatory if a GRid is available. A GRid comprises four parts: the string "A1", followed by five alphanumeric characters, ten alphanumeric characters and and one alphanumeric character.')

    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20100712ddexC_ReleaseId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2770, 12), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ISRC (International Standard Recording Code as defined in ISO 3901) used as proxy for identification of the Release. Only applicable when the Release only contains one SoundRecording or one MusicalWorkVideo. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.')

    
    # Element ICPN uses Python identifier ICPN
    __ICPN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ICPN'), 'ICPN', '__httpddex_netxml20100712ddexC_ReleaseId_ICPN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2775, 12), )

    
    ICPN = property(__ICPN.value, __ICPN.set, None, 'A Composite containing details of the ICPN used as proxy for identification of the Release. Only applicable when the Release is an abstraction of a complete PhysicalProduct. An ICPN comprises 12 or 13 digits, depending whether it is an EAN (13) or a UPC (12).')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20100712ddexC_ReleaseId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2780, 12), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A Composite containing details of the CatalogNumber of the Release.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_ReleaseId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2785, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the Release.')

    _ElementMap.update({
        __GRid.name() : __GRid,
        __ISRC.name() : __ISRC,
        __ICPN.name() : __ICPN,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseId', ReleaseId)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseResourceReferenceList with content type ELEMENT_ONLY
class ReleaseResourceReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a list of ReleaseResourceReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseResourceReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2825, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseResourceReference uses Python identifier ReleaseResourceReference
    __ReleaseResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseResourceReference'), 'ReleaseResourceReference', '__httpddex_netxml20100712ddexC_ReleaseResourceReferenceList_ReleaseResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2830, 12), )

    
    ReleaseResourceReference = property(__ReleaseResourceReference.value, __ReleaseResourceReference.set, None, 'A Composite containing a Reference for a Resource (specific to this Message). The LocalAnchorReference in this Composite is a string starting with the letter A.')

    _ElementMap.update({
        __ReleaseResourceReference.name() : __ReleaseResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseResourceReferenceList', ReleaseResourceReferenceList)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseSummary with content type ELEMENT_ONLY
class ReleaseSummary (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing summary details of a Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseSummary')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2837, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20100712ddexC_ReleaseSummary_ReleaseId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2842, 12), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A Composite containing details of ReleaseIds. If available, a GRid shall always to be used. If the Release contains only one SoundRecording, the ISRC of the SoundRecording may be used instead. If the Release is an abstraction of a complete PhysicalProduct (such as a CD Album), the ICPN of the PhysicalProduct may be used instead. More than one of these identifiers may be provided.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20100712ddexC_ReleaseSummary_ReferenceTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2847, 12), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A Composite containing details of the ReferenceTitle of the Release.')

    
    # Element ReleaseSummaryDetailsByTerritory uses Python identifier ReleaseSummaryDetailsByTerritory
    __ReleaseSummaryDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory'), 'ReleaseSummaryDetailsByTerritory', '__httpddex_netxml20100712ddexC_ReleaseSummary_ReleaseSummaryDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2852, 12), )

    
    ReleaseSummaryDetailsByTerritory = property(__ReleaseSummaryDetailsByTerritory.value, __ReleaseSummaryDetailsByTerritory.set, None, 'A Composite containing summary details of Descriptors and other attributes of the Release which may vary according to Territory of Release. Territory of Release may be the world.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_ReleaseSummary_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2857, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_ReleaseSummary_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2863, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2863, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the ReleaseSummary as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __ReleaseId.name() : __ReleaseId,
        __ReferenceTitle.name() : __ReferenceTitle,
        __ReleaseSummaryDetailsByTerritory.name() : __ReleaseSummaryDetailsByTerritory,
        __RightsAgreementId.name() : __RightsAgreementId
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseSummary', ReleaseSummary)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseSummaryDetailsByTerritory with content type ELEMENT_ONLY
class ReleaseSummaryDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing summary details of Descriptors and other attributes of a Release which may vary according to Territory of Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseSummaryDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2869, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_ReleaseSummaryDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2875, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the ReleaseSummaryDetailsByTerritory apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_ReleaseSummaryDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2880, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the ReleaseSummaryDetailsByTerritory do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element DisplayArtistName uses Python identifier DisplayArtistName
    __DisplayArtistName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtistName'), 'DisplayArtistName', '__httpddex_netxml20100712ddexC_ReleaseSummaryDetailsByTerritory_DisplayArtistName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2886, 12), )

    
    DisplayArtistName = property(__DisplayArtistName.value, __DisplayArtistName.set, None, 'A Composite containing the Name to be used by a DSP when presenting Artist details of the Release to a Consumer.')

    
    # Element LabelName uses Python identifier LabelName
    __LabelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LabelName'), 'LabelName', '__httpddex_netxml20100712ddexC_ReleaseSummaryDetailsByTerritory_LabelName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2891, 12), )

    
    LabelName = property(__LabelName.value, __LabelName.set, None, 'A Composite containing the Name of the Label for the Release.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_ReleaseSummaryDetailsByTerritory_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2896, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_ReleaseSummaryDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2902, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2902, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the ReleaseSummaryDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __DisplayArtistName.name() : __DisplayArtistName,
        __LabelName.name() : __LabelName,
        __RightsAgreementId.name() : __RightsAgreementId
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseSummaryDetailsByTerritory', ReleaseSummaryDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}RemittanceAdvice with content type SIMPLE
class RemittanceAdvice (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an RemittanceAdvice."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RemittanceAdvice')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2927, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_RemittanceAdvice_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2933, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2933, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the RemittanceAdvice as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'RemittanceAdvice', RemittanceAdvice)


# Complex type {http://ddex.net/xml/20100712/ddexC}ResourceContainedResourceReference with content type ELEMENT_ONLY
class ResourceContainedResourceReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ResourceContainedResourceReference for the case where one Resource contains another one."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceContainedResourceReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2979, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ResourceContainedResourceReference uses Python identifier ResourceContainedResourceReference
    __ResourceContainedResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference'), 'ResourceContainedResourceReference', '__httpddex_netxml20100712ddexC_ResourceContainedResourceReference_ResourceContainedResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2984, 12), )

    
    ResourceContainedResourceReference = property(__ResourceContainedResourceReference.value, __ResourceContainedResourceReference.set, None, 'A Reference for a Resource (specific to this Message). This LocalAnchorReference is a string starting with the letter A.')

    
    # Element DurationUsed uses Python identifier DurationUsed
    __DurationUsed = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DurationUsed'), 'DurationUsed', '__httpddex_netxml20100712ddexC_ResourceContainedResourceReference_DurationUsed', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2989, 12), )

    
    DurationUsed = property(__DurationUsed.value, __DurationUsed.set, None, 'The total Duration of the Resource that has been used in a specified context (this may be less than the total Duration of the Resource) (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element StartPoint uses Python identifier StartPoint
    __StartPoint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartPoint'), 'StartPoint', '__httpddex_netxml20100712ddexC_ResourceContainedResourceReference_StartPoint', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2994, 12), )

    
    StartPoint = property(__StartPoint.value, __StartPoint.set, None, 'The start point of the preview given in seconds from the start of the referenced Resource.')

    
    # Element Purpose uses Python identifier Purpose
    __Purpose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Purpose'), 'Purpose', '__httpddex_netxml20100712ddexC_ResourceContainedResourceReference_Purpose', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2999, 12), )

    
    Purpose = property(__Purpose.value, __Purpose.set, None, 'A Composite containing details of the Purpose of the usage.')

    _ElementMap.update({
        __ResourceContainedResourceReference.name() : __ResourceContainedResourceReference,
        __DurationUsed.name() : __DurationUsed,
        __StartPoint.name() : __StartPoint,
        __Purpose.name() : __Purpose
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceContainedResourceReference', ResourceContainedResourceReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}ResourceContainedResourceReferenceList with content type ELEMENT_ONLY
class ResourceContainedResourceReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of one or more ResourceContainedResourceReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceContainedResourceReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3006, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ResourceContainedResourceReference uses Python identifier ResourceContainedResourceReference
    __ResourceContainedResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference'), 'ResourceContainedResourceReference', '__httpddex_netxml20100712ddexC_ResourceContainedResourceReferenceList_ResourceContainedResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3011, 12), )

    
    ResourceContainedResourceReference = property(__ResourceContainedResourceReference.value, __ResourceContainedResourceReference.set, None, 'A Composite containing details of a ResourceContainedResourceReference.')

    _ElementMap.update({
        __ResourceContainedResourceReference.name() : __ResourceContainedResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceContainedResourceReferenceList', ResourceContainedResourceReferenceList)


# Complex type {http://ddex.net/xml/20100712/ddexC}ResourceGroupResourceReferenceList with content type ELEMENT_ONLY
class ResourceGroupResourceReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a list of ResourceGroupResourceReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceGroupResourceReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3058, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ResourceGroupResourceReference uses Python identifier ResourceGroupResourceReference
    __ResourceGroupResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceGroupResourceReference'), 'ResourceGroupResourceReference', '__httpddex_netxml20100712ddexC_ResourceGroupResourceReferenceList_ResourceGroupResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3063, 12), )

    
    ResourceGroupResourceReference = property(__ResourceGroupResourceReference.value, __ResourceGroupResourceReference.set, None, 'A Reference for a Resource (specific to this Message). This LocalAnchorReference is a string starting with the letter A.')

    _ElementMap.update({
        __ResourceGroupResourceReference.name() : __ResourceGroupResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceGroupResourceReferenceList', ResourceGroupResourceReferenceList)


# Complex type {http://ddex.net/xml/20100712/ddexC}ResourceId with content type ELEMENT_ONLY
class ResourceId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of ResourceIds."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3070, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20100712ddexC_ResourceId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3075, 12), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ISRC (International Standard Recording Code as defined in ISO 3901) for the Resource. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.')

    
    # Element ISMN uses Python identifier ISMN
    __ISMN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISMN'), 'ISMN', '__httpddex_netxml20100712ddexC_ResourceId_ISMN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3080, 12), )

    
    ISMN = property(__ISMN.value, __ISMN.set, None, 'The ISMN (International Standard Music Number defined in ISO 10957) for the Resource. An ISMN is a thirteen-digit number. Pre-2008 ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ("M") with "979-0".')

    
    # Element ISAN uses Python identifier ISAN
    __ISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISAN'), 'ISAN', '__httpddex_netxml20100712ddexC_ResourceId_ISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3085, 12), )

    
    ISAN = property(__ISAN.value, __ISAN.set, None, 'The ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the Resource. An ISAN comprises four blocks of four hexadecimal charaters followed by a check character.')

    
    # Element VISAN uses Python identifier VISAN
    __VISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VISAN'), 'VISAN', '__httpddex_netxml20100712ddexC_ResourceId_VISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3090, 12), )

    
    VISAN = property(__VISAN.value, __VISAN.set, None, 'The V-ISAN (Version Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the Resource. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.')

    
    # Element ISBN uses Python identifier ISBN
    __ISBN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISBN'), 'ISBN', '__httpddex_netxml20100712ddexC_ResourceId_ISBN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3095, 12), )

    
    ISBN = property(__ISBN.value, __ISBN.set, None, 'The ISBN (International Standard Book Number defined in ISO 2108) for the Resource. An ISBN is a 13-digit number. Pre-2007, ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix "978" and re-calculating the check character.')

    
    # Element ISSN uses Python identifier ISSN
    __ISSN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISSN'), 'ISSN', '__httpddex_netxml20100712ddexC_ResourceId_ISSN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3100, 12), )

    
    ISSN = property(__ISSN.value, __ISSN.set, None, 'The ISSN (International Standard Serial Number defined in ISO 3297) for the Resource. An ISSN comprises two groups of four digits, separated by a hyphen and a control digit.')

    
    # Element SICI uses Python identifier SICI
    __SICI = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SICI'), 'SICI', '__httpddex_netxml20100712ddexC_ResourceId_SICI', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3105, 12), )

    
    SICI = property(__SICI.value, __SICI.set, None, 'The SICI (Serial Item and Contribution Identifier defined in ANSI/NISO Z39.56-199) for the Resource.')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20100712ddexC_ResourceId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3110, 12), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A Composite containing details of the CatalogNumber of the Resource.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_ResourceId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3115, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the Resource.')

    _ElementMap.update({
        __ISRC.name() : __ISRC,
        __ISMN.name() : __ISMN,
        __ISAN.name() : __ISAN,
        __VISAN.name() : __VISAN,
        __ISBN.name() : __ISBN,
        __ISSN.name() : __ISSN,
        __SICI.name() : __SICI,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceId', ResourceId)


# Complex type {http://ddex.net/xml/20100712/ddexC}ResourceMusicalWorkReference with content type ELEMENT_ONLY
class ResourceMusicalWorkReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a ResourceMusicalWorkReference."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceMusicalWorkReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3122, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_ResourceMusicalWorkReference_SequenceNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3127, 12), )

    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the MusicalWork in a group of MusicalWorks within a Medley, SoundRecording or other Resource.')

    
    # Element DurationUsed uses Python identifier DurationUsed
    __DurationUsed = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DurationUsed'), 'DurationUsed', '__httpddex_netxml20100712ddexC_ResourceMusicalWorkReference_DurationUsed', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3132, 12), )

    
    DurationUsed = property(__DurationUsed.value, __DurationUsed.set, None, 'The total Duration of the MusicalWork that has been used in a specified context (this may be less than the total Duration of the MusicalWork) (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element IsFragment uses Python identifier IsFragment
    __IsFragment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsFragment'), 'IsFragment', '__httpddex_netxml20100712ddexC_ResourceMusicalWorkReference_IsFragment', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3137, 12), )

    
    IsFragment = property(__IsFragment.value, __IsFragment.set, None, 'The Flag indicating whether the MusicalWork is a Fragment (=True) or not (=False).')

    
    # Element ResourceMusicalWorkReference uses Python identifier ResourceMusicalWorkReference
    __ResourceMusicalWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference'), 'ResourceMusicalWorkReference', '__httpddex_netxml20100712ddexC_ResourceMusicalWorkReference_ResourceMusicalWorkReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3142, 12), )

    
    ResourceMusicalWorkReference = property(__ResourceMusicalWorkReference.value, __ResourceMusicalWorkReference.set, None, 'A Reference for a MusicalWork (specific to this Message). This LocalAnchorReference is a string starting with the letter W.')

    _ElementMap.update({
        __SequenceNumber.name() : __SequenceNumber,
        __DurationUsed.name() : __DurationUsed,
        __IsFragment.name() : __IsFragment,
        __ResourceMusicalWorkReference.name() : __ResourceMusicalWorkReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceMusicalWorkReference', ResourceMusicalWorkReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}ResourceMusicalWorkReferenceList with content type ELEMENT_ONLY
class ResourceMusicalWorkReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a list of ResourceMusicalWorkReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceMusicalWorkReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3149, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ResourceMusicalWorkReference uses Python identifier ResourceMusicalWorkReference
    __ResourceMusicalWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference'), 'ResourceMusicalWorkReference', '__httpddex_netxml20100712ddexC_ResourceMusicalWorkReferenceList_ResourceMusicalWorkReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3154, 12), )

    
    ResourceMusicalWorkReference = property(__ResourceMusicalWorkReference.value, __ResourceMusicalWorkReference.set, None, 'A Composite containing a ResourceMusicalWorkReference for a MusicalWork (specific to this Message).')

    _ElementMap.update({
        __ResourceMusicalWorkReference.name() : __ResourceMusicalWorkReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceMusicalWorkReferenceList', ResourceMusicalWorkReferenceList)


# Complex type {http://ddex.net/xml/20100712/ddexC}RightsAgreementId with content type ELEMENT_ONLY
class RightsAgreementId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Identifiers of a License, Claim, RightShare or contract."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightsAgreementId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3180, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MWLI uses Python identifier MWLI
    __MWLI = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MWLI'), 'MWLI', '__httpddex_netxml20100712ddexC_RightsAgreementId_MWLI', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3185, 12), )

    
    MWLI = property(__MWLI.value, __MWLI.set, None, 'A MusicalWork License Identifier identifying a License. If the Composite is meant to describe a Claim, RightShare or contract, then the License relates to that Claim, RightShare or contract. A MWLI comprises four parts: one of the strings "M1" or "M2" or "M3" or "M4", followed by five alphanumeric characters, ten alphanumeric characters and one alphanumeric check character.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_RightsAgreementId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3190, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the License, Claim, RightShare or contract.')

    _ElementMap.update({
        __MWLI.name() : __MWLI,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'RightsAgreementId', RightsAgreementId)


# Complex type {http://ddex.net/xml/20100712/ddexC}RightShare with content type ELEMENT_ONLY
class RightShare (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a RightShare."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightShare')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3230, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element RightShareId uses Python identifier RightShareId
    __RightShareId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareId'), 'RightShareId', '__httpddex_netxml20100712ddexC_RightShare_RightShareId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3235, 12), )

    
    RightShareId = property(__RightShareId.value, __RightShareId.set, None, 'A Composite containing details of Identifiers for the RightShare.')

    
    # Element RightShareReference uses Python identifier RightShareReference
    __RightShareReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareReference'), 'RightShareReference', '__httpddex_netxml20100712ddexC_RightShare_RightShareReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3240, 12), )

    
    RightShareReference = property(__RightShareReference.value, __RightShareReference.set, None, 'The Identifier (specific to the Message) of the RightShare within the Release which contains it. This LocalAnchor is a string starting with the letter S.')

    
    # Element RightShareCreationReferenceList uses Python identifier RightShareCreationReferenceList
    __RightShareCreationReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareCreationReferenceList'), 'RightShareCreationReferenceList', '__httpddex_netxml20100712ddexC_RightShare_RightShareCreationReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3245, 12), )

    
    RightShareCreationReferenceList = property(__RightShareCreationReferenceList.value, __RightShareCreationReferenceList.set, None, 'A Composite containing details of one or more Creations contained in the RightShare.')

    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_RightShare_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3251, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the RightShare applies (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_RightShare_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3256, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the RightShare does not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element RightsType uses Python identifier RightsType
    __RightsType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsType'), 'RightsType', '__httpddex_netxml20100712ddexC_RightShare_RightsType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3262, 12), )

    
    RightsType = property(__RightsType.value, __RightsType.set, None, 'A Type of Right covered by the RightShare. One of the Elements RightsType and UseType must be present. The RightsType is defined according to the jurisdiction of the Territory indicated in the TerritoryCode XmlAttribute.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20100712ddexC_RightShare_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3267, 12), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A Composite containing details of a nature of a Service, or a Release, as used by a Consumer. One of the Elements RightsType and UseType must be present.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20100712ddexC_RightShare_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3272, 12), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A Composite containing details of a physical interface by which a Consumer uses a Service or Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20100712ddexC_RightShare_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3277, 12), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20100712ddexC_RightShare_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3282, 12), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A Composite containing details of a Carrier.')

    
    # Element CommercialModelType uses Python identifier CommercialModelType
    __CommercialModelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CommercialModelType'), 'CommercialModelType', '__httpddex_netxml20100712ddexC_RightShare_CommercialModelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3287, 12), )

    
    CommercialModelType = property(__CommercialModelType.value, __CommercialModelType.set, None, 'A Composite containing details of the fundamental business model which applies (e.g. SubscriptionModel and PayAsYouGoModel). The CommercialModelType indicates how the Consumer pays for the Service or Release.')

    
    # Element MusicalWorkRightsClaimType uses Python identifier MusicalWorkRightsClaimType
    __MusicalWorkRightsClaimType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkRightsClaimType'), 'MusicalWorkRightsClaimType', '__httpddex_netxml20100712ddexC_RightShare_MusicalWorkRightsClaimType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3292, 12), )

    
    MusicalWorkRightsClaimType = property(__MusicalWorkRightsClaimType.value, __MusicalWorkRightsClaimType.set, None, 'A Type of the RightsClaim related to a MusicalWork.')

    
    # Element RightsController uses Python identifier RightsController
    __RightsController = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsController'), 'RightsController', '__httpddex_netxml20100712ddexC_RightShare_RightsController', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3297, 12), )

    
    RightsController = property(__RightsController.value, __RightsController.set, None, 'A Composite containing details of a RightsController of Rights in a Creation.')

    
    # Element ValidityPeriod uses Python identifier ValidityPeriod
    __ValidityPeriod = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ValidityPeriod'), 'ValidityPeriod', '__httpddex_netxml20100712ddexC_RightShare_ValidityPeriod', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3302, 12), )

    
    ValidityPeriod = property(__ValidityPeriod.value, __ValidityPeriod.set, None, 'A Composite containing details about the Period of Time for which the RightShare is valid.')

    
    # Element PercentageUnknown uses Python identifier PercentageUnknown
    __PercentageUnknown = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PercentageUnknown'), 'PercentageUnknown', '__httpddex_netxml20100712ddexC_RightShare_PercentageUnknown', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3308, 16), )

    
    PercentageUnknown = property(__PercentageUnknown.value, __PercentageUnknown.set, None, 'The Flag indicating whether the RightSharePercentage is unknown (=True) or not (=False).')

    
    # Element PercentageRate uses Python identifier PercentageRate
    __PercentageRate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PercentageRate'), 'PercentageRate', '__httpddex_netxml20100712ddexC_RightShare_PercentageRate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3313, 16), )

    
    PercentageRate = property(__PercentageRate.value, __PercentageRate.set, None, 'The share of the licensed Rights owned by the RightsController. RightShare information is given as a decimal value (e.g. "0.125" represents 12.5%) or as a fraction (e.g. "1/8" represents 12.5%).')

    
    # Element TariffReference uses Python identifier TariffReference
    __TariffReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TariffReference'), 'TariffReference', '__httpddex_netxml20100712ddexC_RightShare_TariffReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3319, 12), )

    
    TariffReference = property(__TariffReference.value, __TariffReference.set, None, 'A Composite containing details of a Reference to a TextDocument containing details of a Tariff (in the form of an Identifier, Name or Description) that is to be applied to the RightShare.')

    
    # Element LicenseStatus uses Python identifier LicenseStatus
    __LicenseStatus = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LicenseStatus'), 'LicenseStatus', '__httpddex_netxml20100712ddexC_RightShare_LicenseStatus', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3324, 12), )

    
    LicenseStatus = property(__LicenseStatus.value, __LicenseStatus.set, None, 'The legal status of a License for the RightShare.')

    
    # Element HasFirstLicenseRefusal uses Python identifier HasFirstLicenseRefusal
    __HasFirstLicenseRefusal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HasFirstLicenseRefusal'), 'HasFirstLicenseRefusal', '__httpddex_netxml20100712ddexC_RightShare_HasFirstLicenseRefusal', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3329, 12), )

    
    HasFirstLicenseRefusal = property(__HasFirstLicenseRefusal.value, __HasFirstLicenseRefusal.set, None, 'The Flag indicating whether a RightsController retains the right of refusal regarding the granting of the first licence for creating a SoundRecording of a Musical Work (=True) or not (=False).')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_RightShare_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3335, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3335, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the RightShare as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __RightShareId.name() : __RightShareId,
        __RightShareReference.name() : __RightShareReference,
        __RightShareCreationReferenceList.name() : __RightShareCreationReferenceList,
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __RightsType.name() : __RightsType,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType,
        __CommercialModelType.name() : __CommercialModelType,
        __MusicalWorkRightsClaimType.name() : __MusicalWorkRightsClaimType,
        __RightsController.name() : __RightsController,
        __ValidityPeriod.name() : __ValidityPeriod,
        __PercentageUnknown.name() : __PercentageUnknown,
        __PercentageRate.name() : __PercentageRate,
        __TariffReference.name() : __TariffReference,
        __LicenseStatus.name() : __LicenseStatus,
        __HasFirstLicenseRefusal.name() : __HasFirstLicenseRefusal
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'RightShare', RightShare)


# Complex type {http://ddex.net/xml/20100712/ddexC}RightShareCreationReferenceList with content type ELEMENT_ONLY
class RightShareCreationReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a list of RightShareCreationReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightShareCreationReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3341, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element RightShareWorkReference uses Python identifier RightShareWorkReference
    __RightShareWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareWorkReference'), 'RightShareWorkReference', '__httpddex_netxml20100712ddexC_RightShareCreationReferenceList_RightShareWorkReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3346, 12), )

    
    RightShareWorkReference = property(__RightShareWorkReference.value, __RightShareWorkReference.set, None, 'A Reference for a Work (specific to this Message) that is part of the RightShare. This LocalAnchorReference is a string starting with the letter W.')

    
    # Element RightShareResourceReference uses Python identifier RightShareResourceReference
    __RightShareResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareResourceReference'), 'RightShareResourceReference', '__httpddex_netxml20100712ddexC_RightShareCreationReferenceList_RightShareResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3351, 12), )

    
    RightShareResourceReference = property(__RightShareResourceReference.value, __RightShareResourceReference.set, None, 'A Reference for a Resource (specific to this Message) that is part of the RightShare. This LocalAnchorReference is a string starting with the letter A. The RightShare covers the Works used in the Resource(s).')

    
    # Element RightShareReleaseReference uses Python identifier RightShareReleaseReference
    __RightShareReleaseReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareReleaseReference'), 'RightShareReleaseReference', '__httpddex_netxml20100712ddexC_RightShareCreationReferenceList_RightShareReleaseReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3356, 12), )

    
    RightShareReleaseReference = property(__RightShareReleaseReference.value, __RightShareReleaseReference.set, None, 'A Reference for a Release (specific to this Message) that is part of the RightShare. This LocalAnchorReference is a string starting with the letter R. The RightShare covers the Works used in the Release(s).')

    _ElementMap.update({
        __RightShareWorkReference.name() : __RightShareWorkReference,
        __RightShareResourceReference.name() : __RightShareResourceReference,
        __RightShareReleaseReference.name() : __RightShareReleaseReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'RightShareCreationReferenceList', RightShareCreationReferenceList)


# Complex type {http://ddex.net/xml/20100712/ddexC}RoyaltyCode with content type SIMPLE
class RoyaltyCode (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a RoyaltyCode."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RoyaltyCode')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3401, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_RoyaltyCode_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3407, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3407, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the RoyaltyRateType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'RoyaltyCode', RoyaltyCode)


# Complex type {http://ddex.net/xml/20100712/ddexC}SalesReportingProxyReleaseId with content type ELEMENT_ONLY
class SalesReportingProxyReleaseId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SalesReportingProxyReleaseId."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SalesReportingProxyReleaseId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3415, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20100712ddexC_SalesReportingProxyReleaseId_ReleaseId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3420, 12), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A Composite containing details of ReleaseIds. If available, a GRid should always be used.')

    
    # Element Reason uses Python identifier Reason
    __Reason = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Reason'), 'Reason', '__httpddex_netxml20100712ddexC_SalesReportingProxyReleaseId_Reason', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3425, 12), )

    
    Reason = property(__Reason.value, __Reason.set, None, 'A Composite containing the textual Description of the reason for the Identifier being used as a proxy.')

    
    # Element ReasonType uses Python identifier ReasonType
    __ReasonType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReasonType'), 'ReasonType', '__httpddex_netxml20100712ddexC_SalesReportingProxyReleaseId_ReasonType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3430, 12), )

    
    ReasonType = property(__ReasonType.value, __ReasonType.set, None, 'A Composite containing details of a ReasonType.')

    _ElementMap.update({
        __ReleaseId.name() : __ReleaseId,
        __Reason.name() : __Reason,
        __ReasonType.name() : __ReasonType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SalesReportingProxyReleaseId', SalesReportingProxyReleaseId)


# Complex type {http://ddex.net/xml/20100712/ddexC}SheetMusic with content type ELEMENT_ONLY
class SheetMusic (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SheetMusic."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SheetMusic')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3451, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element SheetMusicType uses Python identifier SheetMusicType
    __SheetMusicType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SheetMusicType'), 'SheetMusicType', '__httpddex_netxml20100712ddexC_SheetMusic_SheetMusicType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3456, 12), )

    
    SheetMusicType = property(__SheetMusicType.value, __SheetMusicType.set, None, 'A Composite containing details of the Type of the SheetMusic.')

    
    # Element IsArtistRelated uses Python identifier IsArtistRelated
    __IsArtistRelated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), 'IsArtistRelated', '__httpddex_netxml20100712ddexC_SheetMusic_IsArtistRelated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3461, 12), )

    
    IsArtistRelated = property(__IsArtistRelated.value, __IsArtistRelated.set, None, 'The Flag indicating whether the SheetMusic is related to an Artist (=True) or not (=False).')

    
    # Element SheetMusicId uses Python identifier SheetMusicId
    __SheetMusicId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SheetMusicId'), 'SheetMusicId', '__httpddex_netxml20100712ddexC_SheetMusic_SheetMusicId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3466, 12), )

    
    SheetMusicId = property(__SheetMusicId.value, __SheetMusicId.set, None, 'A Composite containing details of Identifiers of the SheetMusic.')

    
    # Element IndirectSheetMusicId uses Python identifier IndirectSheetMusicId
    __IndirectSheetMusicId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectSheetMusicId'), 'IndirectSheetMusicId', '__httpddex_netxml20100712ddexC_SheetMusic_IndirectSheetMusicId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3471, 12), )

    
    IndirectSheetMusicId = property(__IndirectSheetMusicId.value, __IndirectSheetMusicId.set, None, 'A Composite containing details of a MusicalWorkId of a MusicalWork used in the SheetMusic.')

    
    # Element ResourceReference uses Python identifier ResourceReference
    __ResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReference'), 'ResourceReference', '__httpddex_netxml20100712ddexC_SheetMusic_ResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3476, 12), )

    
    ResourceReference = property(__ResourceReference.value, __ResourceReference.set, None, 'The Identifier (specific to the Message) of the SheetMusic within the Release which contains it. This LocalAnchor is a string starting with the letter A.')

    
    # Element LanguageOfLyrics uses Python identifier LanguageOfLyrics
    __LanguageOfLyrics = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LanguageOfLyrics'), 'LanguageOfLyrics', '__httpddex_netxml20100712ddexC_SheetMusic_LanguageOfLyrics', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3481, 12), )

    
    LanguageOfLyrics = property(__LanguageOfLyrics.value, __LanguageOfLyrics.set, None, 'The Language of the lyrics of the SheetMusic (represented by an ISO 639-2 LanguageCode).')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_SheetMusic_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3486, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) related to the SheetMusic.')

    
    # Element ResourceMusicalWorkReferenceList uses Python identifier ResourceMusicalWorkReferenceList
    __ResourceMusicalWorkReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), 'ResourceMusicalWorkReferenceList', '__httpddex_netxml20100712ddexC_SheetMusic_ResourceMusicalWorkReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3491, 12), )

    
    ResourceMusicalWorkReferenceList = property(__ResourceMusicalWorkReferenceList.value, __ResourceMusicalWorkReferenceList.set, None, 'A Composite containing details of one or more MusicalWorks contained in the SheetMusic.')

    
    # Element ResourceContainedResourceReferenceList uses Python identifier ResourceContainedResourceReferenceList
    __ResourceContainedResourceReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), 'ResourceContainedResourceReferenceList', '__httpddex_netxml20100712ddexC_SheetMusic_ResourceContainedResourceReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3496, 12), )

    
    ResourceContainedResourceReferenceList = property(__ResourceContainedResourceReferenceList.value, __ResourceContainedResourceReferenceList.set, None, 'A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current SheetMusic.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20100712ddexC_SheetMusic_ReferenceTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3501, 12), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A Composite containing details of the ReferenceTitle of the SheetMusic.')

    
    # Element CreationDate uses Python identifier CreationDate
    __CreationDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CreationDate'), 'CreationDate', '__httpddex_netxml20100712ddexC_SheetMusic_CreationDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3506, 12), )

    
    CreationDate = property(__CreationDate.value, __CreationDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the SheetMusic was created.')

    
    # Element SheetMusicDetailsByTerritory uses Python identifier SheetMusicDetailsByTerritory
    __SheetMusicDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SheetMusicDetailsByTerritory'), 'SheetMusicDetailsByTerritory', '__httpddex_netxml20100712ddexC_SheetMusic_SheetMusicDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3511, 12), )

    
    SheetMusicDetailsByTerritory = property(__SheetMusicDetailsByTerritory.value, __SheetMusicDetailsByTerritory.set, None, 'A Composite containing details of the SheetMusic which may vary according to Territory of release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_SheetMusic_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3517, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3517, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the SheetMusic as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __SheetMusicType.name() : __SheetMusicType,
        __IsArtistRelated.name() : __IsArtistRelated,
        __SheetMusicId.name() : __SheetMusicId,
        __IndirectSheetMusicId.name() : __IndirectSheetMusicId,
        __ResourceReference.name() : __ResourceReference,
        __LanguageOfLyrics.name() : __LanguageOfLyrics,
        __RightsAgreementId.name() : __RightsAgreementId,
        __ResourceMusicalWorkReferenceList.name() : __ResourceMusicalWorkReferenceList,
        __ResourceContainedResourceReferenceList.name() : __ResourceContainedResourceReferenceList,
        __ReferenceTitle.name() : __ReferenceTitle,
        __CreationDate.name() : __CreationDate,
        __SheetMusicDetailsByTerritory.name() : __SheetMusicDetailsByTerritory
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SheetMusic', SheetMusic)


# Complex type {http://ddex.net/xml/20100712/ddexC}SheetMusicDetailsByTerritory with content type ELEMENT_ONLY
class SheetMusicDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Descriptors, Dates and other attributes of a SheetMusic which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SheetMusicDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3547, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_SheetMusicDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3553, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the SheetMusic details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_SheetMusicDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3558, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the SheetMusic details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_SheetMusicDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3564, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the SheetMusic.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20100712ddexC_SheetMusicDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3569, 12), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A Composite containing details of a Contributor to the SheetMusic.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20100712ddexC_SheetMusicDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3574, 12), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A Composite containing details of an indirect Contributor to the SheetMusic.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20100712ddexC_SheetMusicDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3579, 12), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A Composite containing details of the CLine for the SheetMusic.')

    
    # Element CourtesyLine uses Python identifier CourtesyLine
    __CourtesyLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), 'CourtesyLine', '__httpddex_netxml20100712ddexC_SheetMusicDetailsByTerritory_CourtesyLine', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3584, 12), )

    
    CourtesyLine = property(__CourtesyLine.value, __CourtesyLine.set, None, 'A Composite containing an Annotation which acknowledges record companies and/or other Parties giving permission for Artists or others featured in the SheetMusic.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20100712ddexC_SheetMusicDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3589, 12), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the SheetMusic was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_SheetMusicDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3595, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3595, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the SheetMusicDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __Title.name() : __Title,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __CLine.name() : __CLine,
        __CourtesyLine.name() : __CourtesyLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SheetMusicDetailsByTerritory', SheetMusicDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}SheetMusicId with content type ELEMENT_ONLY
class SheetMusicId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Identifiers of a SheetMusic."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SheetMusicId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3601, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISMN uses Python identifier ISMN
    __ISMN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISMN'), 'ISMN', '__httpddex_netxml20100712ddexC_SheetMusicId_ISMN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3606, 12), )

    
    ISMN = property(__ISMN.value, __ISMN.set, None, 'The ISMN (International Standard Music Number defined in ISO 10957) for the SheetMusic. An ISMN is a thirteen-digit number. Pre-2008 ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ("M") with "979-0".')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_SheetMusicId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3611, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the SheetMusic.')

    _ElementMap.update({
        __ISMN.name() : __ISMN,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SheetMusicId', SheetMusicId)


# Complex type {http://ddex.net/xml/20100712/ddexC}SimpleProfileMessageHeader with content type ELEMENT_ONLY
class SimpleProfileMessageHeader (pyxb.binding.basis.complexTypeDefinition):
    """A Composite placed at the beginning of each DdexMessage providing information about the Message, such as MessageSender, MessageRecipient and a Message creation time stamp."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SimpleProfileMessageHeader')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3658, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MessageThreadId uses Python identifier MessageThreadId
    __MessageThreadId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageThreadId'), 'MessageThreadId', '__httpddex_netxml20100712ddexC_SimpleProfileMessageHeader_MessageThreadId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3663, 12), )

    
    MessageThreadId = property(__MessageThreadId.value, __MessageThreadId.set, None, 'A string used to uniquely identify the thread of Messages of which the current Message is a part.')

    
    # Element MessageId uses Python identifier MessageId
    __MessageId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageId'), 'MessageId', '__httpddex_netxml20100712ddexC_SimpleProfileMessageHeader_MessageId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3668, 12), )

    
    MessageId = property(__MessageId.value, __MessageId.set, None, 'A string used to uniquely identify the current Message.')

    
    # Element MessageFileName uses Python identifier MessageFileName
    __MessageFileName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageFileName'), 'MessageFileName', '__httpddex_netxml20100712ddexC_SimpleProfileMessageHeader_MessageFileName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3673, 12), )

    
    MessageFileName = property(__MessageFileName.value, __MessageFileName.set, None, 'The FileName, possibly including the FilePath, of the XML File containing the current Message.')

    
    # Element MessageSender uses Python identifier MessageSender
    __MessageSender = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageSender'), 'MessageSender', '__httpddex_netxml20100712ddexC_SimpleProfileMessageHeader_MessageSender', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3678, 12), )

    
    MessageSender = property(__MessageSender.value, __MessageSender.set, None, 'A Composite containing details of the MessageSender.')

    
    # Element MessageRecipient uses Python identifier MessageRecipient
    __MessageRecipient = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageRecipient'), 'MessageRecipient', '__httpddex_netxml20100712ddexC_SimpleProfileMessageHeader_MessageRecipient', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3683, 12), )

    
    MessageRecipient = property(__MessageRecipient.value, __MessageRecipient.set, None, 'A Composite containing details of the MessageRecipient.')

    
    # Element MessageCreatedDateTime uses Python identifier MessageCreatedDateTime
    __MessageCreatedDateTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageCreatedDateTime'), 'MessageCreatedDateTime', '__httpddex_netxml20100712ddexC_SimpleProfileMessageHeader_MessageCreatedDateTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3688, 12), )

    
    MessageCreatedDateTime = property(__MessageCreatedDateTime.value, __MessageCreatedDateTime.set, None, 'The DateTime on which the Message was created (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).')

    
    # Element Comment uses Python identifier Comment
    __Comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Comment'), 'Comment', '__httpddex_netxml20100712ddexC_SimpleProfileMessageHeader_Comment', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3693, 12), )

    
    Comment = property(__Comment.value, __Comment.set, None, 'A Composite containing a human-readable Comment about the Message.')

    
    # Element MessageControlType uses Python identifier MessageControlType
    __MessageControlType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageControlType'), 'MessageControlType', '__httpddex_netxml20100712ddexC_SimpleProfileMessageHeader_MessageControlType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3698, 12), )

    
    MessageControlType = property(__MessageControlType.value, __MessageControlType.set, None, 'The indicator used to distinguish a live Message from a test Message.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_SimpleProfileMessageHeader_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3704, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3704, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the MessageHeader as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __MessageThreadId.name() : __MessageThreadId,
        __MessageId.name() : __MessageId,
        __MessageFileName.name() : __MessageFileName,
        __MessageSender.name() : __MessageSender,
        __MessageRecipient.name() : __MessageRecipient,
        __MessageCreatedDateTime.name() : __MessageCreatedDateTime,
        __Comment.name() : __Comment,
        __MessageControlType.name() : __MessageControlType
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SimpleProfileMessageHeader', SimpleProfileMessageHeader)


# Complex type {http://ddex.net/xml/20100712/ddexC}SimpleProfileMessagingParty with content type ELEMENT_ONLY
class SimpleProfileMessagingParty (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a MessagingParty."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SimpleProfileMessagingParty')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3710, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20100712ddexC_SimpleProfileMessagingParty_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3715, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A Composite containing details of the PartyId for the Party handling the Message. If no Namespace is given, the Identifier is a DdexPartyId (DPID). Note that DPIDs are not normally used to identify Artists, Producers or other Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20100712ddexC_SimpleProfileMessagingParty_PartyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3720, 12), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A Composite containing details of the PartyNames for the Party handling the Message.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_SimpleProfileMessagingParty_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3726, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3726, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the MessagingParty as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SimpleProfileMessagingParty', SimpleProfileMessagingParty)


# Complex type {http://ddex.net/xml/20100712/ddexC}SimpleProfilePartyDescriptor with content type ELEMENT_ONLY
class SimpleProfilePartyDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Party. Parties are typically described through Names and/or Identifiers."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SimpleProfilePartyDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3732, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20100712ddexC_SimpleProfilePartyDescriptor_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3737, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A Composite containing details of the PartyId for the Party. If no Namespace is given, the Identifier is a DdexPartyId (DPID). Note that DPIDs are not normally used to identify Artists, Producers or other Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20100712ddexC_SimpleProfilePartyDescriptor_PartyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3743, 16), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A Composite containing details of the PartyName(s).')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SimpleProfilePartyDescriptor', SimpleProfilePartyDescriptor)


# Complex type {http://ddex.net/xml/20100712/ddexC}SimpleProfilePartyName with content type ELEMENT_ONLY
class SimpleProfilePartyName (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a PartyName. Name details for a Party typically either contain a FullName or a KeyName."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SimpleProfilePartyName')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3756, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element FullName uses Python identifier FullName
    __FullName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FullName'), 'FullName', '__httpddex_netxml20100712ddexC_SimpleProfilePartyName_FullName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3761, 12), )

    
    FullName = property(__FullName.value, __FullName.set, None, 'A Composite containing the complete Name of the Party, in its normal form of presentation (e.g. John H. Smith, Acme Music Inc, A Composite containing the Beatles).')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_SimpleProfilePartyName_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3767, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3767, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the PartyName as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __FullName.name() : __FullName
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SimpleProfilePartyName', SimpleProfilePartyName)


# Complex type {http://ddex.net/xml/20100712/ddexC}SocietyAffiliation with content type ELEMENT_ONLY
class SocietyAffiliation (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a society affiliation."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SocietyAffiliation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3794, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_SocietyAffiliation_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3800, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the affiliation details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_SocietyAffiliation_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3805, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the affiliation details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element MusicRightsSociety uses Python identifier MusicRightsSociety
    __MusicRightsSociety = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicRightsSociety'), 'MusicRightsSociety', '__httpddex_netxml20100712ddexC_SocietyAffiliation_MusicRightsSociety', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3811, 12), )

    
    MusicRightsSociety = property(__MusicRightsSociety.value, __MusicRightsSociety.set, None, 'A Composite containing details of a MusicRightsSociety.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __MusicRightsSociety.name() : __MusicRightsSociety
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SocietyAffiliation', SocietyAffiliation)


# Complex type {http://ddex.net/xml/20100712/ddexC}Software with content type ELEMENT_ONLY
class Software (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an item of Software."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Software')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3818, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element SoftwareType uses Python identifier SoftwareType
    __SoftwareType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoftwareType'), 'SoftwareType', '__httpddex_netxml20100712ddexC_Software_SoftwareType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3823, 12), )

    
    SoftwareType = property(__SoftwareType.value, __SoftwareType.set, None, 'A Composite containing details of the Type of the Software.')

    
    # Element IsArtistRelated uses Python identifier IsArtistRelated
    __IsArtistRelated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), 'IsArtistRelated', '__httpddex_netxml20100712ddexC_Software_IsArtistRelated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3828, 12), )

    
    IsArtistRelated = property(__IsArtistRelated.value, __IsArtistRelated.set, None, 'The Flag indicating whether the Software is related to an Artist (=True) or not (=False).')

    
    # Element SoftwareId uses Python identifier SoftwareId
    __SoftwareId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoftwareId'), 'SoftwareId', '__httpddex_netxml20100712ddexC_Software_SoftwareId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3833, 12), )

    
    SoftwareId = property(__SoftwareId.value, __SoftwareId.set, None, 'A Composite containing details of Identifiers of the Software.')

    
    # Element IndirectSoftwareId uses Python identifier IndirectSoftwareId
    __IndirectSoftwareId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectSoftwareId'), 'IndirectSoftwareId', '__httpddex_netxml20100712ddexC_Software_IndirectSoftwareId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3838, 12), )

    
    IndirectSoftwareId = property(__IndirectSoftwareId.value, __IndirectSoftwareId.set, None, 'A Composite containing details of a MusicalWorkId of a MusicalWork used in the Software.')

    
    # Element ResourceReference uses Python identifier ResourceReference
    __ResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReference'), 'ResourceReference', '__httpddex_netxml20100712ddexC_Software_ResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3843, 12), )

    
    ResourceReference = property(__ResourceReference.value, __ResourceReference.set, None, 'The Identifier (specific to the Message) of the Software within the Release which contains it. This LocalAnchor is a string starting with the letter A.')

    
    # Element ResourceMusicalWorkReferenceList uses Python identifier ResourceMusicalWorkReferenceList
    __ResourceMusicalWorkReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), 'ResourceMusicalWorkReferenceList', '__httpddex_netxml20100712ddexC_Software_ResourceMusicalWorkReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3848, 12), )

    
    ResourceMusicalWorkReferenceList = property(__ResourceMusicalWorkReferenceList.value, __ResourceMusicalWorkReferenceList.set, None, 'A Composite containing details of one or more MusicalWorks contained in the Software.')

    
    # Element ResourceContainedResourceReferenceList uses Python identifier ResourceContainedResourceReferenceList
    __ResourceContainedResourceReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), 'ResourceContainedResourceReferenceList', '__httpddex_netxml20100712ddexC_Software_ResourceContainedResourceReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3853, 12), )

    
    ResourceContainedResourceReferenceList = property(__ResourceContainedResourceReferenceList.value, __ResourceContainedResourceReferenceList.set, None, 'A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current Software.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_Software_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3858, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the Software.')

    
    # Element CreationDate uses Python identifier CreationDate
    __CreationDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CreationDate'), 'CreationDate', '__httpddex_netxml20100712ddexC_Software_CreationDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3863, 12), )

    
    CreationDate = property(__CreationDate.value, __CreationDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Software was created.')

    
    # Element SoftwareDetailsByTerritory uses Python identifier SoftwareDetailsByTerritory
    __SoftwareDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoftwareDetailsByTerritory'), 'SoftwareDetailsByTerritory', '__httpddex_netxml20100712ddexC_Software_SoftwareDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3868, 12), )

    
    SoftwareDetailsByTerritory = property(__SoftwareDetailsByTerritory.value, __SoftwareDetailsByTerritory.set, None, 'A Composite containing details of the Software which may vary according to Territory of release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Software_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3874, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3874, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the Software as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __SoftwareType.name() : __SoftwareType,
        __IsArtistRelated.name() : __IsArtistRelated,
        __SoftwareId.name() : __SoftwareId,
        __IndirectSoftwareId.name() : __IndirectSoftwareId,
        __ResourceReference.name() : __ResourceReference,
        __ResourceMusicalWorkReferenceList.name() : __ResourceMusicalWorkReferenceList,
        __ResourceContainedResourceReferenceList.name() : __ResourceContainedResourceReferenceList,
        __Title.name() : __Title,
        __CreationDate.name() : __CreationDate,
        __SoftwareDetailsByTerritory.name() : __SoftwareDetailsByTerritory
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Software', Software)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoftwareDetailsByTerritory with content type ELEMENT_ONLY
class SoftwareDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Descriptors, Dates and other attributes of a Software application which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoftwareDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3880, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_SoftwareDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3886, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the Software details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_SoftwareDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3891, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the Software details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20100712ddexC_SoftwareDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3897, 12), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A Composite containing details of a Contributor to the Software.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20100712ddexC_SoftwareDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3902, 12), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A Composite containing details of an indirect Contributor to the Software.')

    
    # Element PLine uses Python identifier PLine
    __PLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLine'), 'PLine', '__httpddex_netxml20100712ddexC_SoftwareDetailsByTerritory_PLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3907, 12), )

    
    PLine = property(__PLine.value, __PLine.set, None, 'A Composite containing details of the PLine for the Software.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20100712ddexC_SoftwareDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3912, 12), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A Composite containing details of the CLine for the Software.')

    
    # Element CourtesyLine uses Python identifier CourtesyLine
    __CourtesyLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), 'CourtesyLine', '__httpddex_netxml20100712ddexC_SoftwareDetailsByTerritory_CourtesyLine', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3917, 12), )

    
    CourtesyLine = property(__CourtesyLine.value, __CourtesyLine.set, None, 'A Composite containing an Annotation which acknowledges record companies and/or other Parties giving permission for Artists or others featured in the Software.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20100712ddexC_SoftwareDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3922, 12), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Software was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_SoftwareDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3928, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3928, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the SoftwareDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __PLine.name() : __PLine,
        __CLine.name() : __CLine,
        __CourtesyLine.name() : __CourtesyLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SoftwareDetailsByTerritory', SoftwareDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoftwareId with content type ELEMENT_ONLY
class SoftwareId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Identifiers of a Software."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoftwareId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3934, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_SoftwareId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3939, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the Software.')

    _ElementMap.update({
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SoftwareId', SoftwareId)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoundRecording with content type ELEMENT_ONLY
class SoundRecording (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SoundRecording."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecording')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3989, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element SoundRecordingType uses Python identifier SoundRecordingType
    __SoundRecordingType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoundRecordingType'), 'SoundRecordingType', '__httpddex_netxml20100712ddexC_SoundRecording_SoundRecordingType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3994, 12), )

    
    SoundRecordingType = property(__SoundRecordingType.value, __SoundRecordingType.set, None, 'A Composite containing details of the Type of the SoundRecording.')

    
    # Element IsArtistRelated uses Python identifier IsArtistRelated
    __IsArtistRelated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), 'IsArtistRelated', '__httpddex_netxml20100712ddexC_SoundRecording_IsArtistRelated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3999, 12), )

    
    IsArtistRelated = property(__IsArtistRelated.value, __IsArtistRelated.set, None, 'The Flag indicating whether the SoundRecording is related to an Artist (=True) or not (=False).')

    
    # Element SoundRecordingId uses Python identifier SoundRecordingId
    __SoundRecordingId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoundRecordingId'), 'SoundRecordingId', '__httpddex_netxml20100712ddexC_SoundRecording_SoundRecordingId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4004, 12), )

    
    SoundRecordingId = property(__SoundRecordingId.value, __SoundRecordingId.set, None, 'A Composite containing details of SoundRecordingIds.')

    
    # Element IndirectSoundRecordingId uses Python identifier IndirectSoundRecordingId
    __IndirectSoundRecordingId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectSoundRecordingId'), 'IndirectSoundRecordingId', '__httpddex_netxml20100712ddexC_SoundRecording_IndirectSoundRecordingId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4009, 12), )

    
    IndirectSoundRecordingId = property(__IndirectSoundRecordingId.value, __IndirectSoundRecordingId.set, None, 'A Composite containing details of a MusicalWorkId of a MusicalWork used in the SoundRecording.')

    
    # Element ResourceReference uses Python identifier ResourceReference
    __ResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReference'), 'ResourceReference', '__httpddex_netxml20100712ddexC_SoundRecording_ResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4014, 12), )

    
    ResourceReference = property(__ResourceReference.value, __ResourceReference.set, None, 'The Identifier (specific to the Message) of the SoundRecording within the Release which contains it. This LocalAnchor is a string starting with the letter A.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20100712ddexC_SoundRecording_ReferenceTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4019, 12), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A Composite containing details of the ReferenceTitle of the SoundRecording.')

    
    # Element InstrumentationDescription uses Python identifier InstrumentationDescription
    __InstrumentationDescription = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'InstrumentationDescription'), 'InstrumentationDescription', '__httpddex_netxml20100712ddexC_SoundRecording_InstrumentationDescription', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4024, 12), )

    
    InstrumentationDescription = property(__InstrumentationDescription.value, __InstrumentationDescription.set, None, 'A Composite containing a Description of the Type of instrumentation of the MusicalWork(s) in the SoundRecording.')

    
    # Element IsMedley uses Python identifier IsMedley
    __IsMedley = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsMedley'), 'IsMedley', '__httpddex_netxml20100712ddexC_SoundRecording_IsMedley', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4029, 12), )

    
    IsMedley = property(__IsMedley.value, __IsMedley.set, None, 'The Flag indicating whether the SoundRecording is a Medley (=True) or not (=False).')

    
    # Element IsPotpourri uses Python identifier IsPotpourri
    __IsPotpourri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsPotpourri'), 'IsPotpourri', '__httpddex_netxml20100712ddexC_SoundRecording_IsPotpourri', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4034, 12), )

    
    IsPotpourri = property(__IsPotpourri.value, __IsPotpourri.set, None, 'The Flag indicating whether the SoundRecording is a Potpourri (=True) or not (=False).')

    
    # Element IsInstrumental uses Python identifier IsInstrumental
    __IsInstrumental = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsInstrumental'), 'IsInstrumental', '__httpddex_netxml20100712ddexC_SoundRecording_IsInstrumental', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4039, 12), )

    
    IsInstrumental = property(__IsInstrumental.value, __IsInstrumental.set, None, 'The Flag indicating whether the SoundRecording is instrumental (=True) or not (=False).')

    
    # Element IsBackground uses Python identifier IsBackground
    __IsBackground = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsBackground'), 'IsBackground', '__httpddex_netxml20100712ddexC_SoundRecording_IsBackground', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4044, 12), )

    
    IsBackground = property(__IsBackground.value, __IsBackground.set, None, 'The Flag indicating whether the SoundRecording is used as background to other audio or audiovisual material (=True) or not (=False).')

    
    # Element IsHiddenResource uses Python identifier IsHiddenResource
    __IsHiddenResource = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsHiddenResource'), 'IsHiddenResource', '__httpddex_netxml20100712ddexC_SoundRecording_IsHiddenResource', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4049, 12), )

    
    IsHiddenResource = property(__IsHiddenResource.value, __IsHiddenResource.set, None, 'The Flag indicating whether the SoundRecording is hidden in some way from the Consumer (=True) or not (=False).')

    
    # Element IsBonusResource uses Python identifier IsBonusResource
    __IsBonusResource = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsBonusResource'), 'IsBonusResource', '__httpddex_netxml20100712ddexC_SoundRecording_IsBonusResource', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4054, 12), )

    
    IsBonusResource = property(__IsBonusResource.value, __IsBonusResource.set, None, 'The Flag indicating whether the SoundRecording is additional to those on the original Release of which this is a Version (=True) or not (=False).')

    
    # Element IsComputerGenerated uses Python identifier IsComputerGenerated
    __IsComputerGenerated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsComputerGenerated'), 'IsComputerGenerated', '__httpddex_netxml20100712ddexC_SoundRecording_IsComputerGenerated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4059, 12), )

    
    IsComputerGenerated = property(__IsComputerGenerated.value, __IsComputerGenerated.set, None, 'The Flag indicating whether the SoundRecording is generated by a computer (=True) or not (=False).')

    
    # Element LanguageOfPerformance uses Python identifier LanguageOfPerformance
    __LanguageOfPerformance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LanguageOfPerformance'), 'LanguageOfPerformance', '__httpddex_netxml20100712ddexC_SoundRecording_LanguageOfPerformance', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4064, 12), )

    
    LanguageOfPerformance = property(__LanguageOfPerformance.value, __LanguageOfPerformance.set, None, 'The Language of the Performance recorded in the SoundRecording (represented by an ISO 639-2 LanguageCode).')

    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20100712ddexC_SoundRecording_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4069, 12), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The Duration of the SoundRecording (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_SoundRecording_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4074, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the SoundRecording.')

    
    # Element ResourceMusicalWorkReferenceList uses Python identifier ResourceMusicalWorkReferenceList
    __ResourceMusicalWorkReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), 'ResourceMusicalWorkReferenceList', '__httpddex_netxml20100712ddexC_SoundRecording_ResourceMusicalWorkReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4079, 12), )

    
    ResourceMusicalWorkReferenceList = property(__ResourceMusicalWorkReferenceList.value, __ResourceMusicalWorkReferenceList.set, None, 'A Composite containing details of one or more MusicalWorks contained in the SoundRecording.')

    
    # Element ResourceContainedResourceReferenceList uses Python identifier ResourceContainedResourceReferenceList
    __ResourceContainedResourceReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), 'ResourceContainedResourceReferenceList', '__httpddex_netxml20100712ddexC_SoundRecording_ResourceContainedResourceReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4084, 12), )

    
    ResourceContainedResourceReferenceList = property(__ResourceContainedResourceReferenceList.value, __ResourceContainedResourceReferenceList.set, None, 'A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current SoundRecording.')

    
    # Element CreationDate uses Python identifier CreationDate
    __CreationDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CreationDate'), 'CreationDate', '__httpddex_netxml20100712ddexC_SoundRecording_CreationDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4089, 12), )

    
    CreationDate = property(__CreationDate.value, __CreationDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the SoundRecording was created.')

    
    # Element MasteredDate uses Python identifier MasteredDate
    __MasteredDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MasteredDate'), 'MasteredDate', '__httpddex_netxml20100712ddexC_SoundRecording_MasteredDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4094, 12), )

    
    MasteredDate = property(__MasteredDate.value, __MasteredDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the SoundRecording was originally mastered (either in analogue or digital form).')

    
    # Element SoundRecordingDetailsByTerritory uses Python identifier SoundRecordingDetailsByTerritory
    __SoundRecordingDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoundRecordingDetailsByTerritory'), 'SoundRecordingDetailsByTerritory', '__httpddex_netxml20100712ddexC_SoundRecording_SoundRecordingDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4099, 12), )

    
    SoundRecordingDetailsByTerritory = property(__SoundRecordingDetailsByTerritory.value, __SoundRecordingDetailsByTerritory.set, None, 'A Composite containing details of Descriptors and other attributes of the SoundRecording which may vary according to Territory of release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_SoundRecording_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4105, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4105, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the SoundRecording as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __SoundRecordingType.name() : __SoundRecordingType,
        __IsArtistRelated.name() : __IsArtistRelated,
        __SoundRecordingId.name() : __SoundRecordingId,
        __IndirectSoundRecordingId.name() : __IndirectSoundRecordingId,
        __ResourceReference.name() : __ResourceReference,
        __ReferenceTitle.name() : __ReferenceTitle,
        __InstrumentationDescription.name() : __InstrumentationDescription,
        __IsMedley.name() : __IsMedley,
        __IsPotpourri.name() : __IsPotpourri,
        __IsInstrumental.name() : __IsInstrumental,
        __IsBackground.name() : __IsBackground,
        __IsHiddenResource.name() : __IsHiddenResource,
        __IsBonusResource.name() : __IsBonusResource,
        __IsComputerGenerated.name() : __IsComputerGenerated,
        __LanguageOfPerformance.name() : __LanguageOfPerformance,
        __Duration.name() : __Duration,
        __RightsAgreementId.name() : __RightsAgreementId,
        __ResourceMusicalWorkReferenceList.name() : __ResourceMusicalWorkReferenceList,
        __ResourceContainedResourceReferenceList.name() : __ResourceContainedResourceReferenceList,
        __CreationDate.name() : __CreationDate,
        __MasteredDate.name() : __MasteredDate,
        __SoundRecordingDetailsByTerritory.name() : __SoundRecordingDetailsByTerritory
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecording', SoundRecording)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoundRecordingCollectionReference with content type ELEMENT_ONLY
class SoundRecordingCollectionReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SoundRecordingCollectionRef."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingCollectionReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4111, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_SoundRecordingCollectionReference_SequenceNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4116, 12), )

    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the Collection in a group of Collections within a Medley, SoundRecording or other Collection.')

    
    # Element SoundRecordingCollectionReference uses Python identifier SoundRecordingCollectionReference
    __SoundRecordingCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference'), 'SoundRecordingCollectionReference', '__httpddex_netxml20100712ddexC_SoundRecordingCollectionReference_SoundRecordingCollectionReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4121, 12), )

    
    SoundRecordingCollectionReference = property(__SoundRecordingCollectionReference.value, __SoundRecordingCollectionReference.set, None, 'A Reference for a Collection (specific to this Message). This LocalAnchorReference is a string starting with the letter X. The referenced Collection has to be of CollectionType Series, Season or Episode.')

    
    # Element StartTime uses Python identifier StartTime
    __StartTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartTime'), 'StartTime', '__httpddex_netxml20100712ddexC_SoundRecordingCollectionReference_StartTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4126, 12), )

    
    StartTime = property(__StartTime.value, __StartTime.set, None, 'The start time of the Creation, measured from the start of the Resource from which the CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20100712ddexC_SoundRecordingCollectionReference_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4131, 12), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The Duration of the use of the Creation that is referenced in the CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element EndTime uses Python identifier EndTime
    __EndTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndTime'), 'EndTime', '__httpddex_netxml20100712ddexC_SoundRecordingCollectionReference_EndTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4136, 12), )

    
    EndTime = property(__EndTime.value, __EndTime.set, None, 'The end time of the Creation, measured from the start of the Resource from which the CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element ReleaseResourceType uses Python identifier ReleaseResourceType
    __ReleaseResourceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType'), 'ReleaseResourceType', '__httpddex_netxml20100712ddexC_SoundRecordingCollectionReference_ReleaseResourceType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4141, 12), )

    
    ReleaseResourceType = property(__ReleaseResourceType.value, __ReleaseResourceType.set, None, 'A Type of Collection in the context of a Video. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __SequenceNumber.name() : __SequenceNumber,
        __SoundRecordingCollectionReference.name() : __SoundRecordingCollectionReference,
        __StartTime.name() : __StartTime,
        __Duration.name() : __Duration,
        __EndTime.name() : __EndTime,
        __ReleaseResourceType.name() : __ReleaseResourceType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingCollectionReference', SoundRecordingCollectionReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoundRecordingCollectionReferenceList with content type ELEMENT_ONLY
class SoundRecordingCollectionReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a list of SoundRecordingCollectionReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingCollectionReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4148, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element NumberOfCollections uses Python identifier NumberOfCollections
    __NumberOfCollections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), 'NumberOfCollections', '__httpddex_netxml20100712ddexC_SoundRecordingCollectionReferenceList_NumberOfCollections', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4153, 12), )

    
    NumberOfCollections = property(__NumberOfCollections.value, __NumberOfCollections.set, None, 'The number of referenced Collections (typically Chapters).')

    
    # Element SoundRecordingCollectionReference uses Python identifier SoundRecordingCollectionReference
    __SoundRecordingCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference'), 'SoundRecordingCollectionReference', '__httpddex_netxml20100712ddexC_SoundRecordingCollectionReferenceList_SoundRecordingCollectionReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4158, 12), )

    
    SoundRecordingCollectionReference = property(__SoundRecordingCollectionReference.value, __SoundRecordingCollectionReference.set, None, 'A Composite containing a SoundRecordingCollectionReference for a Collection (specific to this Message).')

    _ElementMap.update({
        __NumberOfCollections.name() : __NumberOfCollections,
        __SoundRecordingCollectionReference.name() : __SoundRecordingCollectionReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingCollectionReferenceList', SoundRecordingCollectionReferenceList)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory with content type ELEMENT_ONLY
class SoundRecordingDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Descriptors and other attributes of a SoundRecording which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4165, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4171, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the SoundRecording details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4176, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the SoundRecording details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4182, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the SoundRecording.')

    
    # Element DisplayArtist uses Python identifier DisplayArtist
    __DisplayArtist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), 'DisplayArtist', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_DisplayArtist', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4187, 12), )

    
    DisplayArtist = property(__DisplayArtist.value, __DisplayArtist.set, None, 'A Composite containing details of the DisplayArtist for the SoundRecording. The DisplayArtist may be described through Name, Identifier and Roles.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4192, 12), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A Composite containing details of a Contributor to the SoundRecording.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4197, 12), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A Composite containing details of an indirect Contributor to the SoundRecording.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4202, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the SoundRecording.')

    
    # Element LabelName uses Python identifier LabelName
    __LabelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LabelName'), 'LabelName', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_LabelName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4207, 12), )

    
    LabelName = property(__LabelName.value, __LabelName.set, None, 'A Composite containing the Name of the Label under which the Release is to be marketed.')

    
    # Element RightsController uses Python identifier RightsController
    __RightsController = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsController'), 'RightsController', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_RightsController', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4212, 12), )

    
    RightsController = property(__RightsController.value, __RightsController.set, None, 'A Composite containing details of RightsController of Rights in the SoundRecording.')

    
    # Element RemasteredDate uses Python identifier RemasteredDate
    __RemasteredDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), 'RemasteredDate', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_RemasteredDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4217, 12), )

    
    RemasteredDate = property(__RemasteredDate.value, __RemasteredDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the SoundRecording was re-mastered (usually digitally).')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4222, 12), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the SoundRecording was originally published, whether for physical or electronic/online distribution.')

    
    # Element PLine uses Python identifier PLine
    __PLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLine'), 'PLine', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_PLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4227, 12), )

    
    PLine = property(__PLine.value, __PLine.set, None, 'A Composite containing details of the PLine for the SoundRecording.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_SoundRecordingDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4233, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4233, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the SoundRecordingDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __Title.name() : __Title,
        __DisplayArtist.name() : __DisplayArtist,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __RightsAgreementId.name() : __RightsAgreementId,
        __LabelName.name() : __LabelName,
        __RightsController.name() : __RightsController,
        __RemasteredDate.name() : __RemasteredDate,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate,
        __PLine.name() : __PLine
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingDetailsByTerritory', SoundRecordingDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoundRecordingId with content type ELEMENT_ONLY
class SoundRecordingId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of SoundRecordingIds."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4239, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20100712ddexC_SoundRecordingId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4244, 12), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ISRC (International Standard Recording Code as defined in ISO 3901) for the SoundRecording. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20100712ddexC_SoundRecordingId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4249, 12), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A Composite containing details of the CatalogNumber of the SoundRecording.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_SoundRecordingId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4254, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the SoundRecording (usually one per society involved in the messaging).')

    _ElementMap.update({
        __ISRC.name() : __ISRC,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingId', SoundRecordingId)


# Complex type {http://ddex.net/xml/20100712/ddexC}StoreLocationDescriptor with content type SIMPLE
class StoreLocationDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a StoreLocationDescriptor."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'StoreLocationDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4280, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_StoreLocationDescriptor_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4286, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4286, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the StoreLocationDescriptor as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'StoreLocationDescriptor', StoreLocationDescriptor)


# Complex type {http://ddex.net/xml/20100712/ddexC}SubTitle with content type SIMPLE
class SubTitle (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SubTitle, including Titles of Versions used to differentiate different versions of the same Title, as required by the GRId and ISRC ReferenceDescriptiveMetadataSets."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SubTitle')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4294, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_SubTitle_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4300, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4300, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the SubTitle as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SubTitle', SubTitle)


# Complex type {http://ddex.net/xml/20100712/ddexC}Synopsis with content type SIMPLE
class Synopsis (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Synopsis."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Synopsis')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4327, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Synopsis_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4333, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4333, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the Synopsis as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Synopsis', Synopsis)


# Complex type {http://ddex.net/xml/20100712/ddexC}TariffReference with content type SIMPLE
class TariffReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Reference to a TextDocument containing details of a Tariff."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TariffReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4341, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_TariffReference_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4347, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4347, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the TariffReference (and the TariffSubReference if applicable) as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute TariffSubReference uses Python identifier TariffSubReference
    __TariffSubReference = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'TariffSubReference'), 'TariffSubReference', '__httpddex_netxml20100712ddexC_TariffReference_TariffSubReference', pyxb.binding.datatypes.string)
    __TariffSubReference._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4352, 16)
    __TariffSubReference._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4352, 16)
    
    TariffSubReference = property(__TariffSubReference.value, __TariffSubReference.set, None, 'The Reference to a TextDocument containing more specific details of a Tariff. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode,
        __TariffSubReference.name() : __TariffSubReference
    })
Namespace.addCategoryObject('typeBinding', 'TariffReference', TariffReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}TaxRate with content type ELEMENT_ONLY
class TaxRate (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a TaxRate."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TaxRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4374, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Rate uses Python identifier Rate
    __Rate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Rate'), 'Rate', '__httpddex_netxml20100712ddexC_TaxRate_Rate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4379, 12), )

    
    Rate = property(__Rate.value, __Rate.set, None, 'The TaxRate as a percentage.')

    
    # Element TaxType uses Python identifier TaxType
    __TaxType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TaxType'), 'TaxType', '__httpddex_netxml20100712ddexC_TaxRate_TaxType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4384, 12), )

    
    TaxType = property(__TaxType.value, __TaxType.set, None, 'A Composite containing details of the Type of Tax.')

    
    # Element TaxScope uses Python identifier TaxScope
    __TaxScope = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TaxScope'), 'TaxScope', '__httpddex_netxml20100712ddexC_TaxRate_TaxScope', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4389, 12), )

    
    TaxScope = property(__TaxScope.value, __TaxScope.set, None, 'A Composite containing details of the Type of Tax according to its scope.')

    _ElementMap.update({
        __Rate.name() : __Rate,
        __TaxType.name() : __TaxType,
        __TaxScope.name() : __TaxScope
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'TaxRate', TaxRate)


# Complex type {http://ddex.net/xml/20100712/ddexC}TechnicalInstantiation with content type ELEMENT_ONLY
class TechnicalInstantiation (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing technical details of a Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TechnicalInstantiation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4434, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element DrmEnforcementType uses Python identifier DrmEnforcementType
    __DrmEnforcementType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DrmEnforcementType'), 'DrmEnforcementType', '__httpddex_netxml20100712ddexC_TechnicalInstantiation_DrmEnforcementType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4439, 12), )

    
    DrmEnforcementType = property(__DrmEnforcementType.value, __DrmEnforcementType.set, None, 'A Type of DRM enforcement.')

    
    # Element VideoDefinitionType uses Python identifier VideoDefinitionType
    __VideoDefinitionType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VideoDefinitionType'), 'VideoDefinitionType', '__httpddex_netxml20100712ddexC_TechnicalInstantiation_VideoDefinitionType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4444, 12), )

    
    VideoDefinitionType = property(__VideoDefinitionType.value, __VideoDefinitionType.set, None, 'A Type of resolution (or definition) in which a Video is provided.')

    
    # Element CodingType uses Python identifier CodingType
    __CodingType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CodingType'), 'CodingType', '__httpddex_netxml20100712ddexC_TechnicalInstantiation_CodingType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4449, 12), )

    
    CodingType = property(__CodingType.value, __CodingType.set, None, 'A Type of coding used to encode a Resource.')

    
    # Element BitRate uses Python identifier BitRate
    __BitRate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'BitRate'), 'BitRate', '__httpddex_netxml20100712ddexC_TechnicalInstantiation_BitRate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4454, 12), )

    
    BitRate = property(__BitRate.value, __BitRate.set, None, 'A Composite containing the BitRate for the audio data and a UnitOfMeasure (the default is kbps).')

    _ElementMap.update({
        __DrmEnforcementType.name() : __DrmEnforcementType,
        __VideoDefinitionType.name() : __VideoDefinitionType,
        __CodingType.name() : __CodingType,
        __BitRate.name() : __BitRate
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'TechnicalInstantiation', TechnicalInstantiation)


# Complex type {http://ddex.net/xml/20100712/ddexC}Text with content type ELEMENT_ONLY
class Text (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Text."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Text')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4467, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TextType uses Python identifier TextType
    __TextType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TextType'), 'TextType', '__httpddex_netxml20100712ddexC_Text_TextType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4472, 12), )

    
    TextType = property(__TextType.value, __TextType.set, None, 'A Composite containing details of the Type of the Text.')

    
    # Element IsArtistRelated uses Python identifier IsArtistRelated
    __IsArtistRelated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), 'IsArtistRelated', '__httpddex_netxml20100712ddexC_Text_IsArtistRelated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4477, 12), )

    
    IsArtistRelated = property(__IsArtistRelated.value, __IsArtistRelated.set, None, 'The Flag indicating whether the Text is related to an Artist (=True) or not (=False).')

    
    # Element TextId uses Python identifier TextId
    __TextId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TextId'), 'TextId', '__httpddex_netxml20100712ddexC_Text_TextId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4482, 12), )

    
    TextId = property(__TextId.value, __TextId.set, None, 'A Composite containing details of an Identifier of the Text.')

    
    # Element IndirectTextId uses Python identifier IndirectTextId
    __IndirectTextId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectTextId'), 'IndirectTextId', '__httpddex_netxml20100712ddexC_Text_IndirectTextId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4487, 12), )

    
    IndirectTextId = property(__IndirectTextId.value, __IndirectTextId.set, None, 'A Composite containing details of a MusicalWorkId of a MusicalWork used in the Text.')

    
    # Element ResourceReference uses Python identifier ResourceReference
    __ResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReference'), 'ResourceReference', '__httpddex_netxml20100712ddexC_Text_ResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4492, 12), )

    
    ResourceReference = property(__ResourceReference.value, __ResourceReference.set, None, 'The Identifier (specific to the Message) of the Text within the Release which contains it. This LocalAnchor is a string starting with the letter A.')

    
    # Element ResourceMusicalWorkReferenceList uses Python identifier ResourceMusicalWorkReferenceList
    __ResourceMusicalWorkReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), 'ResourceMusicalWorkReferenceList', '__httpddex_netxml20100712ddexC_Text_ResourceMusicalWorkReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4497, 12), )

    
    ResourceMusicalWorkReferenceList = property(__ResourceMusicalWorkReferenceList.value, __ResourceMusicalWorkReferenceList.set, None, 'A Composite containing details of one or more MusicalWorks contained in the Text.')

    
    # Element ResourceContainedResourceReferenceList uses Python identifier ResourceContainedResourceReferenceList
    __ResourceContainedResourceReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), 'ResourceContainedResourceReferenceList', '__httpddex_netxml20100712ddexC_Text_ResourceContainedResourceReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4502, 12), )

    
    ResourceContainedResourceReferenceList = property(__ResourceContainedResourceReferenceList.value, __ResourceContainedResourceReferenceList.set, None, 'A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current Text.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_Text_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4507, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the Text.')

    
    # Element CreationDate uses Python identifier CreationDate
    __CreationDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CreationDate'), 'CreationDate', '__httpddex_netxml20100712ddexC_Text_CreationDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4512, 12), )

    
    CreationDate = property(__CreationDate.value, __CreationDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Text was created.')

    
    # Element TextDetailsByTerritory uses Python identifier TextDetailsByTerritory
    __TextDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TextDetailsByTerritory'), 'TextDetailsByTerritory', '__httpddex_netxml20100712ddexC_Text_TextDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4517, 12), )

    
    TextDetailsByTerritory = property(__TextDetailsByTerritory.value, __TextDetailsByTerritory.set, None, 'A Composite containing details of the Text which may vary according to Territory of release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Text_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4523, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4523, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the Text as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TextType.name() : __TextType,
        __IsArtistRelated.name() : __IsArtistRelated,
        __TextId.name() : __TextId,
        __IndirectTextId.name() : __IndirectTextId,
        __ResourceReference.name() : __ResourceReference,
        __ResourceMusicalWorkReferenceList.name() : __ResourceMusicalWorkReferenceList,
        __ResourceContainedResourceReferenceList.name() : __ResourceContainedResourceReferenceList,
        __Title.name() : __Title,
        __CreationDate.name() : __CreationDate,
        __TextDetailsByTerritory.name() : __TextDetailsByTerritory
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Text', Text)


# Complex type {http://ddex.net/xml/20100712/ddexC}TextDetailsByTerritory with content type ELEMENT_ONLY
class TextDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Descriptors, Dates and other attributes of a Text which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TextDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4553, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_TextDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4559, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the Text details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_TextDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4564, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the Text details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20100712ddexC_TextDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4570, 12), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A Composite containing details of a Contributor to the Text.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20100712ddexC_TextDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4575, 12), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A Composite containing details of an indirect Contributor to the Text.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20100712ddexC_TextDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4580, 12), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A Composite containing details of the CLine for the Text.')

    
    # Element CourtesyLine uses Python identifier CourtesyLine
    __CourtesyLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), 'CourtesyLine', '__httpddex_netxml20100712ddexC_TextDetailsByTerritory_CourtesyLine', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4585, 12), )

    
    CourtesyLine = property(__CourtesyLine.value, __CourtesyLine.set, None, 'A Composite containing an Annotation which acknowledges record companies and/or other Parties giving permission for Artists or others featured in the Text.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20100712ddexC_TextDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4590, 12), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Text was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_TextDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4596, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4596, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the TextDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __CLine.name() : __CLine,
        __CourtesyLine.name() : __CourtesyLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'TextDetailsByTerritory', TextDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}TextId with content type ELEMENT_ONLY
class TextId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Identifiers of a Text."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TextId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4602, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISBN uses Python identifier ISBN
    __ISBN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISBN'), 'ISBN', '__httpddex_netxml20100712ddexC_TextId_ISBN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4607, 12), )

    
    ISBN = property(__ISBN.value, __ISBN.set, None, 'The ISBN (International Standard Book Number defined in ISO 2108) for the Text. An ISBN is a 13-digit number. Pre-2007, ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix "978" and re-calculating the check character.')

    
    # Element ISSN uses Python identifier ISSN
    __ISSN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISSN'), 'ISSN', '__httpddex_netxml20100712ddexC_TextId_ISSN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4612, 12), )

    
    ISSN = property(__ISSN.value, __ISSN.set, None, 'The ISSN (International Standard Serial Number defined in ISO 3297) identifying the Text. An ISSN comprises two groups of four digits, separated by a hyphen and a control digit.')

    
    # Element SICI uses Python identifier SICI
    __SICI = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SICI'), 'SICI', '__httpddex_netxml20100712ddexC_TextId_SICI', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4617, 12), )

    
    SICI = property(__SICI.value, __SICI.set, None, 'The SICI (Serial Item and Contribution Identifier defined in ANSI/NISO Z39.56-199) for the Text.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_TextId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4622, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the Text (usually one per society involved in the messaging).')

    _ElementMap.update({
        __ISBN.name() : __ISBN,
        __ISSN.name() : __ISSN,
        __SICI.name() : __SICI,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'TextId', TextId)


# Complex type {http://ddex.net/xml/20100712/ddexC}TitleText with content type SIMPLE
class TitleText (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a TitleText."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TitleText')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4675, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_TitleText_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4681, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4681, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the TitleText as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'TitleText', TitleText)


# Complex type {http://ddex.net/xml/20100712/ddexC}TotalRoyaltyAmount with content type ELEMENT_ONLY
class TotalRoyaltyAmount (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a total RoyaltyAmount."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TotalRoyaltyAmount')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4689, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseType uses Python identifier ReleaseType
    __ReleaseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseType'), 'ReleaseType', '__httpddex_netxml20100712ddexC_TotalRoyaltyAmount_ReleaseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4694, 12), )

    
    ReleaseType = property(__ReleaseType.value, __ReleaseType.set, None, 'A Composite containing details of the ReleaseType for which the RoyaltyAmount is calculated.')

    
    # Element RightsType uses Python identifier RightsType
    __RightsType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsType'), 'RightsType', '__httpddex_netxml20100712ddexC_TotalRoyaltyAmount_RightsType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4699, 12), )

    
    RightsType = property(__RightsType.value, __RightsType.set, None, 'A Composite containing details of the RightsType for which the RoyaltyAmount is calculated.')

    
    # Element RoyaltyAmount uses Python identifier RoyaltyAmount
    __RoyaltyAmount = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RoyaltyAmount'), 'RoyaltyAmount', '__httpddex_netxml20100712ddexC_TotalRoyaltyAmount_RoyaltyAmount', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4704, 12), )

    
    RoyaltyAmount = property(__RoyaltyAmount.value, __RoyaltyAmount.set, None, 'A Composite containing details of the RoyaltyAmount due.')

    _ElementMap.update({
        __ReleaseType.name() : __ReleaseType,
        __RightsType.name() : __RightsType,
        __RoyaltyAmount.name() : __RoyaltyAmount
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'TotalRoyaltyAmount', TotalRoyaltyAmount)


# Complex type {http://ddex.net/xml/20100712/ddexC}Usage with content type ELEMENT_ONLY
class Usage (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing Types and number of Usages of a Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Usage')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4711, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20100712ddexC_Usage_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4716, 12), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20100712ddexC_Usage_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4721, 12), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A Composite containing details of a physical interface by which a Consumer is intended to use a Service or Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20100712ddexC_Usage_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4726, 12), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A Composite containing details of a distribution channel intended to be used to disseminate a Service or Release to a Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20100712ddexC_Usage_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4731, 12), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A Composite containing details of a Carrier.')

    
    # Element TechnicalInstantiation uses Python identifier TechnicalInstantiation
    __TechnicalInstantiation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TechnicalInstantiation'), 'TechnicalInstantiation', '__httpddex_netxml20100712ddexC_Usage_TechnicalInstantiation', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4736, 12), )

    
    TechnicalInstantiation = property(__TechnicalInstantiation.value, __TechnicalInstantiation.set, None, 'A Composite containing technical details of the Release.')

    
    # Element NumberOfUsages uses Python identifier NumberOfUsages
    __NumberOfUsages = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NumberOfUsages'), 'NumberOfUsages', '__httpddex_netxml20100712ddexC_Usage_NumberOfUsages', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4741, 12), )

    
    NumberOfUsages = property(__NumberOfUsages.value, __NumberOfUsages.set, None, 'The number of times a Release can be used under the terms of the Deal.')

    _ElementMap.update({
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType,
        __TechnicalInstantiation.name() : __TechnicalInstantiation,
        __NumberOfUsages.name() : __NumberOfUsages
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'Usage', Usage)


# Complex type {http://ddex.net/xml/20100712/ddexC}UserDefinedResource with content type ELEMENT_ONLY
class UserDefinedResource (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a UserDefinedResource."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserDefinedResource')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4748, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element UserDefinedResourceType uses Python identifier UserDefinedResourceType
    __UserDefinedResourceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserDefinedResourceType'), 'UserDefinedResourceType', '__httpddex_netxml20100712ddexC_UserDefinedResource_UserDefinedResourceType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4753, 12), )

    
    UserDefinedResourceType = property(__UserDefinedResourceType.value, __UserDefinedResourceType.set, None, 'A Composite containing details of the Type of the UserDefinedResource.')

    
    # Element IsArtistRelated uses Python identifier IsArtistRelated
    __IsArtistRelated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), 'IsArtistRelated', '__httpddex_netxml20100712ddexC_UserDefinedResource_IsArtistRelated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4758, 12), )

    
    IsArtistRelated = property(__IsArtistRelated.value, __IsArtistRelated.set, None, 'The Flag indicating whether the UserDefinedResource is related to an Artist (=True) or not (=False).')

    
    # Element UserDefinedResourceId uses Python identifier UserDefinedResourceId
    __UserDefinedResourceId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserDefinedResourceId'), 'UserDefinedResourceId', '__httpddex_netxml20100712ddexC_UserDefinedResource_UserDefinedResourceId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4763, 12), )

    
    UserDefinedResourceId = property(__UserDefinedResourceId.value, __UserDefinedResourceId.set, None, 'A Composite containing details of Identifiers of the UserDefinedResource.')

    
    # Element IndirectUserDefinedResourceId uses Python identifier IndirectUserDefinedResourceId
    __IndirectUserDefinedResourceId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectUserDefinedResourceId'), 'IndirectUserDefinedResourceId', '__httpddex_netxml20100712ddexC_UserDefinedResource_IndirectUserDefinedResourceId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4768, 12), )

    
    IndirectUserDefinedResourceId = property(__IndirectUserDefinedResourceId.value, __IndirectUserDefinedResourceId.set, None, 'A Composite containing details of a MusicalWorkId of a MusicalWork used in the UserDefinedResource.')

    
    # Element ResourceReference uses Python identifier ResourceReference
    __ResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReference'), 'ResourceReference', '__httpddex_netxml20100712ddexC_UserDefinedResource_ResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4773, 12), )

    
    ResourceReference = property(__ResourceReference.value, __ResourceReference.set, None, 'The Identifier (specific to the Message) of the UserDefinedResource within the Release which contains it. This LocalAnchor is a string starting with the letter A.')

    
    # Element ResourceMusicalWorkReferenceList uses Python identifier ResourceMusicalWorkReferenceList
    __ResourceMusicalWorkReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), 'ResourceMusicalWorkReferenceList', '__httpddex_netxml20100712ddexC_UserDefinedResource_ResourceMusicalWorkReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4778, 12), )

    
    ResourceMusicalWorkReferenceList = property(__ResourceMusicalWorkReferenceList.value, __ResourceMusicalWorkReferenceList.set, None, 'A Composite containing details of one or more MusicalWorks contained in the UserDefinedResource.')

    
    # Element ResourceContainedResourceReferenceList uses Python identifier ResourceContainedResourceReferenceList
    __ResourceContainedResourceReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), 'ResourceContainedResourceReferenceList', '__httpddex_netxml20100712ddexC_UserDefinedResource_ResourceContainedResourceReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4783, 12), )

    
    ResourceContainedResourceReferenceList = property(__ResourceContainedResourceReferenceList.value, __ResourceContainedResourceReferenceList.set, None, 'A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current UserDefinedResource.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_UserDefinedResource_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4788, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the UserDefinedResource.')

    
    # Element UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_UserDefinedResource_UserDefinedValue', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4793, 12), )

    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A Composite containing details of a UserDefinedValue.')

    
    # Element UserDefinedResourceDetailsByTerritory uses Python identifier UserDefinedResourceDetailsByTerritory
    __UserDefinedResourceDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserDefinedResourceDetailsByTerritory'), 'UserDefinedResourceDetailsByTerritory', '__httpddex_netxml20100712ddexC_UserDefinedResource_UserDefinedResourceDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4798, 12), )

    
    UserDefinedResourceDetailsByTerritory = property(__UserDefinedResourceDetailsByTerritory.value, __UserDefinedResourceDetailsByTerritory.set, None, 'A Composite containing details of the UserDefinedResource which may vary according to Territory of release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_UserDefinedResource_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4804, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4804, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the UserDefinedResource as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __UserDefinedResourceType.name() : __UserDefinedResourceType,
        __IsArtistRelated.name() : __IsArtistRelated,
        __UserDefinedResourceId.name() : __UserDefinedResourceId,
        __IndirectUserDefinedResourceId.name() : __IndirectUserDefinedResourceId,
        __ResourceReference.name() : __ResourceReference,
        __ResourceMusicalWorkReferenceList.name() : __ResourceMusicalWorkReferenceList,
        __ResourceContainedResourceReferenceList.name() : __ResourceContainedResourceReferenceList,
        __Title.name() : __Title,
        __UserDefinedValue.name() : __UserDefinedValue,
        __UserDefinedResourceDetailsByTerritory.name() : __UserDefinedResourceDetailsByTerritory
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'UserDefinedResource', UserDefinedResource)


# Complex type {http://ddex.net/xml/20100712/ddexC}UserDefinedResourceDetailsByTerritory with content type ELEMENT_ONLY
class UserDefinedResourceDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Descriptors, Dates and other attributes of a UserDefinedResource application which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserDefinedResourceDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4810, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_UserDefinedResourceDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4816, 16), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the UserDefinedResource details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20100712ddexC_UserDefinedResourceDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4821, 16), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A Territory to which the UserDefinedResource details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20100712ddexC_UserDefinedResourceDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4827, 12), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A Composite containing details of a Contributor to the UserDefinedResource.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20100712ddexC_UserDefinedResourceDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4832, 12), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A Composite containing details of an indirect Contributor to the UserDefinedResource.')

    
    # Element UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_UserDefinedResourceDetailsByTerritory_UserDefinedValue', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4837, 12), )

    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A Composite containing details of a UserDefinedValue.')

    
    # Element PLine uses Python identifier PLine
    __PLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLine'), 'PLine', '__httpddex_netxml20100712ddexC_UserDefinedResourceDetailsByTerritory_PLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4842, 12), )

    
    PLine = property(__PLine.value, __PLine.set, None, 'A Composite containing details of the PLine for the UserDefinedResource.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20100712ddexC_UserDefinedResourceDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4847, 12), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A Composite containing details of the CLine for the UserDefinedResource.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20100712ddexC_UserDefinedResourceDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4852, 12), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the UserDefinedResource was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_UserDefinedResourceDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4858, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4858, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the UserDefinedResourceDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __UserDefinedValue.name() : __UserDefinedValue,
        __PLine.name() : __PLine,
        __CLine.name() : __CLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'UserDefinedResourceDetailsByTerritory', UserDefinedResourceDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}UserDefinedResourceId with content type ELEMENT_ONLY
class UserDefinedResourceId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Identifiers of a UserDefinedResource."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserDefinedResourceId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4864, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_UserDefinedResourceId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4869, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the UserDefinedResource.')

    _ElementMap.update({
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'UserDefinedResourceId', UserDefinedResourceId)


# Complex type {http://ddex.net/xml/20100712/ddexC}UserDefinedResourceType with content type SIMPLE
class UserDefinedResourceType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a UserDefinedResourceType."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserDefinedResourceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4876, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_UserDefinedResourceType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4882, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4882, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the UserDefinedResourceType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'UserDefinedResourceType', UserDefinedResourceType)


# Complex type {http://ddex.net/xml/20100712/ddexC}UserDefinedValue with content type SIMPLE
class UserDefinedValue (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a UserDefinedValue."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserDefinedValue')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4890, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_UserDefinedValue_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4896, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4896, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the UserDefinedValue. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute Description uses Python identifier Description
    __Description = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Description'), 'Description', '__httpddex_netxml20100712ddexC_UserDefinedValue_Description', pyxb.binding.datatypes.string)
    __Description._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4901, 16)
    __Description._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4901, 16)
    
    Description = property(__Description.value, __Description.set, None, 'A textual Description of the Type or function of the UserDefinedValue. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_UserDefinedValue_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4906, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4906, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the Description as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __Description.name() : __Description,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'UserDefinedValue', UserDefinedValue)


# Complex type {http://ddex.net/xml/20100712/ddexC}Video with content type ELEMENT_ONLY
class Video (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Video."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Video')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4952, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element VideoType uses Python identifier VideoType
    __VideoType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VideoType'), 'VideoType', '__httpddex_netxml20100712ddexC_Video_VideoType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4957, 12), )

    
    VideoType = property(__VideoType.value, __VideoType.set, None, 'A Composite containing details of the Type of the Video.')

    
    # Element IsArtistRelated uses Python identifier IsArtistRelated
    __IsArtistRelated = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), 'IsArtistRelated', '__httpddex_netxml20100712ddexC_Video_IsArtistRelated', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4962, 12), )

    
    IsArtistRelated = property(__IsArtistRelated.value, __IsArtistRelated.set, None, 'The Flag indicating whether the Video is related to an Artist (=True) or not (=False).')

    
    # Element VideoId uses Python identifier VideoId
    __VideoId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VideoId'), 'VideoId', '__httpddex_netxml20100712ddexC_Video_VideoId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4967, 12), )

    
    VideoId = property(__VideoId.value, __VideoId.set, None, 'A Composite containing details of an Identifier of the Video.')

    
    # Element IndirectVideoId uses Python identifier IndirectVideoId
    __IndirectVideoId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectVideoId'), 'IndirectVideoId', '__httpddex_netxml20100712ddexC_Video_IndirectVideoId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4972, 12), )

    
    IndirectVideoId = property(__IndirectVideoId.value, __IndirectVideoId.set, None, 'A Composite containing details of a MusicalWorkId of a MusicalWork used in the Video.')

    
    # Element ResourceReference uses Python identifier ResourceReference
    __ResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReference'), 'ResourceReference', '__httpddex_netxml20100712ddexC_Video_ResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4977, 12), )

    
    ResourceReference = property(__ResourceReference.value, __ResourceReference.set, None, 'The Identifier (specific to the Message) of the Video within the Release which contains it. This LocalAnchor is a string starting with the letter A.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20100712ddexC_Video_ReferenceTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4982, 12), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A Composite containing details of the ReferenceTitle of the Video.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_Video_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4987, 12), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the Video.')

    
    # Element InstrumentationDescription uses Python identifier InstrumentationDescription
    __InstrumentationDescription = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'InstrumentationDescription'), 'InstrumentationDescription', '__httpddex_netxml20100712ddexC_Video_InstrumentationDescription', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4992, 12), )

    
    InstrumentationDescription = property(__InstrumentationDescription.value, __InstrumentationDescription.set, None, 'A Composite containing a Description of the Type of instrumentation of the MusicalWork(s) in the Video.')

    
    # Element IsMedley uses Python identifier IsMedley
    __IsMedley = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsMedley'), 'IsMedley', '__httpddex_netxml20100712ddexC_Video_IsMedley', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4997, 12), )

    
    IsMedley = property(__IsMedley.value, __IsMedley.set, None, 'The Flag indicating whether the Video is a Medley (=True) or not (=False).')

    
    # Element IsPotpourri uses Python identifier IsPotpourri
    __IsPotpourri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsPotpourri'), 'IsPotpourri', '__httpddex_netxml20100712ddexC_Video_IsPotpourri', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5002, 12), )

    
    IsPotpourri = property(__IsPotpourri.value, __IsPotpourri.set, None, 'The Flag indicating whether the Video is a Potpourri (=True) or not (=False).')

    
    # Element IsInstrumental uses Python identifier IsInstrumental
    __IsInstrumental = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsInstrumental'), 'IsInstrumental', '__httpddex_netxml20100712ddexC_Video_IsInstrumental', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5007, 12), )

    
    IsInstrumental = property(__IsInstrumental.value, __IsInstrumental.set, None, 'The Flag indicating whether the Video is instrumental (=True) or not (=False).')

    
    # Element IsBackground uses Python identifier IsBackground
    __IsBackground = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsBackground'), 'IsBackground', '__httpddex_netxml20100712ddexC_Video_IsBackground', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5012, 12), )

    
    IsBackground = property(__IsBackground.value, __IsBackground.set, None, 'The Flag indicating whether the Video is used as background to other audio or audiovisual material (=True) or not (=False).')

    
    # Element IsHiddenResource uses Python identifier IsHiddenResource
    __IsHiddenResource = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsHiddenResource'), 'IsHiddenResource', '__httpddex_netxml20100712ddexC_Video_IsHiddenResource', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5017, 12), )

    
    IsHiddenResource = property(__IsHiddenResource.value, __IsHiddenResource.set, None, 'The Flag indicating whether the Video is hidden in some way from the Consumer (=True) or not (=False).')

    
    # Element IsBonusResource uses Python identifier IsBonusResource
    __IsBonusResource = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsBonusResource'), 'IsBonusResource', '__httpddex_netxml20100712ddexC_Video_IsBonusResource', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5022, 12), )

    
    IsBonusResource = property(__IsBonusResource.value, __IsBonusResource.set, None, 'The Flag indicating whether the Video is additional to those on the original Release of which this is a Version (=True) or not (=False).')

    
    # Element LanguageOfPerformance uses Python identifier LanguageOfPerformance
    __LanguageOfPerformance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LanguageOfPerformance'), 'LanguageOfPerformance', '__httpddex_netxml20100712ddexC_Video_LanguageOfPerformance', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5027, 12), )

    
    LanguageOfPerformance = property(__LanguageOfPerformance.value, __LanguageOfPerformance.set, None, 'The Language of the Performance recorded in the Video (represented by an ISO 639-2 LanguageCode).')

    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20100712ddexC_Video_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5032, 12), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The Duration of the Video (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20100712ddexC_Video_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5037, 12), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Video.')

    
    # Element ResourceMusicalWorkReferenceList uses Python identifier ResourceMusicalWorkReferenceList
    __ResourceMusicalWorkReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), 'ResourceMusicalWorkReferenceList', '__httpddex_netxml20100712ddexC_Video_ResourceMusicalWorkReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5042, 12), )

    
    ResourceMusicalWorkReferenceList = property(__ResourceMusicalWorkReferenceList.value, __ResourceMusicalWorkReferenceList.set, None, 'A Composite containing details of one or more MusicalWorks contained in the Video.')

    
    # Element ResourceContainedResourceReferenceList uses Python identifier ResourceContainedResourceReferenceList
    __ResourceContainedResourceReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), 'ResourceContainedResourceReferenceList', '__httpddex_netxml20100712ddexC_Video_ResourceContainedResourceReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5047, 12), )

    
    ResourceContainedResourceReferenceList = property(__ResourceContainedResourceReferenceList.value, __ResourceContainedResourceReferenceList.set, None, 'A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current Video.')

    
    # Element CreationDate uses Python identifier CreationDate
    __CreationDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CreationDate'), 'CreationDate', '__httpddex_netxml20100712ddexC_Video_CreationDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5052, 12), )

    
    CreationDate = property(__CreationDate.value, __CreationDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Video was created.')

    
    # Element MasteredDate uses Python identifier MasteredDate
    __MasteredDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MasteredDate'), 'MasteredDate', '__httpddex_netxml20100712ddexC_Video_MasteredDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5057, 12), )

    
    MasteredDate = property(__MasteredDate.value, __MasteredDate.set, None, 'A Composite containing details of the Date and Place of the Event in which the Video was originally mastered (either in analogue or digital form).')

    
    # Element VideoDetailsByTerritory uses Python identifier VideoDetailsByTerritory
    __VideoDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VideoDetailsByTerritory'), 'VideoDetailsByTerritory', '__httpddex_netxml20100712ddexC_Video_VideoDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5062, 12), )

    
    VideoDetailsByTerritory = property(__VideoDetailsByTerritory.value, __VideoDetailsByTerritory.set, None, 'A Composite containing details of Descriptors and other attributes of the Video which may vary according to Territory of release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Video_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5068, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5068, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the Video as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __VideoType.name() : __VideoType,
        __IsArtistRelated.name() : __IsArtistRelated,
        __VideoId.name() : __VideoId,
        __IndirectVideoId.name() : __IndirectVideoId,
        __ResourceReference.name() : __ResourceReference,
        __ReferenceTitle.name() : __ReferenceTitle,
        __Title.name() : __Title,
        __InstrumentationDescription.name() : __InstrumentationDescription,
        __IsMedley.name() : __IsMedley,
        __IsPotpourri.name() : __IsPotpourri,
        __IsInstrumental.name() : __IsInstrumental,
        __IsBackground.name() : __IsBackground,
        __IsHiddenResource.name() : __IsHiddenResource,
        __IsBonusResource.name() : __IsBonusResource,
        __LanguageOfPerformance.name() : __LanguageOfPerformance,
        __Duration.name() : __Duration,
        __RightsAgreementId.name() : __RightsAgreementId,
        __ResourceMusicalWorkReferenceList.name() : __ResourceMusicalWorkReferenceList,
        __ResourceContainedResourceReferenceList.name() : __ResourceContainedResourceReferenceList,
        __CreationDate.name() : __CreationDate,
        __MasteredDate.name() : __MasteredDate,
        __VideoDetailsByTerritory.name() : __VideoDetailsByTerritory
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Video', Video)


# Complex type {http://ddex.net/xml/20100712/ddexC}VideoCueSheetReference with content type ELEMENT_ONLY
class VideoCueSheetReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a VideoCueSheetReference."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoCueSheetReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5098, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element VideoCueSheetReference uses Python identifier VideoCueSheetReference
    __VideoCueSheetReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VideoCueSheetReference'), 'VideoCueSheetReference', '__httpddex_netxml20100712ddexC_VideoCueSheetReference_VideoCueSheetReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5103, 12), )

    
    VideoCueSheetReference = property(__VideoCueSheetReference.value, __VideoCueSheetReference.set, None, 'A Reference for a CueSheet (specific to this Message). This LocalAnchorReference is a string starting with the letter Q.')

    _ElementMap.update({
        __VideoCueSheetReference.name() : __VideoCueSheetReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'VideoCueSheetReference', VideoCueSheetReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}VideoId with content type ELEMENT_ONLY
class VideoId (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of Identifiers of a Video."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5126, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20100712ddexC_VideoId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5131, 12), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ISRC (International Standard Recording Code as defined in ISO 3901) for the Video. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.')

    
    # Element ISAN uses Python identifier ISAN
    __ISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISAN'), 'ISAN', '__httpddex_netxml20100712ddexC_VideoId_ISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5136, 12), )

    
    ISAN = property(__ISAN.value, __ISAN.set, None, 'The ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the Video. An ISAN comprises four blocks of four hexadecimal charaters followed by a check character.')

    
    # Element VISAN uses Python identifier VISAN
    __VISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VISAN'), 'VISAN', '__httpddex_netxml20100712ddexC_VideoId_VISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5141, 12), )

    
    VISAN = property(__VISAN.value, __VISAN.set, None, 'The V-ISAN (Version Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the Video. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20100712ddexC_VideoId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5146, 12), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A Composite containing details of the CatalogNumber of the Video.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20100712ddexC_VideoId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5151, 12), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A Composite containing details of a ProprietaryIdentifier of the Video (usually one per society involved in the messaging).')

    _ElementMap.update({
        __ISRC.name() : __ISRC,
        __ISAN.name() : __ISAN,
        __VISAN.name() : __VISAN,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'VideoId', VideoId)


# Complex type {http://ddex.net/xml/20100712/ddexC}WebPage with content type ELEMENT_ONLY
class WebPage (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a WebPage."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'WebPage')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5177, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PageName uses Python identifier PageName
    __PageName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PageName'), 'PageName', '__httpddex_netxml20100712ddexC_WebPage_PageName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5182, 12), )

    
    PageName = property(__PageName.value, __PageName.set, None, 'A Composite containing the Name of the WebPage.')

    
    # Element URL uses Python identifier URL
    __URL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'URL'), 'URL', '__httpddex_netxml20100712ddexC_WebPage_URL', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5187, 12), )

    
    URL = property(__URL.value, __URL.set, None, 'A URL of the WebPage.')

    
    # Element UserName uses Python identifier UserName
    __UserName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserName'), 'UserName', '__httpddex_netxml20100712ddexC_WebPage_UserName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5192, 12), )

    
    UserName = property(__UserName.value, __UserName.set, None, 'An Identifier of a computer user who is granted maintenance access to the WebPage.')

    
    # Element Password uses Python identifier Password
    __Password = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Password'), 'Password', '__httpddex_netxml20100712ddexC_WebPage_Password', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5197, 12), )

    
    Password = property(__Password.value, __Password.set, None, 'A Password needed to grant a user maintenance access to the WebPage in combination with the UserName.')

    _ElementMap.update({
        __PageName.name() : __PageName,
        __URL.name() : __URL,
        __UserName.name() : __UserName,
        __Password.name() : __Password
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'WebPage', WebPage)


# Complex type {http://ddex.net/xml/20100712/ddexC}WorkList with content type ELEMENT_ONLY
class WorkList (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of one or more Works."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'WorkList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5204, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MusicalWork uses Python identifier MusicalWork
    __MusicalWork = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWork'), 'MusicalWork', '__httpddex_netxml20100712ddexC_WorkList_MusicalWork', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5209, 12), )

    
    MusicalWork = property(__MusicalWork.value, __MusicalWork.set, None, 'A Composite containing details of a MusicalWork contained in a Resource.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_WorkList_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5215, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5215, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the WorkList as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __MusicalWork.name() : __MusicalWork
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'WorkList', WorkList)


# Complex type {http://ddex.net/xml/20100712/ddexC}AdministratingRecordCompany with content type ELEMENT_ONLY
class AdministratingRecordCompany (PartyDescriptor):
    """A Composite containing details of an AdministratingRecordCompany."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AdministratingRecordCompany')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 24, 4)
    _ElementMap = PartyDescriptor._ElementMap.copy()
    _AttributeMap = PartyDescriptor._AttributeMap.copy()
    # Base type is PartyDescriptor
    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Attribute Role uses Python identifier Role
    __Role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Role'), 'Role', '__httpddex_netxml20100712ddexC_AdministratingRecordCompany_Role', _ImportedBinding__ddex.AdministratingRecordCompanyRole, required=True)
    __Role._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 30, 16)
    __Role._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 30, 16)
    
    Role = property(__Role.value, __Role.set, None, 'The role played by the Party responsible for administering Rights in a Resource or a Release.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Role.name() : __Role
    })
Namespace.addCategoryObject('typeBinding', 'AdministratingRecordCompany', AdministratingRecordCompany)


# Complex type {http://ddex.net/xml/20100712/ddexC}AppliedRoyaltyRate with content type SIMPLE
class AppliedRoyaltyRate (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an applied RoyaltyRate."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AppliedRoyaltyRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 101, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute ValueType uses Python identifier ValueType
    __ValueType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ValueType'), 'ValueType', '__httpddex_netxml20100712ddexC_AppliedRoyaltyRate_ValueType', _ImportedBinding__ddex.ValueType, required=True)
    __ValueType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 107, 16)
    __ValueType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 107, 16)
    
    ValueType = property(__ValueType.value, __ValueType.set, None, 'The Type of the numeric value specified for the RoyaltyRate. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute RoyaltyRateType uses Python identifier RoyaltyRateType
    __RoyaltyRateType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'RoyaltyRateType'), 'RoyaltyRateType', '__httpddex_netxml20100712ddexC_AppliedRoyaltyRate_RoyaltyRateType', _ImportedBinding__ddex.RoyaltyRateType, required=True)
    __RoyaltyRateType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 112, 16)
    __RoyaltyRateType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 112, 16)
    
    RoyaltyRateType = property(__RoyaltyRateType.value, __RoyaltyRateType.set, None, 'A Type of RoyaltyRate upon which the per unit royalty is calculated.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_AppliedRoyaltyRate_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 117, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 117, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the RoyaltyRateType if it is UserDefined. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_AppliedRoyaltyRate_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 122, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 122, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the RoyaltyRateType if it is UserDefined. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __ValueType.name() : __ValueType,
        __RoyaltyRateType.name() : __RoyaltyRateType,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'AppliedRoyaltyRate', AppliedRoyaltyRate)


# Complex type {http://ddex.net/xml/20100712/ddexC}ArtistRole with content type SIMPLE
class ArtistRole (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an ArtistRole. Note: This can be used in a DdexMessage in relation to any Performance or Fixation either of which may form the whole or part of the Resource itself. Example: if an "AssociatedPerformer" is shown as a Contributor to a MusicalWork it refers to a Performer of a Resource (e.g. a SoundRecording) expressing the MusicalWork."""
    _TypeDefinition = _ImportedBinding__ddex.ArtistRole
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ArtistRole')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 130, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ArtistRole
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ArtistRole_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 136, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 136, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ArtistRole. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ArtistRole_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 141, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 141, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ArtistRole. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ArtistRole', ArtistRole)


# Complex type {http://ddex.net/xml/20100712/ddexC}AudioCodecType with content type SIMPLE
class AudioCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an AudioCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.AudioCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AudioCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 149, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.AudioCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20100712ddexC_AudioCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 155, 16)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 155, 16)
    
    Version = property(__Version.value, __Version.set, None, 'The Identifier of the Version of the AudioCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_AudioCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 160, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 160, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the AudioCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_AudioCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 165, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 165, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the AudioCodecType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'AudioCodecType', AudioCodecType)


# Complex type {http://ddex.net/xml/20100712/ddexC}BitRate with content type SIMPLE
class BitRate (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a BitRate and a UnitOfMeasure."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'BitRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 190, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute UnitOfMeasure uses Python identifier UnitOfMeasure
    __UnitOfMeasure = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UnitOfMeasure'), 'UnitOfMeasure', '__httpddex_netxml20100712ddexC_BitRate_UnitOfMeasure', _ImportedBinding__ddex.UnitOfBitRate)
    __UnitOfMeasure._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 196, 16)
    __UnitOfMeasure._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 196, 16)
    
    UnitOfMeasure = property(__UnitOfMeasure.value, __UnitOfMeasure.set, None, 'The UnitOfMeasure of the BitRate. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __UnitOfMeasure.name() : __UnitOfMeasure
    })
Namespace.addCategoryObject('typeBinding', 'BitRate', BitRate)


# Complex type {http://ddex.net/xml/20100712/ddexC}CalculationType with content type SIMPLE
class CalculationType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CalculationType."""
    _TypeDefinition = _ImportedBinding__ddex.CalculationType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CalculationType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 204, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CalculationType
    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_CalculationType_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 210, 16)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 210, 16)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the CalculationType in a group of CalculationTypes. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'CalculationType', CalculationType)


# Complex type {http://ddex.net/xml/20100712/ddexC}CarrierType with content type SIMPLE
class CarrierType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CarrierType."""
    _TypeDefinition = _ImportedBinding__ddex.CarrierType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CarrierType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 218, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CarrierType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CarrierType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 224, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 224, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the CarrierType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_CarrierType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 229, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 229, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the CarrierType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CarrierType', CarrierType)


# Complex type {http://ddex.net/xml/20100712/ddexC}Character with content type ELEMENT_ONLY
class Character (PartyDescriptor):
    """A Composite containing details of a Character. A Character may be described through Name, Identifier and Roles."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Character')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 251, 4)
    _ElementMap = PartyDescriptor._ElementMap.copy()
    _AttributeMap = PartyDescriptor._AttributeMap.copy()
    # Base type is PartyDescriptor
    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20100712ddexC_Character_ResourceContributor', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 258, 20), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A Composite containing details of the Name, Identifier and role(s) of a Contributor.')

    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_Character_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 264, 16)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 264, 16)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the Character in a group of Characters. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __ResourceContributor.name() : __ResourceContributor
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'Character', Character)


# Complex type {http://ddex.net/xml/20100712/ddexC}CollectionType with content type SIMPLE
class CollectionType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CollectionType. Collections referenced from Video Resources are of CollectionType VideoChapter . Collections referenced from a Release composite are of CollectionType Series, Season or Episode."""
    _TypeDefinition = _ImportedBinding__ddex.CollectionType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 508, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CollectionType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CollectionType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 514, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 514, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the CollectionType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_CollectionType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 519, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 519, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the CollectionType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CollectionType', CollectionType)


# Complex type {http://ddex.net/xml/20100712/ddexC}CommercialModelType with content type SIMPLE
class CommercialModelType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CommercialModelType."""
    _TypeDefinition = _ImportedBinding__ddex.CommercialModelType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CommercialModelType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 541, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CommercialModelType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CommercialModelType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 547, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 547, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the CommercialModelType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_CommercialModelType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 552, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 552, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the CommercialModelType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CommercialModelType', CommercialModelType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ContainedReleaseSummary with content type ELEMENT_ONLY
class ContainedReleaseSummary (ReleaseSummary):
    """A Composite containing summary details of a Release for which data is provided in a Message."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ContainedReleaseSummary')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 574, 4)
    _ElementMap = ReleaseSummary._ElementMap.copy()
    _AttributeMap = ReleaseSummary._AttributeMap.copy()
    # Base type is ReleaseSummary
    
    # Element RelatedRelease uses Python identifier RelatedRelease
    __RelatedRelease = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RelatedRelease'), 'RelatedRelease', '__httpddex_netxml20100712ddexC_ContainedReleaseSummary_RelatedRelease', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 581, 20), )

    
    RelatedRelease = property(__RelatedRelease.value, __RelatedRelease.set, None, 'A Composite containing details of a Release (or a PhysicalProduct or a DigitalProduct derived from such a Release) which is related to the Release.')

    
    # Element ReleaseId (ReleaseId) inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummary
    
    # Element ReferenceTitle (ReferenceTitle) inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummary
    
    # Element ReleaseSummaryDetailsByTerritory (ReleaseSummaryDetailsByTerritory) inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummary
    
    # Element RightsAgreementId (RightsAgreementId) inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummary
    
    # Attribute LanguageAndScriptCode inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummary
    _ElementMap.update({
        __RelatedRelease.name() : __RelatedRelease
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ContainedReleaseSummary', ContainedReleaseSummary)


# Complex type {http://ddex.net/xml/20100712/ddexC}CueOrigin with content type SIMPLE
class CueOrigin (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CueOrigin."""
    _TypeDefinition = _ImportedBinding__ddex.CueOrigin
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueOrigin')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 623, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CueOrigin
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CueOrigin_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 629, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 629, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the CueOrigin. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_CueOrigin_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 634, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 634, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the CueOrigin. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueOrigin', CueOrigin)


# Complex type {http://ddex.net/xml/20100712/ddexC}CueSheetType with content type SIMPLE
class CueSheetType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CueSheetType."""
    _TypeDefinition = _ImportedBinding__ddex.CueSheetType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueSheetType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 642, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CueSheetType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CueSheetType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 648, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 648, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the CueSheetType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_CueSheetType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 653, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 653, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the CueSheetType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueSheetType', CueSheetType)


# Complex type {http://ddex.net/xml/20100712/ddexC}CueThemeType with content type SIMPLE
class CueThemeType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ThemeType for a Creation referenced in a Cue."""
    _TypeDefinition = _ImportedBinding__ddex.ThemeType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueThemeType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 661, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ThemeType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CueThemeType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 667, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 667, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ThemeType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_CueThemeType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 672, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 672, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ThemeType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueThemeType', CueThemeType)


# Complex type {http://ddex.net/xml/20100712/ddexC}CueUseType with content type SIMPLE
class CueUseType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a CueUseType."""
    _TypeDefinition = _ImportedBinding__ddex.CueUseType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueUseType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 680, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CueUseType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CueUseType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 686, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 686, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the CueUseType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_CueUseType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 691, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 691, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the CueUseType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueUseType', CueUseType)


# Complex type {http://ddex.net/xml/20100712/ddexC}CueVisualPerceptionType with content type SIMPLE
class CueVisualPerceptionType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a VisualPerceptionType for a Creation referenced in a Cue."""
    _TypeDefinition = _ImportedBinding__ddex.VisualPerceptionType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueVisualPerceptionType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 699, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.VisualPerceptionType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CueVisualPerceptionType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 705, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 705, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the VisualPerceptionType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_CueVisualPerceptionType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 710, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 710, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the VisualPerceptionType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueVisualPerceptionType', CueVisualPerceptionType)


# Complex type {http://ddex.net/xml/20100712/ddexC}CueVocalType with content type SIMPLE
class CueVocalType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a VocalType for a Creation referenced in a Cue."""
    _TypeDefinition = _ImportedBinding__ddex.VocalType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueVocalType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 718, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.VocalType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_CueVocalType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 724, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 724, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the VocalType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_CueVocalType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 729, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 729, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the VocalType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueVocalType', CueVocalType)


# Complex type {http://ddex.net/xml/20100712/ddexC}DeductionRate with content type SIMPLE
class DeductionRate (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a DeductionRate."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DeductionRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 751, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute DeductionRateType uses Python identifier DeductionRateType
    __DeductionRateType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'DeductionRateType'), 'DeductionRateType', '__httpddex_netxml20100712ddexC_DeductionRate_DeductionRateType', _ImportedBinding__ddex.DeductionRateType, required=True)
    __DeductionRateType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 757, 16)
    __DeductionRateType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 757, 16)
    
    DeductionRateType = property(__DeductionRateType.value, __DeductionRateType.set, None, 'A Type of DeductionRate.This is represented in an XML schema as an XML Attribute.')

    
    # Attribute DeductionDescription uses Python identifier DeductionDescription
    __DeductionDescription = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'DeductionDescription'), 'DeductionDescription', '__httpddex_netxml20100712ddexC_DeductionRate_DeductionDescription', pyxb.binding.datatypes.string)
    __DeductionDescription._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 762, 16)
    __DeductionDescription._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 762, 16)
    
    DeductionDescription = property(__DeductionDescription.value, __DeductionDescription.set, None, 'A Description of the deduction to be applied to an Amount to determine the actual Amount paid. This is a text string with no prescribed allowed values.This is represented in an XML schema as an XML Attribute.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_DeductionRate_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 767, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 767, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script of the DeductionDescription as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __DeductionRateType.name() : __DeductionRateType,
        __DeductionDescription.name() : __DeductionDescription,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'DeductionRate', DeductionRate)


# Complex type {http://ddex.net/xml/20100712/ddexC}DisplayArtist with content type ELEMENT_ONLY
class DisplayArtist (PartyDescriptor):
    """A Composite containing details of a DisplayArtist. A DisplayArtist may be described through Name, Identifier and Roles."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DisplayArtist')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 789, 4)
    _ElementMap = PartyDescriptor._ElementMap.copy()
    _AttributeMap = PartyDescriptor._AttributeMap.copy()
    # Base type is PartyDescriptor
    
    # Element ArtistRole uses Python identifier ArtistRole
    __ArtistRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ArtistRole'), 'ArtistRole', '__httpddex_netxml20100712ddexC_DisplayArtist_ArtistRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 796, 20), )

    
    ArtistRole = property(__ArtistRole.value, __ArtistRole.set, None, 'A Composite containing details of a role played by the DisplayArtist in relation to other DisplayArtists.')

    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_DisplayArtist_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 802, 16)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 802, 16)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the DisplayArtist in a group of DisplayArtists. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __ArtistRole.name() : __ArtistRole
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'DisplayArtist', DisplayArtist)


# Complex type {http://ddex.net/xml/20100712/ddexC}DistributionChannelType with content type SIMPLE
class DistributionChannelType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a DistributionChannelType."""
    _TypeDefinition = _ImportedBinding__ddex.DistributionChannelType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DistributionChannelType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 824, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.DistributionChannelType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_DistributionChannelType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 830, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 830, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the DistributionChannelType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_DistributionChannelType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 835, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 835, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the DistributionChannelType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'DistributionChannelType', DistributionChannelType)


# Complex type {http://ddex.net/xml/20100712/ddexC}DrmPlatformType with content type SIMPLE
class DrmPlatformType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a DrmPlatformType."""
    _TypeDefinition = _ImportedBinding__ddex.DrmPlatformType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DrmPlatformType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 843, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.DrmPlatformType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20100712ddexC_DrmPlatformType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 849, 16)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 849, 16)
    
    Version = property(__Version.value, __Version.set, None, 'The Identifier of the Version of the DrmPlatformType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_DrmPlatformType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 854, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 854, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the DrmPlatformType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_DrmPlatformType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 859, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 859, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the DrmPlatformType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'DrmPlatformType', DrmPlatformType)


# Complex type {http://ddex.net/xml/20100712/ddexC}DSP with content type ELEMENT_ONLY
class DSP (PartyDescriptor):
    """A Composite containing details of a DSP acting as a Licensee in a commercial relationship."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DSP')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 867, 4)
    _ElementMap = PartyDescriptor._ElementMap.copy()
    _AttributeMap = PartyDescriptor._AttributeMap.copy()
    # Base type is PartyDescriptor
    
    # Element TradingName uses Python identifier TradingName
    __TradingName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TradingName'), 'TradingName', '__httpddex_netxml20100712ddexC_DSP_TradingName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 874, 20), )

    
    TradingName = property(__TradingName.value, __TradingName.set, None, 'A Composite containing a TradingName of the DSP.')

    
    # Element URL uses Python identifier URL
    __URL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'URL'), 'URL', '__httpddex_netxml20100712ddexC_DSP_URL', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 879, 20), )

    
    URL = property(__URL.value, __URL.set, None, "A URL for the DSP's web site.")

    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_DSP_TerritoryCode', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 884, 20), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'The Territory from which the DSP operates (represented by an ISO 3166-1 TerritoryCode). This Territory may differ from the one in which SalesTransactions occur.')

    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_DSP_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 890, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 890, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the DSP as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TradingName.name() : __TradingName,
        __URL.name() : __URL,
        __TerritoryCode.name() : __TerritoryCode
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'DSP', DSP)


# Complex type {http://ddex.net/xml/20100712/ddexC}Extent with content type SIMPLE
class Extent (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing an Extent and a UnitOfMeasure."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Extent')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 969, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute UnitOfMeasure uses Python identifier UnitOfMeasure
    __UnitOfMeasure = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UnitOfMeasure'), 'UnitOfMeasure', '__httpddex_netxml20100712ddexC_Extent_UnitOfMeasure', _ImportedBinding__ddex.UnitOfExtent)
    __UnitOfMeasure._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 975, 16)
    __UnitOfMeasure._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 975, 16)
    
    UnitOfMeasure = property(__UnitOfMeasure.value, __UnitOfMeasure.set, None, 'The UnitOfMeasure of the Extent. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __UnitOfMeasure.name() : __UnitOfMeasure
    })
Namespace.addCategoryObject('typeBinding', 'Extent', Extent)


# Complex type {http://ddex.net/xml/20100712/ddexC}ExternalLocationDescriptor with content type SIMPLE
class ExternalLocationDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an ExternalLocationDescriptor."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ExternalLocationDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 983, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute DescriptorSyntax uses Python identifier DescriptorSyntax
    __DescriptorSyntax = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'DescriptorSyntax'), 'DescriptorSyntax', '__httpddex_netxml20100712ddexC_ExternalLocationDescriptor_DescriptorSyntax', _ImportedBinding__ddex.DescriptorSyntax)
    __DescriptorSyntax._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 989, 16)
    __DescriptorSyntax._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 989, 16)
    
    DescriptorSyntax = property(__DescriptorSyntax.value, __DescriptorSyntax.set, None, 'A Type of the Descriptor according to how it is defined syntactically. For example, using a namespace (typically using a DPID) for a proprietary syntax or "URI" for a uniform resource identifier as defined in RFC 1630). This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __DescriptorSyntax.name() : __DescriptorSyntax
    })
Namespace.addCategoryObject('typeBinding', 'ExternalLocationDescriptor', ExternalLocationDescriptor)


# Complex type {http://ddex.net/xml/20100712/ddexC}ExternallyLinkedResourceType with content type SIMPLE
class ExternallyLinkedResourceType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an ExternallyLinkedResourceType."""
    _TypeDefinition = _ImportedBinding__ddex.ExternallyLinkedResourceType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ExternallyLinkedResourceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 997, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ExternallyLinkedResourceType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ExternallyLinkedResourceType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1003, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1003, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ExternallyLinkedResourceType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ExternallyLinkedResourceType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1008, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1008, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ExternallyLinkedResourceType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ExternallyLinkedResourceType', ExternallyLinkedResourceType)


# Complex type {http://ddex.net/xml/20100712/ddexC}FrameRate with content type SIMPLE
class FrameRate (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a FrameRate and a UnitOfMeasure."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'FrameRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1079, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute UnitOfMeasure uses Python identifier UnitOfMeasure
    __UnitOfMeasure = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UnitOfMeasure'), 'UnitOfMeasure', '__httpddex_netxml20100712ddexC_FrameRate_UnitOfMeasure', _ImportedBinding__ddex.UnitOfFrameRate)
    __UnitOfMeasure._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1085, 16)
    __UnitOfMeasure._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1085, 16)
    
    UnitOfMeasure = property(__UnitOfMeasure.value, __UnitOfMeasure.set, None, 'The UnitOfMeasure of the FrameRate. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __UnitOfMeasure.name() : __UnitOfMeasure
    })
Namespace.addCategoryObject('typeBinding', 'FrameRate', FrameRate)


# Complex type {http://ddex.net/xml/20100712/ddexC}GuaranteedAmount with content type SIMPLE
class GuaranteedAmount (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a GuaranteedAmount."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'GuaranteedAmount')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1132, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20100712ddexC_GuaranteedAmount_CurrencyCode', _ImportedBinding__iso4217a.CurrencyCode, required=True)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1138, 16)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1138, 16)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The Currency of the GuaranteedAmount (represented by an ISO 4217 CurrencyCode). This is represented in an XML schema as an XML Attribute.')

    
    # Attribute ReferenceUnit uses Python identifier ReferenceUnit
    __ReferenceUnit = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ReferenceUnit'), 'ReferenceUnit', '__httpddex_netxml20100712ddexC_GuaranteedAmount_ReferenceUnit', _ImportedBinding__ddex.ReferenceUnit, required=True)
    __ReferenceUnit._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1143, 16)
    __ReferenceUnit._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1143, 16)
    
    ReferenceUnit = property(__ReferenceUnit.value, __ReferenceUnit.set, None, 'A unit to which the GuaranteedAmount refers (per Use or for the whole License).')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode,
        __ReferenceUnit.name() : __ReferenceUnit
    })
Namespace.addCategoryObject('typeBinding', 'GuaranteedAmount', GuaranteedAmount)


# Complex type {http://ddex.net/xml/20100712/ddexC}HashSumAlgorithmType with content type SIMPLE
class HashSumAlgorithmType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a HashSumAlgorithmType."""
    _TypeDefinition = _ImportedBinding__ddex.HashSumAlgorithmType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'HashSumAlgorithmType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1168, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.HashSumAlgorithmType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_HashSumAlgorithmType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1174, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1174, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the HashSumAlgorithmType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_HashSumAlgorithmType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1179, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1179, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the HashSumAlgorithmType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'HashSumAlgorithmType', HashSumAlgorithmType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ImageCodecType with content type SIMPLE
class ImageCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an ImageCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.ImageCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ImageCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1290, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ImageCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20100712ddexC_ImageCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1296, 16)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1296, 16)
    
    Version = property(__Version.value, __Version.set, None, 'The Identifier of the Version of the ImageCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ImageCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1301, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1301, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ImageCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ImageCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1306, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1306, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ImageCodecType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ImageCodecType', ImageCodecType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ImageType with content type SIMPLE
class ImageType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an ImageType."""
    _TypeDefinition = _ImportedBinding__ddex.ImageType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ImageType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1380, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ImageType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ImageType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1386, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1386, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ImageType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ImageType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1391, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1391, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ImageType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ImageType', ImageType)


# Complex type {http://ddex.net/xml/20100712/ddexC}IndirectResourceContributor with content type ELEMENT_ONLY
class IndirectResourceContributor (PartyDescriptor):
    """A Composite containing details of the Name, Identifier and role(s) of an indirect Contributor to a Resource."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'IndirectResourceContributor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1399, 4)
    _ElementMap = PartyDescriptor._ElementMap.copy()
    _AttributeMap = PartyDescriptor._AttributeMap.copy()
    # Base type is PartyDescriptor
    
    # Element IndirectResourceContributorRole uses Python identifier IndirectResourceContributorRole
    __IndirectResourceContributorRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributorRole'), 'IndirectResourceContributorRole', '__httpddex_netxml20100712ddexC_IndirectResourceContributor_IndirectResourceContributorRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1406, 20), )

    
    IndirectResourceContributorRole = property(__IndirectResourceContributorRole.value, __IndirectResourceContributorRole.set, None, 'A Composite containing details of a role played by the indirect Contributor.')

    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_IndirectResourceContributor_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1412, 16)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1412, 16)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the indirect ResourceContributor in a group of ResourceContributors that have contributed to a Resource. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __IndirectResourceContributorRole.name() : __IndirectResourceContributorRole
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'IndirectResourceContributor', IndirectResourceContributor)


# Complex type {http://ddex.net/xml/20100712/ddexC}LicenseOrClaimRefusalReason with content type SIMPLE
class LicenseOrClaimRefusalReason (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a LicenseOrClaimRefusalReason."""
    _TypeDefinition = _ImportedBinding__ddex.LicenseOrClaimRefusalReason
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'LicenseOrClaimRefusalReason')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1434, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LicenseOrClaimRefusalReason
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_LicenseOrClaimRefusalReason_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1440, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1440, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the LicenseOrClaimRefusalReason. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_LicenseOrClaimRefusalReason_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1445, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1445, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the LicenseOrClaimRefusalReason. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'LicenseOrClaimRefusalReason', LicenseOrClaimRefusalReason)


# Complex type {http://ddex.net/xml/20100712/ddexC}LinkedReleaseResourceReference with content type SIMPLE
class LinkedReleaseResourceReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a LinkedReleaseResourceReference for a Resource which is linked to a ContentItem."""
    _TypeDefinition = _ImportedBinding__ddex.LocalResourceAnchorReference
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'LinkedReleaseResourceReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1453, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LocalResourceAnchorReference
    
    # Attribute LinkDescription uses Python identifier LinkDescription
    __LinkDescription = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LinkDescription'), 'LinkDescription', '__httpddex_netxml20100712ddexC_LinkedReleaseResourceReference_LinkDescription', pyxb.binding.datatypes.string)
    __LinkDescription._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1459, 16)
    __LinkDescription._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1459, 16)
    
    LinkDescription = property(__LinkDescription.value, __LinkDescription.set, None, 'A Composite containing a Description of the link for the ReleaseResourceReference.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_LinkedReleaseResourceReference_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1464, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1464, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the LinkDescription as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LinkDescription.name() : __LinkDescription,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'LinkedReleaseResourceReference', LinkedReleaseResourceReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}MessageActionType with content type SIMPLE
class MessageActionType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a MessageActionType."""
    _TypeDefinition = _ImportedBinding__ddex.MessageActionType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageActionType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1472, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.MessageActionType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_MessageActionType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1478, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1478, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the MessageActionType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_MessageActionType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1483, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1483, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the MessageActionType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'MessageActionType', MessageActionType)


# Complex type {http://ddex.net/xml/20100712/ddexC}MidiType with content type SIMPLE
class MidiType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a MidiType."""
    _TypeDefinition = _ImportedBinding__ddex.MidiType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MidiType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1839, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.MidiType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_MidiType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1845, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1845, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the MidiType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_MidiType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1850, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1850, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the MidiType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'MidiType', MidiType)


# Complex type {http://ddex.net/xml/20100712/ddexC}MusicalWorkContributor with content type ELEMENT_ONLY
class MusicalWorkContributor (PartyDescriptor):
    """A Composite containing details a MusicalWorkContributor."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkContributor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1915, 4)
    _ElementMap = PartyDescriptor._ElementMap.copy()
    _AttributeMap = PartyDescriptor._AttributeMap.copy()
    # Base type is PartyDescriptor
    
    # Element MusicalWorkContributorRole uses Python identifier MusicalWorkContributorRole
    __MusicalWorkContributorRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributorRole'), 'MusicalWorkContributorRole', '__httpddex_netxml20100712ddexC_MusicalWorkContributor_MusicalWorkContributorRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1922, 20), )

    
    MusicalWorkContributorRole = property(__MusicalWorkContributorRole.value, __MusicalWorkContributorRole.set, None, 'A Composite containing details of a role played by the Contributor in relation to the MusicalWork. Note: This can be used in a DdexMessage in relation to any Work, Performance or Fixation any of which may form the whole or part of the Resource itself. Example: if an "AssociatedPerformer" is shown as a Contributor to a MusicalWork it refers to a performer of a Resource (e.g. a SoundRecording) expressing the MusicalWork.')

    
    # Element SocietyAffiliation uses Python identifier SocietyAffiliation
    __SocietyAffiliation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SocietyAffiliation'), 'SocietyAffiliation', '__httpddex_netxml20100712ddexC_MusicalWorkContributor_SocietyAffiliation', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1927, 20), )

    
    SocietyAffiliation = property(__SocietyAffiliation.value, __SocietyAffiliation.set, None, 'A Composite containing details of a society affiliation for the MusicalWorkContributor.')

    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_MusicalWorkContributor_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1933, 16)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1933, 16)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the MusicalWorkContributor in a group of MusicalWorkContributors that have contributed to a MusicalWork. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __MusicalWorkContributorRole.name() : __MusicalWorkContributorRole,
        __SocietyAffiliation.name() : __SocietyAffiliation
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkContributor', MusicalWorkContributor)


# Complex type {http://ddex.net/xml/20100712/ddexC}MusicalWorkContributorRole with content type SIMPLE
class MusicalWorkContributorRole (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a MusicalWorkContributorRole. Note: This can be used in a DdexMessage in relation to any Work, Performance or Fixation any of which may form the whole or part of the Resource itself. Example: if an "AssociatedPerformer" is shown as a Contributor to a MusicalWork it refers to a performer of a Resource (e.g. a SoundRecording) expressing the MusicalWork."""
    _TypeDefinition = _ImportedBinding__ddex.MusicalWorkContributorRole
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkContributorRole')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1941, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.MusicalWorkContributorRole
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_MusicalWorkContributorRole_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1947, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1947, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the MusicalWorkContributorRole. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_MusicalWorkContributorRole_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1952, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1952, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the MusicalWorkContributorRole. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkContributorRole', MusicalWorkContributorRole)


# Complex type {http://ddex.net/xml/20100712/ddexC}MusicalWorkType with content type SIMPLE
class MusicalWorkType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a MusicalWorkType."""
    _TypeDefinition = _ImportedBinding__ddex.MusicalWorkType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2016, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.MusicalWorkType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_MusicalWorkType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2022, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2022, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the MusicalWorkType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_MusicalWorkType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2027, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2027, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the MusicalWorkType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkType', MusicalWorkType)


# Complex type {http://ddex.net/xml/20100712/ddexC}NumberOfDataMismatchItems with content type SIMPLE
class NumberOfDataMismatchItems (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a NumberOfDataMismatchItems."""
    _TypeDefinition = pyxb.binding.datatypes.integer
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'NumberOfDataMismatchItems')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2049, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.integer
    
    # Attribute DataMismatchStatus uses Python identifier DataMismatchStatus
    __DataMismatchStatus = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'DataMismatchStatus'), 'DataMismatchStatus', '__httpddex_netxml20100712ddexC_NumberOfDataMismatchItems_DataMismatchStatus', _ImportedBinding__ddex.DataMismatchStatus)
    __DataMismatchStatus._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2055, 16)
    __DataMismatchStatus._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2055, 16)
    
    DataMismatchStatus = property(__DataMismatchStatus.value, __DataMismatchStatus.set, None, 'A status of the DataMismatch(es). This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __DataMismatchStatus.name() : __DataMismatchStatus
    })
Namespace.addCategoryObject('typeBinding', 'NumberOfDataMismatchItems', NumberOfDataMismatchItems)


# Complex type {http://ddex.net/xml/20100712/ddexC}OperatingSystemType with content type SIMPLE
class OperatingSystemType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of an OperatingSystemType."""
    _TypeDefinition = _ImportedBinding__ddex.OperatingSystemType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'OperatingSystemType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2095, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.OperatingSystemType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20100712ddexC_OperatingSystemType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2101, 16)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2101, 16)
    
    Version = property(__Version.value, __Version.set, None, 'The Identifier of the Version of the OperatingSystemType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_OperatingSystemType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2106, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2106, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the OperatingSystemType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_OperatingSystemType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2111, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2111, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the OperatingSystemType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'OperatingSystemType', OperatingSystemType)


# Complex type {http://ddex.net/xml/20100712/ddexC}OrderType with content type SIMPLE
class OrderType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a OrderType."""
    _TypeDefinition = _ImportedBinding__ddex.OrderType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'OrderType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2119, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.OrderType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_OrderType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2125, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2125, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the OrderType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_OrderType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2130, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2130, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the OrderType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'OrderType', OrderType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ParentalWarningType with content type SIMPLE
class ParentalWarningType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ParentalWarningType."""
    _TypeDefinition = _ImportedBinding__ddex.ParentalWarningType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ParentalWarningType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2138, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ParentalWarningType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ParentalWarningType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2144, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2144, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ParentalWarningType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ParentalWarningType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2149, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2149, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ParentalWarningType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ParentalWarningType', ParentalWarningType)


# Complex type {http://ddex.net/xml/20100712/ddexC}Price with content type SIMPLE
class Price (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Price."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Price')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2281, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20100712ddexC_Price_CurrencyCode', _ImportedBinding__iso4217a.CurrencyCode, required=True)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2287, 16)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2287, 16)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The Currency of the Price (represented by an ISO 4217 CurrencyCode). This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode
    })
Namespace.addCategoryObject('typeBinding', 'Price', Price)


# Complex type {http://ddex.net/xml/20100712/ddexC}PriceConsumerPaidExcSalesTax with content type SIMPLE
class PriceConsumerPaidExcSalesTax (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a PriceConsumerPaidExcSalesTax."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PriceConsumerPaidExcSalesTax')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2295, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20100712ddexC_PriceConsumerPaidExcSalesTax_CurrencyCode', _ImportedBinding__iso4217a.CurrencyCode)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2301, 16)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2301, 16)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The Currency of the Price (represented by an ISO 4217 CurrencyCode). This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode
    })
Namespace.addCategoryObject('typeBinding', 'PriceConsumerPaidExcSalesTax', PriceConsumerPaidExcSalesTax)


# Complex type {http://ddex.net/xml/20100712/ddexC}PriceRangeType with content type SIMPLE
class PriceRangeType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a PriceRangeType."""
    _TypeDefinition = _ImportedBinding__ddex.PriceRangeType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PriceRangeType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2341, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.PriceRangeType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_PriceRangeType_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2347, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2347, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the PriceRangeType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'PriceRangeType', PriceRangeType)


# Complex type {http://ddex.net/xml/20100712/ddexC}PriceType with content type SIMPLE
class PriceType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a PriceType."""
    _TypeDefinition = _ImportedBinding__ddex.PriceType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PriceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2355, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.PriceType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_PriceType_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2361, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2361, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the PriceType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'PriceType', PriceType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ProductType with content type SIMPLE
class ProductType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ProductType."""
    _TypeDefinition = _ImportedBinding__ddex.ProductType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ProductType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2369, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ProductType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ProductType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2375, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2375, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ProductType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ProductType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2380, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2380, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ProductType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ProductType', ProductType)


# Complex type {http://ddex.net/xml/20100712/ddexC}Purpose with content type SIMPLE
class Purpose (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Purpose."""
    _TypeDefinition = _ImportedBinding__ddex.Purpose
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Purpose')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2416, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.Purpose
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_Purpose_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2422, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2422, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the Purpose. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_Purpose_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2427, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2427, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the Purpose. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'Purpose', Purpose)


# Complex type {http://ddex.net/xml/20100712/ddexC}RatingAgency with content type SIMPLE
class RatingAgency (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a RatingAgency."""
    _TypeDefinition = _ImportedBinding__ddex.RatingAgency
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RatingAgency')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2435, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.RatingAgency
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_RatingAgency_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2441, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2441, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the RatingAgency. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_RatingAgency_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2446, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2446, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the RatingAgency. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'RatingAgency', RatingAgency)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReasonType with content type SIMPLE
class ReasonType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReasonType."""
    _TypeDefinition = _ImportedBinding__ddex.ReasonType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReasonType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2468, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReasonType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ReasonType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2474, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2474, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ReasonType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ReasonType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2479, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2479, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ReasonType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReasonType', ReasonType)


# Complex type {http://ddex.net/xml/20100712/ddexC}RedeliveryReasonType with content type SIMPLE
class RedeliveryReasonType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a RedeliveryReasonType."""
    _TypeDefinition = _ImportedBinding__ddex.RedeliveryReasonType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RedeliveryReasonType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2524, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.RedeliveryReasonType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_RedeliveryReasonType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2530, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2530, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the RedeliveryReasonType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_RedeliveryReasonType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2535, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2535, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the RedeliveryReasonType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'RedeliveryReasonType', RedeliveryReasonType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseAvailabilityStatus with content type SIMPLE
class ReleaseAvailabilityStatus (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReleaseAvailabilityStatus."""
    _TypeDefinition = _ImportedBinding__ddex.ReleaseAvailabilityStatus
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseAvailabilityStatus')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2669, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReleaseAvailabilityStatus
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ReleaseAvailabilityStatus_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2675, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2675, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ReleaseAvailabilityStatus. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ReleaseAvailabilityStatus_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2680, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2680, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ReleaseAvailabilityStatus. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseAvailabilityStatus', ReleaseAvailabilityStatus)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseCollectionReference with content type SIMPLE
class ReleaseCollectionReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReleaseCollectionReference."""
    _TypeDefinition = _ImportedBinding__ddex.LocalCollectionAnchorReference
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseCollectionReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2688, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LocalCollectionAnchorReference
    
    # Attribute ReleaseResourceType uses Python identifier ReleaseResourceType
    __ReleaseResourceType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType'), 'ReleaseResourceType', '__httpddex_netxml20100712ddexC_ReleaseCollectionReference_ReleaseResourceType', _ImportedBinding__ddex.ReleaseResourceType)
    __ReleaseResourceType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2694, 16)
    __ReleaseResourceType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2694, 16)
    
    ReleaseResourceType = property(__ReleaseResourceType.value, __ReleaseResourceType.set, None, 'A Type of Collection in the context of a Release. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __ReleaseResourceType.name() : __ReleaseResourceType
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseCollectionReference', ReleaseCollectionReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseDetailsByTerritory with content type ELEMENT_ONLY
class ReleaseDetailsByTerritory (ReleaseSummaryDetailsByTerritory):
    """A Composite containing details of Descriptors and other attributes of a Release which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2719, 4)
    _ElementMap = ReleaseSummaryDetailsByTerritory._ElementMap.copy()
    _AttributeMap = ReleaseSummaryDetailsByTerritory._AttributeMap.copy()
    # Base type is ReleaseSummaryDetailsByTerritory
    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20100712ddexC_ReleaseDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2726, 20), )

    
    Title = property(__Title.value, __Title.set, None, 'A Composite containing details of a Title of the Release.')

    
    # Element DisplayArtist uses Python identifier DisplayArtist
    __DisplayArtist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), 'DisplayArtist', '__httpddex_netxml20100712ddexC_ReleaseDetailsByTerritory_DisplayArtist', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2731, 20), )

    
    DisplayArtist = property(__DisplayArtist.value, __DisplayArtist.set, None, 'A Composite containing details of the DisplayArtist for the Release. The DisplayArtist may be described through Name, Identifier and Roles.')

    
    # Element IsMultiArtistCompilation uses Python identifier IsMultiArtistCompilation
    __IsMultiArtistCompilation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsMultiArtistCompilation'), 'IsMultiArtistCompilation', '__httpddex_netxml20100712ddexC_ReleaseDetailsByTerritory_IsMultiArtistCompilation', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2736, 20), )

    
    IsMultiArtistCompilation = property(__IsMultiArtistCompilation.value, __IsMultiArtistCompilation.set, None, 'The Flag indicating whether the Release is a multiartist compilation (=True) or not (=False).')

    
    # Element AdministratingRecordCompany uses Python identifier AdministratingRecordCompany
    __AdministratingRecordCompany = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany'), 'AdministratingRecordCompany', '__httpddex_netxml20100712ddexC_ReleaseDetailsByTerritory_AdministratingRecordCompany', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2741, 20), )

    
    AdministratingRecordCompany = property(__AdministratingRecordCompany.value, __AdministratingRecordCompany.set, None, 'A Composite containing details of the AdministratingRecordCompany for the Release.')

    
    # Element ReleaseType uses Python identifier ReleaseType
    __ReleaseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseType'), 'ReleaseType', '__httpddex_netxml20100712ddexC_ReleaseDetailsByTerritory_ReleaseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2746, 20), )

    
    ReleaseType = property(__ReleaseType.value, __ReleaseType.set, None, 'A Composite containing details of the form in which a ReleaseCreator anticipates offering the Release to Consumers. This overrides the ReleaseType specified globally for the Release.')

    
    # Element RelatedRelease uses Python identifier RelatedRelease
    __RelatedRelease = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RelatedRelease'), 'RelatedRelease', '__httpddex_netxml20100712ddexC_ReleaseDetailsByTerritory_RelatedRelease', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2751, 20), )

    
    RelatedRelease = property(__RelatedRelease.value, __RelatedRelease.set, None, 'A Composite containing details of a Release (or a PhysicalProduct or a DigitalProduct derived from such a Release) which is related to this Release.')

    
    # Element TerritoryCode (TerritoryCode) inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummaryDetailsByTerritory
    
    # Element ExcludedTerritoryCode (ExcludedTerritoryCode) inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummaryDetailsByTerritory
    
    # Element DisplayArtistName (DisplayArtistName) inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummaryDetailsByTerritory
    
    # Element LabelName (LabelName) inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummaryDetailsByTerritory
    
    # Element RightsAgreementId (RightsAgreementId) inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummaryDetailsByTerritory
    
    # Attribute LanguageAndScriptCode inherited from {http://ddex.net/xml/20100712/ddexC}ReleaseSummaryDetailsByTerritory
    _ElementMap.update({
        __Title.name() : __Title,
        __DisplayArtist.name() : __DisplayArtist,
        __IsMultiArtistCompilation.name() : __IsMultiArtistCompilation,
        __AdministratingRecordCompany.name() : __AdministratingRecordCompany,
        __ReleaseType.name() : __ReleaseType,
        __RelatedRelease.name() : __RelatedRelease
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseDetailsByTerritory', ReleaseDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseRelationshipType with content type SIMPLE
class ReleaseRelationshipType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReleaseRelationshipType, e.g. between an AudioClipRelease and a VideoClipRelease."""
    _TypeDefinition = _ImportedBinding__ddex.ReleaseRelationshipType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseRelationshipType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2792, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReleaseRelationshipType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ReleaseRelationshipType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2798, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2798, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ReleaseRelationshipType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ReleaseRelationshipType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2803, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2803, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ReleaseRelationshipType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseRelationshipType', ReleaseRelationshipType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseResourceReference with content type SIMPLE
class ReleaseResourceReference (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReleaseResourceReference."""
    _TypeDefinition = _ImportedBinding__ddex.LocalResourceAnchorReference
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseResourceReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2811, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LocalResourceAnchorReference
    
    # Attribute ReleaseResourceType uses Python identifier ReleaseResourceType
    __ReleaseResourceType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType'), 'ReleaseResourceType', '__httpddex_netxml20100712ddexC_ReleaseResourceReference_ReleaseResourceType', _ImportedBinding__ddex.ReleaseResourceType)
    __ReleaseResourceType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2817, 16)
    __ReleaseResourceType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2817, 16)
    
    ReleaseResourceType = property(__ReleaseResourceType.value, __ReleaseResourceType.set, None, 'A Type of Resource in the context of a Release. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __ReleaseResourceType.name() : __ReleaseResourceType
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseResourceReference', ReleaseResourceReference)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReleaseType with content type SIMPLE
class ReleaseType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReleaseType."""
    _TypeDefinition = _ImportedBinding__ddex.ReleaseType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2908, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReleaseType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ReleaseType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2914, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2914, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ReleaseType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ReleaseType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2919, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2919, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ReleaseType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseType', ReleaseType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReportFormat with content type SIMPLE
class ReportFormat (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReportFormat."""
    _TypeDefinition = _ImportedBinding__ddex.ReportFormat
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReportFormat')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2941, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReportFormat
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ReportFormat_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2947, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2947, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ReportFormat. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ReportFormat_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2952, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2952, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ReportFormat. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReportFormat', ReportFormat)


# Complex type {http://ddex.net/xml/20100712/ddexC}ReportType with content type SIMPLE
class ReportType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ReportType."""
    _TypeDefinition = _ImportedBinding__ddex.ReportType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReportType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2960, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReportType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ReportType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2966, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2966, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ReportType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ReportType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2971, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2971, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ReportType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReportType', ReportType)


# Complex type {http://ddex.net/xml/20100712/ddexC}ResourceContributor with content type ELEMENT_ONLY
class ResourceContributor (PartyDescriptor):
    """A Composite containing details of the Name, Identifier and role(s) of a Contributor to a Resource."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceContributor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3018, 4)
    _ElementMap = PartyDescriptor._ElementMap.copy()
    _AttributeMap = PartyDescriptor._AttributeMap.copy()
    # Base type is PartyDescriptor
    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element ResourceContributorRole uses Python identifier ResourceContributorRole
    __ResourceContributorRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributorRole'), 'ResourceContributorRole', '__httpddex_netxml20100712ddexC_ResourceContributor_ResourceContributorRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3025, 20), )

    
    ResourceContributorRole = property(__ResourceContributorRole.value, __ResourceContributorRole.set, None, 'A Composite containing details of a role played by the Contributor.')

    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_ResourceContributor_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3031, 16)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3031, 16)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ResourceContributor in a group of ResourceContributors that have contributed to a Resource. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __ResourceContributorRole.name() : __ResourceContributorRole
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'ResourceContributor', ResourceContributor)


# Complex type {http://ddex.net/xml/20100712/ddexC}ResourceContributorRole with content type SIMPLE
class ResourceContributorRole (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ResourceContributorRole. Note: This can be used in a DdexMessage in relation to any Work, Performance or Fixation any of which may form the whole or part of the Resource itself."""
    _TypeDefinition = _ImportedBinding__ddex.ResourceContributorRole
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceContributorRole')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3039, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ResourceContributorRole
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ResourceContributorRole_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3045, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3045, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ResourceContributorRole. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ResourceContributorRole_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3050, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3050, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ResourceContributorRole. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ResourceContributorRole', ResourceContributorRole)


# Complex type {http://ddex.net/xml/20100712/ddexC}ResourceType with content type SIMPLE
class ResourceType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a ResourceType. For example a SoundRecording of a Performance of a MusicalWork or an Image of an Artist."""
    _TypeDefinition = _ImportedBinding__ddex.ResourceType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3161, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ResourceType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_ResourceType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3167, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3167, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the ResourceType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_ResourceType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3172, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3172, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the ResourceType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ResourceType', ResourceType)


# Complex type {http://ddex.net/xml/20100712/ddexC}RightsController with content type ELEMENT_ONLY
class RightsController (PartyDescriptor):
    """A Composite containing details of a RightsController. RightsControllers are typicallydescribed by Name, Identifier and role(s)."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightsController')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3197, 4)
    _ElementMap = PartyDescriptor._ElementMap.copy()
    _AttributeMap = PartyDescriptor._AttributeMap.copy()
    # Base type is PartyDescriptor
    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}PartyDescriptor
    
    # Element RightsControllerRole uses Python identifier RightsControllerRole
    __RightsControllerRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsControllerRole'), 'RightsControllerRole', '__httpddex_netxml20100712ddexC_RightsController_RightsControllerRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3204, 20), )

    
    RightsControllerRole = property(__RightsControllerRole.value, __RightsControllerRole.set, None, 'A role that describes the Party involved in the administration of Rights.')

    
    # Element RightShareUnknown uses Python identifier RightShareUnknown
    __RightShareUnknown = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareUnknown'), 'RightShareUnknown', '__httpddex_netxml20100712ddexC_RightsController_RightShareUnknown', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3210, 24), )

    
    RightShareUnknown = property(__RightShareUnknown.value, __RightShareUnknown.set, None, 'The Flag indicating whether the RightSharePercentage is unknown (=True) or not (=False).')

    
    # Element RightSharePercentage uses Python identifier RightSharePercentage
    __RightSharePercentage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightSharePercentage'), 'RightSharePercentage', '__httpddex_netxml20100712ddexC_RightsController_RightSharePercentage', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3215, 24), )

    
    RightSharePercentage = property(__RightSharePercentage.value, __RightSharePercentage.set, None, 'The share of the licensed Rights owned by the RightsController. RightShare information is given as a decimal value (e.g. "0.125" represents 12.5%). If no information is given, 100% is assumed.')

    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_RightsController_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3222, 16)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3222, 16)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the RightsController in a group of RightsControllers. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __RightsControllerRole.name() : __RightsControllerRole,
        __RightShareUnknown.name() : __RightShareUnknown,
        __RightSharePercentage.name() : __RightSharePercentage
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'RightsController', RightsController)


# Complex type {http://ddex.net/xml/20100712/ddexC}RoyaltyAmount with content type SIMPLE
class RoyaltyAmount (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a RoyaltyAmount."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RoyaltyAmount')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3387, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20100712ddexC_RoyaltyAmount_CurrencyCode', _ImportedBinding__iso4217a.CurrencyCode, required=True)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3393, 16)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3393, 16)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The Currency of the RoyaltyAmount (represented by an ISO 4217 CurrencyCode). This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode
    })
Namespace.addCategoryObject('typeBinding', 'RoyaltyAmount', RoyaltyAmount)


# Complex type {http://ddex.net/xml/20100712/ddexC}SamplingRate with content type SIMPLE
class SamplingRate (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing a SamplingRate and a UnitOfMeasure."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SamplingRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3437, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute UnitOfMeasure uses Python identifier UnitOfMeasure
    __UnitOfMeasure = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UnitOfMeasure'), 'UnitOfMeasure', '__httpddex_netxml20100712ddexC_SamplingRate_UnitOfMeasure', _ImportedBinding__ddex.UnitOfFrequency)
    __UnitOfMeasure._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3443, 16)
    __UnitOfMeasure._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3443, 16)
    
    UnitOfMeasure = property(__UnitOfMeasure.value, __UnitOfMeasure.set, None, 'The UnitOfMeasure of the SamplingRate. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __UnitOfMeasure.name() : __UnitOfMeasure
    })
Namespace.addCategoryObject('typeBinding', 'SamplingRate', SamplingRate)


# Complex type {http://ddex.net/xml/20100712/ddexC}SheetMusicCodecType with content type SIMPLE
class SheetMusicCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SheetMusicCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.SheetMusicCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SheetMusicCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3523, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SheetMusicCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20100712ddexC_SheetMusicCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3529, 16)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3529, 16)
    
    Version = property(__Version.value, __Version.set, None, 'The Identifier of the Version of the SheetMusicCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_SheetMusicCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3534, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3534, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the SheetMusicCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_SheetMusicCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3539, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3539, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the SheetMusicCodecType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SheetMusicCodecType', SheetMusicCodecType)


# Complex type {http://ddex.net/xml/20100712/ddexC}SheetMusicType with content type SIMPLE
class SheetMusicType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SheetMusicType."""
    _TypeDefinition = _ImportedBinding__ddex.SheetMusicType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SheetMusicType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3618, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SheetMusicType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_SheetMusicType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3624, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3624, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the SheetMusicType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_SheetMusicType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3629, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3629, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the SheetMusicType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SheetMusicType', SheetMusicType)


# Complex type {http://ddex.net/xml/20100712/ddexC}SimpleProfileDisplayArtist with content type ELEMENT_ONLY
class SimpleProfileDisplayArtist (SimpleProfilePartyDescriptor):
    """A Composite containing details of a DisplayArtist. A DisplayArtist may be described through Name, Identifier and Roles."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SimpleProfileDisplayArtist')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3637, 4)
    _ElementMap = SimpleProfilePartyDescriptor._ElementMap.copy()
    _AttributeMap = SimpleProfilePartyDescriptor._AttributeMap.copy()
    # Base type is SimpleProfilePartyDescriptor
    
    # Element ArtistRole uses Python identifier ArtistRole
    __ArtistRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ArtistRole'), 'ArtistRole', '__httpddex_netxml20100712ddexC_SimpleProfileDisplayArtist_ArtistRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3644, 20), )

    
    ArtistRole = property(__ArtistRole.value, __ArtistRole.set, None, 'A Composite containing details of a role played by the DisplayArtist in relation to other DisplayArtists.')

    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}SimpleProfilePartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}SimpleProfilePartyDescriptor
    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_SimpleProfileDisplayArtist_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3650, 16)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3650, 16)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the DisplayArtist in a group of DisplayArtists. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __ArtistRole.name() : __ArtistRole
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'SimpleProfileDisplayArtist', SimpleProfileDisplayArtist)


# Complex type {http://ddex.net/xml/20100712/ddexC}SimpleProfileResourceContributor with content type ELEMENT_ONLY
class SimpleProfileResourceContributor (SimpleProfilePartyDescriptor):
    """A Composite containing details of the Name, Identifier and role(s) of a Contributor to a Resource."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SimpleProfileResourceContributor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3773, 4)
    _ElementMap = SimpleProfilePartyDescriptor._ElementMap.copy()
    _AttributeMap = SimpleProfilePartyDescriptor._AttributeMap.copy()
    # Base type is SimpleProfilePartyDescriptor
    
    # Element PartyId (PartyId) inherited from {http://ddex.net/xml/20100712/ddexC}SimpleProfilePartyDescriptor
    
    # Element PartyName (PartyName) inherited from {http://ddex.net/xml/20100712/ddexC}SimpleProfilePartyDescriptor
    
    # Element ResourceContributorRole uses Python identifier ResourceContributorRole
    __ResourceContributorRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributorRole'), 'ResourceContributorRole', '__httpddex_netxml20100712ddexC_SimpleProfileResourceContributor_ResourceContributorRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3780, 20), )

    
    ResourceContributorRole = property(__ResourceContributorRole.value, __ResourceContributorRole.set, None, 'A Composite containing details of a role played by the Contributor.')

    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20100712ddexC_SimpleProfileResourceContributor_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3786, 16)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3786, 16)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ResourceContributor in a group of ResourceContributors that have contributed to a Resource. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __ResourceContributorRole.name() : __ResourceContributorRole
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'SimpleProfileResourceContributor', SimpleProfileResourceContributor)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoftwareType with content type SIMPLE
class SoftwareType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SoftwareType."""
    _TypeDefinition = _ImportedBinding__ddex.SoftwareType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoftwareType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3946, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SoftwareType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_SoftwareType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3952, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3952, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the SoftwareType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_SoftwareType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3957, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3957, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the SoftwareType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SoftwareType', SoftwareType)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoundProcessorType with content type SIMPLE
class SoundProcessorType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SoundProcessorType."""
    _TypeDefinition = _ImportedBinding__ddex.SoundProcessorType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundProcessorType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3965, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SoundProcessorType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20100712ddexC_SoundProcessorType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3971, 16)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3971, 16)
    
    Version = property(__Version.value, __Version.set, None, 'The Identifier of the Version of the SoundProcessorType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_SoundProcessorType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3976, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3976, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the SoundProcessorType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_SoundProcessorType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3981, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3981, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the SoundProcessorType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SoundProcessorType', SoundProcessorType)


# Complex type {http://ddex.net/xml/20100712/ddexC}SoundRecordingType with content type SIMPLE
class SoundRecordingType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SoundRecordingType."""
    _TypeDefinition = _ImportedBinding__ddex.SoundRecordingType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4261, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SoundRecordingType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_SoundRecordingType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4267, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4267, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the SoundRecordingType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_SoundRecordingType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4272, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4272, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the SoundRecordingType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingType', SoundRecordingType)


# Complex type {http://ddex.net/xml/20100712/ddexC}SupplyChainStatus with content type SIMPLE
class SupplyChainStatus (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a SupplyChainStatus."""
    _TypeDefinition = _ImportedBinding__ddex.SupplyChainStatus
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SupplyChainStatus')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4308, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SupplyChainStatus
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_SupplyChainStatus_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4314, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4314, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the SupplyChainStatus. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_SupplyChainStatus_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4319, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4319, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the SupplyChainStatus. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SupplyChainStatus', SupplyChainStatus)


# Complex type {http://ddex.net/xml/20100712/ddexC}Tax with content type SIMPLE
class Tax (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Tax."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Tax')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4360, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20100712ddexC_Tax_CurrencyCode', _ImportedBinding__iso4217a.CurrencyCode, required=True)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4366, 16)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4366, 16)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The Currency of the Tax (represented by an ISO 4217 CurrencyCode). This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode
    })
Namespace.addCategoryObject('typeBinding', 'Tax', Tax)


# Complex type {http://ddex.net/xml/20100712/ddexC}TaxScope with content type SIMPLE
class TaxScope (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a TaxScope."""
    _TypeDefinition = _ImportedBinding__ddex.TaxScope
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TaxScope')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4396, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.TaxScope
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_TaxScope_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4402, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4402, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the TaxScope. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_TaxScope_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4407, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4407, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the TaxScope. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'TaxScope', TaxScope)


# Complex type {http://ddex.net/xml/20100712/ddexC}TaxType with content type SIMPLE
class TaxType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a TaxType."""
    _TypeDefinition = _ImportedBinding__ddex.TaxType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TaxType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4415, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.TaxType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_TaxType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4421, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4421, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the TaxType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_TaxType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4426, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4426, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the TaxType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'TaxType', TaxType)


# Complex type {http://ddex.net/xml/20100712/ddexC}TextCodecType with content type SIMPLE
class TextCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a TextCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.TextCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TextCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4529, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.TextCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20100712ddexC_TextCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4535, 16)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4535, 16)
    
    Version = property(__Version.value, __Version.set, None, 'The Identifier of the Version of the TextCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_TextCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4540, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4540, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the TextCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_TextCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4545, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4545, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the TextCodecType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'TextCodecType', TextCodecType)


# Complex type {http://ddex.net/xml/20100712/ddexC}TextType with content type SIMPLE
class TextType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a TextType."""
    _TypeDefinition = _ImportedBinding__ddex.TextType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TextType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4629, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.TextType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_TextType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4635, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4635, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the TextType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_TextType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4640, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4640, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the TextType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'TextType', TextType)


# Complex type {http://ddex.net/xml/20100712/ddexC}Title with content type ELEMENT_ONLY
class Title (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a Title."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Title')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4648, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TitleText uses Python identifier TitleText
    __TitleText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TitleText'), 'TitleText', '__httpddex_netxml20100712ddexC_Title_TitleText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4653, 12), )

    
    TitleText = property(__TitleText.value, __TitleText.set, None, 'A Composite containing the text of the Title.')

    
    # Element SubTitle uses Python identifier SubTitle
    __SubTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SubTitle'), 'SubTitle', '__httpddex_netxml20100712ddexC_Title_SubTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4658, 12), )

    
    SubTitle = property(__SubTitle.value, __SubTitle.set, None, 'A Composite containing details of a SubTitle of the Title, including Titles of Versions used to differentiate different versions of the same Title, as required by the GRId and ISRC ReferenceDescriptiveMetadataSets.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_Title_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4664, 8)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4664, 8)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the Elements of the Title as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute TitleType uses Python identifier TitleType
    __TitleType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'TitleType'), 'TitleType', '__httpddex_netxml20100712ddexC_Title_TitleType', _ImportedBinding__ddex.TitleType)
    __TitleType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4669, 8)
    __TitleType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4669, 8)
    
    TitleType = property(__TitleType.value, __TitleType.set, None, 'A Type of the Title which defines its origin or the function it fulfils in relation to a Creation. Note: A Title may fulfil more than one role. Example: "Help" may be both the OriginalTitle and the DisplayTitle for the well-known Beatles song. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        __TitleText.name() : __TitleText,
        __SubTitle.name() : __SubTitle
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode,
        __TitleType.name() : __TitleType
    })
Namespace.addCategoryObject('typeBinding', 'Title', Title)


# Complex type {http://ddex.net/xml/20100712/ddexC}UserInterfaceType with content type SIMPLE
class UserInterfaceType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a UserInterfaceType."""
    _TypeDefinition = _ImportedBinding__ddex.UserInterfaceType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserInterfaceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4914, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.UserInterfaceType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_UserInterfaceType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4920, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4920, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the UserInterfaceType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_UserInterfaceType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4925, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4925, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the UserInterfaceType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'UserInterfaceType', UserInterfaceType)


# Complex type {http://ddex.net/xml/20100712/ddexC}UseType with content type SIMPLE
class UseType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a UseType."""
    _TypeDefinition = _ImportedBinding__ddex.UseType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UseType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4933, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.UseType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_UseType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4939, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4939, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the UseType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_UseType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4944, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4944, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the UseType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'UseType', UseType)


# Complex type {http://ddex.net/xml/20100712/ddexC}VideoCodecType with content type SIMPLE
class VideoCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a VideoCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.VideoCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5074, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.VideoCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20100712ddexC_VideoCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5080, 16)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5080, 16)
    
    Version = property(__Version.value, __Version.set, None, 'The Identifier of the Version of the VideoCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_VideoCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5085, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5085, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the VideoCodecType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_VideoCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5090, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5090, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the VideoCodecType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'VideoCodecType', VideoCodecType)


# Complex type {http://ddex.net/xml/20100712/ddexC}VideoDetailsByTerritory with content type ELEMENT_ONLY
class VideoDetailsByTerritory (SoundRecordingDetailsByTerritory):
    """A Composite containing details of Descriptors and other attributes of a Video which may vary according to Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5110, 4)
    _ElementMap = SoundRecordingDetailsByTerritory._ElementMap.copy()
    _AttributeMap = SoundRecordingDetailsByTerritory._AttributeMap.copy()
    # Base type is SoundRecordingDetailsByTerritory
    
    # Element TerritoryCode (TerritoryCode) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element ExcludedTerritoryCode (ExcludedTerritoryCode) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element Title (Title) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element DisplayArtist (DisplayArtist) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element ResourceContributor (ResourceContributor) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element IndirectResourceContributor (IndirectResourceContributor) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element RightsAgreementId (RightsAgreementId) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element LabelName (LabelName) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element RightsController (RightsController) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element RemasteredDate (RemasteredDate) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element OriginalResourceReleaseDate (OriginalResourceReleaseDate) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element PLine (PLine) inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20100712ddexC_VideoDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5117, 20), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A Composite containing details of the CLine for the Video.')

    
    # Attribute LanguageAndScriptCode inherited from {http://ddex.net/xml/20100712/ddexC}SoundRecordingDetailsByTerritory
    _ElementMap.update({
        __CLine.name() : __CLine
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'VideoDetailsByTerritory', VideoDetailsByTerritory)


# Complex type {http://ddex.net/xml/20100712/ddexC}VideoType with content type SIMPLE
class VideoType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a VideoType."""
    _TypeDefinition = _ImportedBinding__ddex.VideoType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5158, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.VideoType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_VideoType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5164, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5164, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the VideoType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_VideoType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5169, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5169, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the VideoType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'VideoType', VideoType)


# Complex type {http://ddex.net/xml/20100712/ddexC}WsMessageStatus with content type SIMPLE
class WsMessageStatus (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a WsMessageStatus."""
    _TypeDefinition = _ImportedBinding__ddex.WsMessageStatus
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'WsMessageStatus')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5221, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.WsMessageStatus
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_WsMessageStatus_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5227, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5227, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the WsMessageStatus. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_WsMessageStatus_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5232, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5232, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the WsMessageStatus. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'WsMessageStatus', WsMessageStatus)


# Complex type {http://ddex.net/xml/20100712/ddexC}EventDate with content type SIMPLE
class EventDate (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of the Date and Place of an Event."""
    _TypeDefinition = pyxb.binding.datatypes.date
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'EventDate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 930, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.date
    
    # Attribute IsApproximate uses Python identifier IsApproximate
    __IsApproximate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsApproximate'), 'IsApproximate', '__httpddex_netxml20100712ddexC_EventDate_IsApproximate', pyxb.binding.datatypes.boolean)
    __IsApproximate._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 936, 16)
    __IsApproximate._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 936, 16)
    
    IsApproximate = property(__IsApproximate.value, __IsApproximate.set, None, 'The Flag indicating whether the reported Date is approximate (=True) or exact (=False). This is represented in an XML schema as an XML Attribute.')

    
    # Attribute IsBefore uses Python identifier IsBefore
    __IsBefore = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsBefore'), 'IsBefore', '__httpddex_netxml20100712ddexC_EventDate_IsBefore', pyxb.binding.datatypes.boolean)
    __IsBefore._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 941, 16)
    __IsBefore._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 941, 16)
    
    IsBefore = property(__IsBefore.value, __IsBefore.set, None, 'The Flag indicating whether the Event being described occurred sometime before the reported Date (=True) or not (=False). This is represented in an XML schema as an XML Attribute.')

    
    # Attribute IsAfter uses Python identifier IsAfter
    __IsAfter = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsAfter'), 'IsAfter', '__httpddex_netxml20100712ddexC_EventDate_IsAfter', pyxb.binding.datatypes.boolean)
    __IsAfter._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 946, 16)
    __IsAfter._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 946, 16)
    
    IsAfter = property(__IsAfter.value, __IsAfter.set, None, 'The Flag indicating whether the Event being described occurred sometime after the reported Date (=True) or not (=False). This is represented in an XML schema as an XML Attribute.')

    
    # Attribute TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_EventDate_TerritoryCode', TerritoryCode)
    __TerritoryCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 951, 16)
    __TerritoryCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 951, 16)
    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'The Territory in which the Event occurred (represented by an ISO 3166-1 TerritoryCode). This is represented in an XML schema as an XML Attribute.')

    
    # Attribute LocationDescription uses Python identifier LocationDescription
    __LocationDescription = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LocationDescription'), 'LocationDescription', '__httpddex_netxml20100712ddexC_EventDate_LocationDescription', pyxb.binding.datatypes.string)
    __LocationDescription._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 956, 16)
    __LocationDescription._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 956, 16)
    
    LocationDescription = property(__LocationDescription.value, __LocationDescription.set, None, 'A Description of the location in which the Event occurred. It offers the opportunity to describe a place more precisely than using the TerritoryCode. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20100712ddexC_EventDate_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 961, 16)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 961, 16)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The Language and script for the LocationDescription as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __IsApproximate.name() : __IsApproximate,
        __IsBefore.name() : __IsBefore,
        __IsAfter.name() : __IsAfter,
        __TerritoryCode.name() : __TerritoryCode,
        __LocationDescription.name() : __LocationDescription,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'EventDate', EventDate)


# Complex type {http://ddex.net/xml/20100712/ddexC}RightsType with content type SIMPLE
class RightsType (pyxb.binding.basis.complexTypeDefinition):
    """A Composite containing details of a RightsType."""
    _TypeDefinition = _ImportedBinding__ddex.RightsCoverage
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightsType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3363, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.RightsCoverage
    
    # Attribute TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20100712ddexC_RightsType_TerritoryCode', TerritoryCode, required=True)
    __TerritoryCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3369, 16)
    __TerritoryCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3369, 16)
    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A Territory to which the RightsType applies (represented by an ISO 3166-1 TerritoryCode). The RightsType is defined according to the jurisdiction of this Territory.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20100712ddexC_RightsType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3374, 16)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3374, 16)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The Namespace of the RightsType. This is represented in an XML schema as an XML Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20100712ddexC_RightsType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3379, 16)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3379, 16)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A UserDefined value of the RightsType. This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'RightsType', RightsType)




AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Amount'), pyxb.binding.datatypes.decimal, scope=AmountByUseAndDistributionChannelType, documentation='The Amount specified for the UseType and the DistributionChannelType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 43, 12)))

AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=AmountByUseAndDistributionChannelType, documentation='A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 48, 12)))

AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=AmountByUseAndDistributionChannelType, documentation='A Composite containing details of a physical interface by which a Consumer uses a Service or Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 53, 12)))

AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=AmountByUseAndDistributionChannelType, documentation='A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 58, 12)))

AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=AmountByUseAndDistributionChannelType, documentation='A Composite containing details of a Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 63, 12)))

def _BuildAutomaton ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton
    del _BuildAutomaton
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 53, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 58, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 63, 12))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'Amount')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 43, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 48, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 53, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 58, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 63, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AmountByUseAndDistributionChannelType._Automaton = _BuildAutomaton()




AmountPerCollection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Amount'), pyxb.binding.datatypes.decimal, scope=AmountPerCollection, documentation='The Amount specified for the CollectionType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 75, 12)))

AmountPerCollection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionType'), CollectionType, scope=AmountPerCollection, documentation='A Composite containing details of the Type of the Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 80, 12)))

def _BuildAutomaton_ ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_
    del _BuildAutomaton_
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AmountPerCollection._UseForTag(pyxb.namespace.ExpandedName(None, 'Amount')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 75, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AmountPerCollection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 80, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AmountPerCollection._Automaton = _BuildAutomaton_()




AvRating._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RatingText'), pyxb.binding.datatypes.string, scope=AvRating, documentation='The text of the AvRating.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 178, 12)))

AvRating._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RatingAgency'), RatingAgency, scope=AvRating, documentation='A Composite containing details of an Organization that issues the AvRating.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 183, 12)))

def _BuildAutomaton_2 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_2
    del _BuildAutomaton_2
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AvRating._UseForTag(pyxb.namespace.ExpandedName(None, 'RatingText')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 178, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AvRating._UseForTag(pyxb.namespace.ExpandedName(None, 'RatingAgency')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 183, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AvRating._Automaton = _BuildAutomaton_2()




CLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Year'), pyxb.binding.datatypes.gYear, scope=CLine, documentation='The Year of the CLine.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 277, 12)))

CLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLineText'), pyxb.binding.datatypes.string, scope=CLine, documentation='The text of the CLine.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 282, 12)))

def _BuildAutomaton_3 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_3
    del _BuildAutomaton_3
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CLine._UseForTag(pyxb.namespace.ExpandedName(None, 'Year')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 277, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CLine._UseForTag(pyxb.namespace.ExpandedName(None, 'CLineText')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 282, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CLine._Automaton = _BuildAutomaton_3()




Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionId'), CollectionId, scope=Collection, documentation='A Composite containing details of an Identifier of the Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 299, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionType'), CollectionType, scope=Collection, documentation='A Composite containing details of the Type of the Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 304, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionReference'), _ImportedBinding__ddex.LocalCollectionAnchor, scope=Collection, documentation='The Identifier (specific to the Message) of the Collection within the Release which contains it. This LocalAnchor is a string starting with the letter X.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 309, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=Collection, documentation='A Composite containing details of a Title of the Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 314, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Contributor'), ResourceContributor, scope=Collection, documentation='A Composite containing details a Contributor to the Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 319, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReferenceList'), CollectionCollectionReferenceList, scope=Collection, documentation='A Composite containing a list of CollectionCollectionReferences for a Collection (specific to this Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 324, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsComplete'), pyxb.binding.datatypes.boolean, scope=Collection, documentation='The Flag indicating whether the Collection is complete (=True) or not (=False). Only one of the Elements IsComplete here and in the CollectionDetailsByTerritory is valid for a given Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 329, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DurationOfMusicalContent'), pyxb.binding.datatypes.duration, scope=Collection, documentation='The Duration of the musical content (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 334, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CreationDate'), EventDate, scope=Collection, documentation='A Composite containing details of the Date and Place of the Event in which the Collection was created.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 339, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate'), EventDate, scope=Collection, documentation='A Composite containing details of the Date and Place of the Event in which the Collection was or will be first made available for Usage, whether for physical or electronic/online distribution (in ISO 8601:2004 format: YYYY-MM-DD).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 344, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalLanguage'), _ImportedBinding__iso639a2.LanguageCode, scope=Collection, documentation='The orignal Language of the Collection (represented by an ISO 639-2 LanguageCode).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 349, 12)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionDetailsByTerritory'), CollectionDetailsByTerritory, scope=Collection, documentation='A Composite containing details of Descriptors and other attributes of the Collection which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 354, 12)))

def _BuildAutomaton_4 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_4
    del _BuildAutomaton_4
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 304, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 314, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 319, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 324, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 334, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 339, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 344, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 349, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 354, 12))
    counters.add(cc_8)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 299, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 304, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 309, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 314, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'Contributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 319, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 324, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'IsComplete')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 329, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'DurationOfMusicalContent')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 334, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CreationDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 339, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 344, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalLanguage')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 349, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 354, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Collection._Automaton = _BuildAutomaton_4()




CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), pyxb.binding.datatypes.integer, scope=CollectionCollectionReference, documentation='The number indicating the order of the Collection in a group of Collections within a Medley, SoundRecording or other Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 371, 12)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference'), _ImportedBinding__ddex.LocalCollectionAnchorReference, scope=CollectionCollectionReference, documentation='A Reference for a Collection (specific to this Message). This LocalAnchorReference is a string starting with the letter X. The referenced Collection has to be of CollectionType Series, Season or Episode.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 376, 12)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartTime'), pyxb.binding.datatypes.duration, scope=CollectionCollectionReference, documentation='The start time of the Creation, measured from the start of the Resource from which the CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 381, 12)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=CollectionCollectionReference, documentation='The Duration of the use of the Creation that is referenced in the CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 386, 12)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndTime'), pyxb.binding.datatypes.duration, scope=CollectionCollectionReference, documentation='The end time of the Creation, measured from the start of the Resource from which the CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 391, 12)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'InclusionDate'), pyxb.binding.datatypes.dateTime, scope=CollectionCollectionReference, documentation='A Date on which the Collection or Resource was included in the parent Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 396, 12)))

def _BuildAutomaton_5 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_5
    del _BuildAutomaton_5
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 371, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 381, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 386, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 391, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 396, 12))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'SequenceNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 371, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 376, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'StartTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 381, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 386, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'EndTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 391, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'InclusionDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 396, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CollectionCollectionReference._Automaton = _BuildAutomaton_5()




CollectionCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), pyxb.binding.datatypes.integer, scope=CollectionCollectionReferenceList, documentation='The number of referenced Collections (typically Chapters).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 408, 12)))

CollectionCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference'), CollectionCollectionReference, scope=CollectionCollectionReferenceList, documentation='A Composite containing a CollectionCollectionReference for a Collection (specific to this Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 413, 12)))

def _BuildAutomaton_6 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_6
    del _BuildAutomaton_6
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 408, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'NumberOfCollections')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 408, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 413, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CollectionCollectionReferenceList._Automaton = _BuildAutomaton_6()




CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=CollectionDetailsByTerritory, documentation='A Territory to which the Collection details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 426, 16)))

CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=CollectionDetailsByTerritory, documentation='A Territory to which the Collection details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 431, 16)))

CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=CollectionDetailsByTerritory, documentation='A Composite containing details of a Title of the Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 437, 12)))

CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Contributor'), ResourceContributor, scope=CollectionDetailsByTerritory, documentation='A Composite containing details of a Contributor to the Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 442, 12)))

CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsComplete'), pyxb.binding.datatypes.boolean, scope=CollectionDetailsByTerritory, documentation='The Flag indicating whether the Collection is complete (=True) or not (=False). Only one of the Elements IsComplete here and in the Collection is valid for a given Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 447, 12)))

def _BuildAutomaton_7 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_7
    del _BuildAutomaton_7
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 437, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 442, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 447, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 426, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 431, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 437, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Contributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 442, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IsComplete')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 447, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CollectionDetailsByTerritory._Automaton = _BuildAutomaton_7()




CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'GRid'), pyxb.binding.datatypes.string, scope=CollectionId, documentation='The GRid identifying the Collection. This is the preferred Element and is mandatory if a GRid is available. A GRid comprises four parts: the string "A1", followed by five alphanumeric characters, ten alphanumeric characters and and one alphanumeric character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 459, 12)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=CollectionId, documentation='The ISRC (International Standard Recording Code as defined in ISO 3901) for the Collection. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 464, 12)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISAN'), pyxb.binding.datatypes.string, scope=CollectionId, documentation='The ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the Collection. An ISAN comprises four blocks of four hexadecimal charaters followed by a check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 469, 12)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VISAN'), pyxb.binding.datatypes.string, scope=CollectionId, documentation='The V-ISAN (Version Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the Collection. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 474, 12)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ICPN'), ICPN, scope=CollectionId, documentation='A Composite containing details of the ICPN used as proxy for identification of the Collection. Only applicable when the Collection is an abstraction of a complete PhysicalProduct. An ICPN comprises 12 or 13 digits, depending whether it is an EAN (13) or a UPC (12).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 479, 12)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=CollectionId, documentation='A Composite containing details of the CatalogNumber of the Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 484, 12)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=CollectionId, documentation='A Composite containing details of a ProprietaryIdentifier of the Collection (usually one per society involved in the messaging).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 489, 12)))

def _BuildAutomaton_8 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_8
    del _BuildAutomaton_8
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 459, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 464, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 469, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 474, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 479, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 484, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 489, 12))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'GRid')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 459, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 464, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 469, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'VISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 474, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'ICPN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 479, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 484, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 489, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CollectionId._Automaton = _BuildAutomaton_8()




CollectionResourceReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionResourceReference'), _ImportedBinding__ddex.LocalResourceAnchorReference, scope=CollectionResourceReferenceList, documentation='A Reference for a Resource (specific to this Message). This LocalAnchorReference is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 501, 12)))

def _BuildAutomaton_9 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_9
    del _BuildAutomaton_9
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionResourceReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 501, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CollectionResourceReferenceList._Automaton = _BuildAutomaton_9()




CueCreationReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueWorkReference'), _ImportedBinding__ddex.LocalMusicalWorkAnchorReference, scope=CueCreationReference, documentation='A Reference for a Work (specific to this Message). This LocalAnchorReference is a string starting with the letter W.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 610, 16)))

CueCreationReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueResourceReference'), _ImportedBinding__ddex.LocalResourceAnchorReference, scope=CueCreationReference, documentation='A Reference for a Resource (specific to this Message). This LocalAnchorReference is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 615, 16)))

def _BuildAutomaton_10 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_10
    del _BuildAutomaton_10
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CueCreationReference._UseForTag(pyxb.namespace.ExpandedName(None, 'CueWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 610, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CueCreationReference._UseForTag(pyxb.namespace.ExpandedName(None, 'CueResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 615, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CueCreationReference._Automaton = _BuildAutomaton_10()




DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=DurationByUseType, documentation='The Duration specified for the UseType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 903, 12)))

DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=DurationByUseType, documentation='A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 908, 12)))

DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=DurationByUseType, documentation='A Composite containing details of a physical interface by which a Consumer uses a Service or Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 913, 12)))

DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=DurationByUseType, documentation='A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 918, 12)))

DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=DurationByUseType, documentation='A Composite containing details of a Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 923, 12)))

def _BuildAutomaton_11 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_11
    del _BuildAutomaton_11
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 913, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 918, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 923, 12))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 903, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 908, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 913, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 918, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 923, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
DurationByUseType._Automaton = _BuildAutomaton_11()




ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'URL'), pyxb.binding.datatypes.string, scope=ExternalResourceLink, documentation='A URL of the linked external Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1021, 12)))

ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ValidityPeriod'), Period, scope=ExternalResourceLink, documentation='A Composite containing details about the Period of Time during which the ExternalResourceLink is active.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1026, 12)))

ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExternalLink'), pyxb.binding.datatypes.string, scope=ExternalResourceLink, documentation='The Identifier which provides a communication link to the related external Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1031, 12)))

ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExternallyLinkedResourceType'), ExternallyLinkedResourceType, scope=ExternalResourceLink, documentation='A Composite containing details of the Type of a Resource pointed to by the ExternalResourceLink.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1036, 12)))

ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FileFormat'), pyxb.binding.datatypes.string, scope=ExternalResourceLink, documentation='The FileFormat of the external Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1041, 12)))

def _BuildAutomaton_12 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_12
    del _BuildAutomaton_12
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1026, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1031, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1036, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1041, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'URL')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1021, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'ValidityPeriod')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1026, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'ExternalLink')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1031, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'ExternallyLinkedResourceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1036, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'FileFormat')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1041, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ExternalResourceLink._Automaton = _BuildAutomaton_12()




File._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FileName'), pyxb.binding.datatypes.string, scope=File, documentation='A Name of the File.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1055, 20)))

File._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FilePath'), pyxb.binding.datatypes.string, scope=File, documentation='A location of the File.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1060, 20)))

File._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'URL'), pyxb.binding.datatypes.string, scope=File, documentation='A URL of the File.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1066, 16)))

File._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HashSum'), HashSum, scope=File, documentation='A Composite containing a HashSum of the File and information about the algorithm with which it has been generated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1072, 12)))

def _BuildAutomaton_13 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_13
    del _BuildAutomaton_13
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1060, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1072, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(File._UseForTag(pyxb.namespace.ExpandedName(None, 'FileName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1055, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(File._UseForTag(pyxb.namespace.ExpandedName(None, 'FilePath')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1060, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(File._UseForTag(pyxb.namespace.ExpandedName(None, 'URL')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1066, 16))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(File._UseForTag(pyxb.namespace.ExpandedName(None, 'HashSum')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1072, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
File._Automaton = _BuildAutomaton_13()




FulfillmentDate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FulfillmentDate'), pyxb.binding.datatypes.date, scope=FulfillmentDate, documentation='A Date after which an end user can receive the Resource (in ISO 8601:2004 format: YYYY-MM-DD). If no FulfillmentDate is provided the FulfillmentDate is the StartDate of the respective Deal.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1098, 12)))

FulfillmentDate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReleaseReference'), _ImportedBinding__ddex.LocalReleaseAnchorReference, scope=FulfillmentDate, documentation='The Identifier (specific to the Message) of a Release for a Resource. This LocalAnchorReference is a string starting with the letter R.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1103, 12)))

def _BuildAutomaton_14 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_14
    del _BuildAutomaton_14
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1103, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(FulfillmentDate._UseForTag(pyxb.namespace.ExpandedName(None, 'FulfillmentDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1098, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(FulfillmentDate._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReleaseReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1103, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
FulfillmentDate._Automaton = _BuildAutomaton_14()




Genre._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'GenreText'), Description, scope=Genre, documentation='A Composite containing a Description of a genre or style (such as Musical, literary or audio-visual) with which a Creation is associated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1115, 12)))

Genre._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SubGenre'), Description, scope=Genre, documentation='A Composite containing a Description of a secondary genre or style with which a Creation is associated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1120, 12)))

def _BuildAutomaton_15 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_15
    del _BuildAutomaton_15
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1120, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Genre._UseForTag(pyxb.namespace.ExpandedName(None, 'GenreText')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1115, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Genre._UseForTag(pyxb.namespace.ExpandedName(None, 'SubGenre')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1120, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Genre._Automaton = _BuildAutomaton_15()




HashSum._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HashSum'), pyxb.binding.datatypes.string, scope=HashSum, documentation='The value of the HashSum.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1156, 12)))

HashSum._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HashSumAlgorithmType'), HashSumAlgorithmType, scope=HashSum, documentation='A Composite containing details of the Type of HashSumAlgorithm governing the HashSum.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1161, 12)))

def _BuildAutomaton_16 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_16
    del _BuildAutomaton_16
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(HashSum._UseForTag(pyxb.namespace.ExpandedName(None, 'HashSum')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1156, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(HashSum._UseForTag(pyxb.namespace.ExpandedName(None, 'HashSumAlgorithmType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1161, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
HashSum._Automaton = _BuildAutomaton_16()




HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=HostSoundCarrier, documentation='A Composite containing details of ReleaseIds of the HostSoundCarrier. If available, a GRid has to be used. If the HostSoundCarrier contains only one SoundRecording, the ISRC of the SoundRecording may be used instead.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1192, 12)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=HostSoundCarrier, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the HostSoundCarrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1197, 12)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=HostSoundCarrier, documentation='A Composite containing details of a Title of the HostSoundCarrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1202, 12)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), DisplayArtist, scope=HostSoundCarrier, documentation='A Composite containing details of the DisplayArtist for the HostSoundCarrier. The DisplayArtist may be described through Name, Identifier and Roles.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1207, 12)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany'), AdministratingRecordCompany, scope=HostSoundCarrier, documentation='A Composite containing details of the AdministratingRecordCompany for the Rights in the HostSoundCarrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1212, 12)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TrackNumber'), pyxb.binding.datatypes.string, scope=HostSoundCarrier, documentation='The TrackNumber of the SoundRecording within the HostSoundCarrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1217, 12)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VolumeNumberInSet'), pyxb.binding.datatypes.string, scope=HostSoundCarrier, documentation='The SequenceNumber within the Set of the volume containing the SoundRecording, where the HostSoundCarrier is a Set (such as a "box set" of CDs).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1222, 12)))

def _BuildAutomaton_17 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_17
    del _BuildAutomaton_17
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1192, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1197, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1202, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1207, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1212, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1217, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1222, 12))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1192, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1197, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1202, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1207, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1212, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'TrackNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1217, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'VolumeNumberInSet')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1222, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
HostSoundCarrier._Automaton = _BuildAutomaton_17()




Image._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ImageType'), ImageType, scope=Image, documentation='A Composite containing details of the Type of the Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1248, 12)))

Image._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), pyxb.binding.datatypes.boolean, scope=Image, documentation='The Flag indicating whether the Image is related to an Artist (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1253, 12)))

Image._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ImageId'), ImageId, scope=Image, documentation='A Composite containing details of Identifiers of the Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1258, 12)))

Image._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReference'), _ImportedBinding__ddex.LocalResourceAnchor, scope=Image, documentation='The Identifier (specific to the Message) of the Image within the Release which contains it. This LocalAnchor is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1263, 12)))

Image._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=Image, documentation='A Composite containing details of a Title of the Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1268, 12)))

Image._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CreationDate'), EventDate, scope=Image, documentation='A Composite containing details of the Date and Place of the Event in which the Image was created.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1273, 12)))

Image._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ImageDetailsByTerritory'), ImageDetailsByTerritory, scope=Image, documentation='A Composite containing details of the Image which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1278, 12)))

def _BuildAutomaton_18 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_18
    del _BuildAutomaton_18
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1248, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1253, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1268, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1273, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Image._UseForTag(pyxb.namespace.ExpandedName(None, 'ImageType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1248, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Image._UseForTag(pyxb.namespace.ExpandedName(None, 'IsArtistRelated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1253, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Image._UseForTag(pyxb.namespace.ExpandedName(None, 'ImageId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1258, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Image._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1263, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Image._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1268, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Image._UseForTag(pyxb.namespace.ExpandedName(None, 'CreationDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1273, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Image._UseForTag(pyxb.namespace.ExpandedName(None, 'ImageDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1278, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Image._Automaton = _BuildAutomaton_18()




ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=ImageDetailsByTerritory, documentation='A Territory to which the Image details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1320, 16)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=ImageDetailsByTerritory, documentation='A Territory to which the Image details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1325, 16)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=ImageDetailsByTerritory, documentation='A Composite containing details of a Contributor to the Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1331, 12)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=ImageDetailsByTerritory, documentation='A Composite containing details of an indirect Contributor to the Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1336, 12)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=ImageDetailsByTerritory, documentation='A Composite containing details of the CLine for the Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1341, 12)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Description'), Description, scope=ImageDetailsByTerritory, documentation='A Composite containing a Description of the subject of the Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1346, 12)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), CourtesyLine, scope=ImageDetailsByTerritory, documentation='A Composite containing an Annotation which acknowledges record companies and/or other Parties giving permission for Artists or others featured on the Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1351, 12)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=ImageDetailsByTerritory, documentation='A Composite containing details of the Date and Place of the Event in which the Image was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1356, 12)))

def _BuildAutomaton_19 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_19
    del _BuildAutomaton_19
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1331, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1336, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1341, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1346, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1351, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1356, 12))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1320, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1325, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1331, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1336, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1341, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Description')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1346, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CourtesyLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1351, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1356, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ImageDetailsByTerritory._Automaton = _BuildAutomaton_19()




ImageId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=ImageId, documentation='A Composite containing details of a ProprietaryIdentifier of the Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1373, 12)))

def _BuildAutomaton_20 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_20
    del _BuildAutomaton_20
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ImageId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1373, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ImageId._Automaton = _BuildAutomaton_20()




MessageAuditTrail._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageAuditTrailEvent'), MessageAuditTrailEvent, scope=MessageAuditTrail, documentation='A Composite containing details of a Party handling the Message and the Time at which the handling took place.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1496, 12)))

def _BuildAutomaton_21 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_21
    del _BuildAutomaton_21
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessageAuditTrail._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageAuditTrailEvent')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1496, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessageAuditTrail._Automaton = _BuildAutomaton_21()




MessageAuditTrailEvent._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessagingPartyDescriptor'), MessagingParty, scope=MessageAuditTrailEvent, documentation='A Composite containing details of a MessagingParty.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1513, 12)))

MessageAuditTrailEvent._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DateTime'), pyxb.binding.datatypes.dateTime, scope=MessageAuditTrailEvent, documentation='The DateTime at which the Message was handled by the MessagingParty (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1518, 12)))

def _BuildAutomaton_22 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_22
    del _BuildAutomaton_22
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageAuditTrailEvent._UseForTag(pyxb.namespace.ExpandedName(None, 'MessagingPartyDescriptor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1513, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessageAuditTrailEvent._UseForTag(pyxb.namespace.ExpandedName(None, 'DateTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1518, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessageAuditTrailEvent._Automaton = _BuildAutomaton_22()




MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageThreadId'), pyxb.binding.datatypes.string, scope=MessageHeader, documentation='A string used to uniquely identify the thread of Messages of which the current Message is a part.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1530, 12)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageId'), pyxb.binding.datatypes.string, scope=MessageHeader, documentation='A string used to uniquely identify the current Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1535, 12)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageFileName'), pyxb.binding.datatypes.string, scope=MessageHeader, documentation='The FileName, possibly including the FilePath, of the XML File containing the current Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1540, 12)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageSender'), MessagingParty, scope=MessageHeader, documentation='A Composite containing details of the MessageSender.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1545, 12)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SentOnBehalfOf'), MessagingParty, scope=MessageHeader, documentation='A Composite containing details of the Party on whose behalf the Message is sent.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1550, 12)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageRecipient'), MessagingParty, scope=MessageHeader, documentation='A Composite containing details of the MessageRecipient.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1555, 12)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageCreatedDateTime'), pyxb.binding.datatypes.dateTime, scope=MessageHeader, documentation='The DateTime on which the Message was created (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1560, 12)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageAuditTrail'), MessageAuditTrail, scope=MessageHeader, documentation='A Composite containing information about Parties in between the original MessageSender and ultimate MessageRecipient.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1565, 12)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Comment'), Comment, scope=MessageHeader, documentation='A Composite containing a human-readable Comment about the Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1570, 12)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageControlType'), _ImportedBinding__ddex.MessageControlType, scope=MessageHeader, documentation='The indicator used to distinguish a live Message from a test Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1575, 12)))

def _BuildAutomaton_23 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_23
    del _BuildAutomaton_23
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1540, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1550, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1565, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1570, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1575, 12))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageThreadId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1530, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1535, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageFileName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1540, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageSender')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1545, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'SentOnBehalfOf')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1550, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageRecipient')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1555, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageCreatedDateTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1560, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageAuditTrail')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1565, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'Comment')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1570, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageControlType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1575, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessageHeader._Automaton = _BuildAutomaton_23()




MessageNotificationPeriod._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartDate'), pyxb.binding.datatypes.date, scope=MessageNotificationPeriod, documentation='The Date that marks the beginning of the Period (in ISO 8601:2004 format: YYYY-MM-DD). This cannot be a Date in the future.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1592, 12)))

MessageNotificationPeriod._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndDate'), pyxb.binding.datatypes.date, scope=MessageNotificationPeriod, documentation='The Date that marks the end of the Period (in ISO 8601:2004 format: YYYY-MM-DD). This cannot be a Date in the future.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1597, 12)))

def _BuildAutomaton_24 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_24
    del _BuildAutomaton_24
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageNotificationPeriod._UseForTag(pyxb.namespace.ExpandedName(None, 'StartDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1592, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessageNotificationPeriod._UseForTag(pyxb.namespace.ExpandedName(None, 'EndDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1597, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessageNotificationPeriod._Automaton = _BuildAutomaton_24()




MessagingParty._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=MessagingParty, documentation='A Composite containing details of the PartyId for the Party handling the Message. If no Namespace is given, the Identifier is a DdexPartyId (DPID). Note that DPIDs are not normally used to identify Artists, Producers or other Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1609, 12)))

MessagingParty._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=MessagingParty, documentation='A Composite containing details of the PartyNames for the Party handling the Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1614, 12)))

MessagingParty._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TradingName'), Name, scope=MessagingParty, documentation='A Composite containing a TradingName for the Party handling the Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1619, 12)))

def _BuildAutomaton_25 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_25
    del _BuildAutomaton_25
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1614, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1619, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessagingParty._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1609, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MessagingParty._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1614, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MessagingParty._UseForTag(pyxb.namespace.ExpandedName(None, 'TradingName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1619, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessagingParty._Automaton = _BuildAutomaton_25()




MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MidiType'), MidiType, scope=MIDI, documentation='A Composite containing details of the Type of the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1636, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), pyxb.binding.datatypes.boolean, scope=MIDI, documentation='The Flag indicating whether the MIDI is related to an Artist (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1641, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MidiId'), MidiId, scope=MIDI, documentation='A Composite containing details of Identifiers of the Midi.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1646, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectMidiId'), MusicalWorkId, scope=MIDI, documentation='A Composite containing details of a MusicalWorkId of a MusicalWork used in the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1651, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReference'), _ImportedBinding__ddex.LocalResourceAnchor, scope=MIDI, documentation='The Identifier (specific to the Message) of the MIDI within the Release which contains it. This LocalAnchor is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1656, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=MIDI, documentation='A Composite containing details of the ReferenceTitle of the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1661, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'InstrumentationDescription'), Description, scope=MIDI, documentation='A Composite containing a Description of the Type of instrumentation of the MusicalWork(s) in the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1666, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsMedley'), pyxb.binding.datatypes.boolean, scope=MIDI, documentation='The Flag indicating whether the MIDI is a Medley (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1671, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsPotpourri'), pyxb.binding.datatypes.boolean, scope=MIDI, documentation='The Flag indicating whether the MIDI is a Potpourri (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1676, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsInstrumental'), pyxb.binding.datatypes.boolean, scope=MIDI, documentation='The Flag indicating whether the MIDI is instrumental (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1681, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsBackground'), pyxb.binding.datatypes.boolean, scope=MIDI, documentation='The Flag indicating whether the MIDI is used as background to other audio or audiovisual material (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1686, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsHiddenResource'), pyxb.binding.datatypes.boolean, scope=MIDI, documentation='The Flag indicating whether the MIDI is hidden in some way from the Consumer (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1691, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsBonusResource'), pyxb.binding.datatypes.boolean, scope=MIDI, documentation='The Flag indicating whether the MIDI is additional to those on the original Release of which this is a Version (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1696, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsComputerGenerated'), pyxb.binding.datatypes.boolean, scope=MIDI, documentation='The Flag indicating whether the MIDI is generated by a computer (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1701, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LanguageOfPerformance'), _ImportedBinding__iso639a2.LanguageCode, scope=MIDI, documentation='The Language of the Performance recorded in the MIDI (represented by an ISO 639-2 LanguageCode).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1706, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=MIDI, documentation='The Duration of the MIDI (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1711, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=MIDI, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1716, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), ResourceMusicalWorkReferenceList, scope=MIDI, documentation='A Composite containing details of one or more MusicalWorks contained in the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1721, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), ResourceContainedResourceReferenceList, scope=MIDI, documentation='A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1726, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CreationDate'), EventDate, scope=MIDI, documentation='A Composite containing details of the Date and Place of the Event in which the MIDI was created.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1731, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MasteredDate'), EventDate, scope=MIDI, documentation='A Composite containing details of the Date and Place of the Event in which the MIDI was originally mastered (either in analogue or digital form).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1736, 12)))

MIDI._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MidiDetailsByTerritory'), MidiDetailsByTerritory, scope=MIDI, documentation='A Composite containing details of Descriptors and other attributes of the MIDI which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1741, 12)))

def _BuildAutomaton_26 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_26
    del _BuildAutomaton_26
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1636, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1641, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1651, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1666, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1671, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1676, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1681, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1686, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1691, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1696, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1701, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1706, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1716, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1721, 12))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1726, 12))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1731, 12))
    counters.add(cc_15)
    cc_16 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1736, 12))
    counters.add(cc_16)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'MidiType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1636, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'IsArtistRelated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1641, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'MidiId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1646, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectMidiId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1651, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1656, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1661, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'InstrumentationDescription')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1666, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'IsMedley')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1671, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'IsPotpourri')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1676, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'IsInstrumental')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1681, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'IsBackground')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1686, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'IsHiddenResource')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1691, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'IsBonusResource')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1696, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'IsComputerGenerated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1701, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'LanguageOfPerformance')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1706, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1711, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1716, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1721, 12))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1726, 12))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'CreationDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1731, 12))
    st_19 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_19)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'MasteredDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1736, 12))
    st_20 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_20)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MIDI._UseForTag(pyxb.namespace.ExpandedName(None, 'MidiDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1741, 12))
    st_21 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_21)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    transitions.append(fac.Transition(st_19, [
         ]))
    transitions.append(fac.Transition(st_20, [
         ]))
    transitions.append(fac.Transition(st_21, [
         ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_18._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_15, True) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_15, False) ]))
    st_19._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_16, True) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_16, False) ]))
    st_20._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_21, [
         ]))
    st_21._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MIDI._Automaton = _BuildAutomaton_26()




MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=MidiDetailsByTerritory, documentation='A Territory to which the MIDI details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1759, 16)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=MidiDetailsByTerritory, documentation='A Territory to which the MIDI details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1764, 16)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=MidiDetailsByTerritory, documentation='A Composite containing details of a Title of the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1770, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), DisplayArtist, scope=MidiDetailsByTerritory, documentation='A Composite containing details of the DisplayArtist for the MIDI. The DisplayArtist may be described through Name, Identifier and Roles.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1775, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=MidiDetailsByTerritory, documentation='A Composite containing details of a Contributor to the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1780, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=MidiDetailsByTerritory, documentation='A Composite containing details of an indirect Contributor to the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1785, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=MidiDetailsByTerritory, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1790, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LabelName'), Name, scope=MidiDetailsByTerritory, documentation='A Composite containing the Name of the Label under which the Release is to be marketed.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1795, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsController'), RightsController, scope=MidiDetailsByTerritory, documentation='A Composite containing details of RightsController of Rights in the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1800, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), EventDate, scope=MidiDetailsByTerritory, documentation='A Composite containing details of the Date and Place of the Event in which the MIDI was re-mastered (usually digitally).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1805, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=MidiDetailsByTerritory, documentation='A Composite containing details of the Date and Place of the Event in which the MIDI was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1810, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=MidiDetailsByTerritory, documentation='A Composite containing details of the CLine for the MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1815, 12)))

def _BuildAutomaton_27 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_27
    del _BuildAutomaton_27
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1770, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1775, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1780, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1785, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1790, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1795, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1800, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1805, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1810, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1815, 12))
    counters.add(cc_9)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1759, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1764, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1770, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1775, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1780, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1785, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1790, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1795, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsController')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1800, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RemasteredDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1805, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1810, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1815, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MidiDetailsByTerritory._Automaton = _BuildAutomaton_27()




MidiId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=MidiId, documentation='A Composite containing details of a ProprietaryIdentifier of the Midi.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1832, 12)))

def _BuildAutomaton_28 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_28
    del _BuildAutomaton_28
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MidiId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1832, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MidiId._Automaton = _BuildAutomaton_28()




MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkId'), MusicalWorkId, scope=MusicalWork, documentation='A Composite containing details of a MusicalWorkId of the MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1863, 12)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkReference'), _ImportedBinding__ddex.LocalMusicalWorkAnchor, scope=MusicalWork, documentation='The Identifier (specific to the Message) of the MusicalWork within the Release which contains it. This LocalAnchor is a string starting with the letter W.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1868, 12)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=MusicalWork, documentation='A Composite containing details of a ReferenceTitle of the MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1873, 12)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=MusicalWork, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1878, 12)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor'), MusicalWorkContributor, scope=MusicalWork, documentation='A Composite containing details a MusicalWorkContributor to the MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1883, 12)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkType'), MusicalWorkType, scope=MusicalWork, documentation='A Composite containing details of the Type of the MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1888, 12)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShare'), RightShare, scope=MusicalWork, documentation='A Composite containing details of a RightShare for the MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1893, 12)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkDetailsByTerritory'), MusicalWorkDetailsByTerritory, scope=MusicalWork, documentation='A Composite containing details of Descriptors and other attributes of the MusicalWork which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1898, 12)))

def _BuildAutomaton_29 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_29
    del _BuildAutomaton_29
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1878, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1888, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1893, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1898, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1863, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1868, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1873, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1878, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1883, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1888, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShare')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1893, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1898, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MusicalWork._Automaton = _BuildAutomaton_29()




MusicalWorkDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=MusicalWorkDetailsByTerritory, documentation='A Territory to which the MusicalWork details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1966, 16)))

MusicalWorkDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=MusicalWorkDetailsByTerritory, documentation='A Territory to which the MusicalWork details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1971, 16)))

MusicalWorkDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor'), MusicalWorkContributor, scope=MusicalWorkDetailsByTerritory, documentation='A Composite containing details a MusicalWorkContributor to the MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1977, 12)))

def _BuildAutomaton_30 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_30
    del _BuildAutomaton_30
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWorkDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1966, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWorkDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1971, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MusicalWorkDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1977, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MusicalWorkDetailsByTerritory._Automaton = _BuildAutomaton_30()




MusicalWorkId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISWC'), pyxb.binding.datatypes.string, scope=MusicalWorkId, documentation='The ISWC (International Standard Musical Work Code defined in ISO 15707) identifying the MusicalWork. An ISWC comprises three parts: the letter "T", followed by nine digits and then one check digit.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1994, 12)))

MusicalWorkId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OpusNumber'), pyxb.binding.datatypes.string, scope=MusicalWorkId, documentation='The MusicalWorkId identifying the MusicalWork within the catalog of its Composer (typically of classical music) as an opus number.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1999, 12)))

MusicalWorkId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ComposerCatalogNumber'), pyxb.binding.datatypes.string, scope=MusicalWorkId, documentation='A MusicalWorkId identifying a MusicalWork within the catalog of its Composer (typically of classical music) according to a standardized numbering (e.g. "K" numbers for Koechel\'s catalog of Mozart).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2004, 12)))

MusicalWorkId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=MusicalWorkId, documentation='A Composite containing details of a ProprietaryIdentifier of the MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2009, 12)))

def _BuildAutomaton_31 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_31
    del _BuildAutomaton_31
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1994, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1999, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2004, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2009, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISWC')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1994, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkId._UseForTag(pyxb.namespace.ExpandedName(None, 'OpusNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1999, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkId._UseForTag(pyxb.namespace.ExpandedName(None, 'ComposerCatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2004, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2009, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
MusicalWorkId._Automaton = _BuildAutomaton_31()




NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Quantity'), pyxb.binding.datatypes.integer, scope=NumberOfSubscribers, documentation='The number of Consumers using the DSP service specified for the UseType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2068, 12)))

NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=NumberOfSubscribers, documentation='A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2073, 12)))

NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=NumberOfSubscribers, documentation='A Composite containing details of a physical interface by which a Consumer uses a Service or Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2078, 12)))

NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=NumberOfSubscribers, documentation='A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2083, 12)))

NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=NumberOfSubscribers, documentation='A Composite containing details of a Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2088, 12)))

def _BuildAutomaton_32 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_32
    del _BuildAutomaton_32
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2078, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2083, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2088, 12))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'Quantity')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2068, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2073, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2078, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2083, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2088, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
NumberOfSubscribers._Automaton = _BuildAutomaton_32()




PartyDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=PartyDescriptor, documentation='A Composite containing details of the PartyId for the Party. If no Namespace is given, the Identifier is a DdexPartyId (DPID). Note that DPIDs are not normally used to identify Artists, Producers or other Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12)))

PartyDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=PartyDescriptor, documentation='A Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16)))

def _BuildAutomaton_33 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_33
    del _BuildAutomaton_33
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PartyDescriptor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PartyDescriptor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(PartyDescriptor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PartyDescriptor._Automaton = _BuildAutomaton_33()




PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FullName'), Name, scope=PartyName, documentation='A Composite containing the complete Name of the Party, in its normal form of presentation (e.g. John H. Smith, Acme Music Inc, A Composite containing the Beatles).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2200, 12)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FullNameAsciiTranscribed'), pyxb.binding.datatypes.string, scope=PartyName, documentation='The FullName transcribed using 7-bit ASCII code.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2205, 12)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FullNameIndexed'), Name, scope=PartyName, documentation='A Composite containing the complete Name of the Party in the form in which it normally appears in an alphabetic index, with the KeyName first (e.g. Smith, John H.; Beatles, A Composite containing the).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2210, 12)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NamesBeforeKeyName'), Name, scope=PartyName, documentation='A Composite containing the Name(s) preceding the KeyName in the FullName (and that is placed after it in a FullNameIndexed). Examples: "George" in "George Michael"; "John Fitzgerald" in "John Fitzgerald Kennedy". Not all PartyNames have a NamesBeforeKeyName (e.g. Madonna, EMI Music Inc).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2215, 12)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'KeyName'), Name, scope=PartyName, documentation='A Composite containing the Part of a Name of the Party normally used to index an entry in an alphabetical list, such as "Smith" (in John Smith) or "Garcia Marquez" or "Madonna" or "Francis de Sales" (in Saint Francis de Sales). For persons, this normally corresponds to the "family name" or names, which in Western name forms usually comes as a surname at the end of a FullName, and in Asian name forms often at the beginning of a FullName.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2220, 12)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NamesAfterKeyName'), Name, scope=PartyName, documentation='A Composite containing the Name(s) following the KeyName. Example:"Ibrahim" (in Anwar Ibrahim). This is common, e.g., in many Asian personal name forms where a FullName begins with the KeyName, which is followed by other names.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2225, 12)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AbbreviatedName'), Name, scope=PartyName, documentation='A Composite containing a short version of the PartyName (e.g. for use on devices with a small display).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2230, 12)))

def _BuildAutomaton_34 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_34
    del _BuildAutomaton_34
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2205, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2210, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2215, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2220, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2225, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2230, 12))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'FullName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2200, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'FullNameAsciiTranscribed')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2205, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'FullNameIndexed')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2210, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'NamesBeforeKeyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2215, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'KeyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2220, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'NamesAfterKeyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2225, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'AbbreviatedName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2230, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PartyName._Automaton = _BuildAutomaton_34()




Period._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartDate'), EventDate, scope=Period, documentation='A Composite containing details of the Date and Place of an Event that marks the beginning of the Period (in ISO 8601:2004 format: YYYY-MM-DD). The StartDate must be earlier than the EndDate if both are provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2247, 12)))

Period._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndDate'), EventDate, scope=Period, documentation='A Composite containing details of the Date and Place of an Event that marks the end of the Period (in ISO 8601:2004 format: YYYY-MM-DD). The EndDate must be later than the StartDate if both are provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2252, 12)))

def _BuildAutomaton_35 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_35
    del _BuildAutomaton_35
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2247, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2252, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Period._UseForTag(pyxb.namespace.ExpandedName(None, 'StartDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2247, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Period._UseForTag(pyxb.namespace.ExpandedName(None, 'EndDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2252, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Period._Automaton = _BuildAutomaton_35()




PLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Year'), pyxb.binding.datatypes.gYear, scope=PLine, documentation='The Year of the PLine.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2264, 12)))

PLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLineText'), pyxb.binding.datatypes.string, scope=PLine, documentation='The text of the PLine.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2269, 12)))

def _BuildAutomaton_36 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_36
    del _BuildAutomaton_36
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PLine._UseForTag(pyxb.namespace.ExpandedName(None, 'Year')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2264, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PLine._UseForTag(pyxb.namespace.ExpandedName(None, 'PLineText')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2269, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PLine._Automaton = _BuildAutomaton_36()




PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PriceRangeType'), PriceRangeType, scope=PriceInformation, documentation='A Composite containing a Type of Price according to its value range. Typical examples include "budget" and "front line".', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2314, 12)))

PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PriceType'), PriceType, scope=PriceInformation, documentation='A Composite containing further details of the Price. Often used to refine the PriceRangeType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2319, 12)))

PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'WholesalePricePerUnit'), Price, scope=PriceInformation, documentation='A Composite containing details of a wholesale Price for a single unit of Usage. Note that this Price applies to all UseTypes referenced in a DealTerm Composite.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2324, 12)))

PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'BulkOrderWholesalePricePerUnit'), Price, scope=PriceInformation, documentation='A Composite containing details of a wholesale Price for a single unit. Note that the size of a bulk order is defined in the contract between MessageSender and the MessageRecipient.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2329, 12)))

PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SuggestedRetailPrice'), Price, scope=PriceInformation, documentation='A Composite containing details of a suggested retail Price.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2334, 12)))

def _BuildAutomaton_37 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_37
    del _BuildAutomaton_37
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2314, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2319, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2324, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2329, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2334, 12))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'PriceRangeType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2314, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'PriceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2319, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'WholesalePricePerUnit')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2324, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'BulkOrderWholesalePricePerUnit')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2329, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'SuggestedRetailPrice')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2334, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
PriceInformation._Automaton = _BuildAutomaton_37()




RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseType'), ReleaseType, scope=RecordCompanyMarketShareData, documentation='A Composite containing details of the form in which a ReleaseCreator anticipates offering the Release to Consumers.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2492, 12)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UnitsSoldTotal'), pyxb.binding.datatypes.integer, scope=RecordCompanyMarketShareData, documentation='The total number of Releases sold of the ReleaseType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2497, 12)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=RecordCompanyMarketShareData, documentation='A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2502, 12)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=RecordCompanyMarketShareData, documentation='A Composite containing details of a physical interface by which a Consumer uses a Service or Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2507, 12)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=RecordCompanyMarketShareData, documentation='A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2512, 12)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=RecordCompanyMarketShareData, documentation='A Composite containing details of a Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2517, 12)))

def _BuildAutomaton_38 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_38
    del _BuildAutomaton_38
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2492, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2507, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2512, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2517, 12))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2492, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'UnitsSoldTotal')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2497, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2502, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2507, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2512, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2517, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RecordCompanyMarketShareData._Automaton = _BuildAutomaton_38()




ReferenceTitle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TitleText'), TitleText, scope=ReferenceTitle, documentation='A Composite containing the text of the ReferenceTitle.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2548, 12)))

ReferenceTitle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SubTitle'), SubTitle, scope=ReferenceTitle, documentation='A Composite containing details of a SubTitle of the ReferenceTitle, including Titles of Versions used to differentiate different versions of the same Title, as required by the GRId and ISRC ReferenceDescriptiveMetadataSets.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2553, 12)))

def _BuildAutomaton_39 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_39
    del _BuildAutomaton_39
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2553, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReferenceTitle._UseForTag(pyxb.namespace.ExpandedName(None, 'TitleText')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2548, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ReferenceTitle._UseForTag(pyxb.namespace.ExpandedName(None, 'SubTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2553, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReferenceTitle._Automaton = _BuildAutomaton_39()




RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=RelatedRelease, documentation='A Composite containing details of ReleaseIds. If available, a GRid shall always to be used. If the Release contains only one SoundRecording, the ISRC of the SoundRecording may be used instead. If the Release is an abstraction of a complete PhysicalProduct (such as a CD Album), the ICPN of the PhysicalProduct may be used instead. More than one of these identifiers may be provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2570, 12)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=RelatedRelease, documentation='A Composite containing details of the ReferenceTitle of the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2575, 12)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory'), ReleaseSummaryDetailsByTerritory, scope=RelatedRelease, documentation='A Composite containing summary details of Descriptors and other attributes of the Release which may vary according to Territory of Release. Territory of Release may be the world.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2580, 12)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=RelatedRelease, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2585, 12)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseRelationshipType'), ReleaseRelationshipType, scope=RelatedRelease, documentation='A Composite containing details of the Type of the relationship between the two Releases.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2590, 12)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseDate'), EventDate, scope=RelatedRelease, documentation='A Composite containing details of the Date and Place of the Event in which the related Release is made available for Usage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2595, 12)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate'), EventDate, scope=RelatedRelease, documentation='A Composite containing details of the Date and Place of the Event in which the Release was or will be first made available for Usage, whether for physical or electronic/online distribution (in ISO 8601:2004 format: YYYY-MM-DD).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2600, 12)))

def _BuildAutomaton_40 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_40
    del _BuildAutomaton_40
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2575, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2580, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2585, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2595, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2600, 12))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2570, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2575, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2580, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2585, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseRelationshipType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2590, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2595, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2600, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RelatedRelease._Automaton = _BuildAutomaton_40()




Release._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=Release, documentation='A Composite containing details of ReleaseIds. If available, a GRid shall always to be used. If the Release contains only one SoundRecording, the ISRC of the SoundRecording may be used instead. If the Release is an abstraction of a complete PhysicalProduct (such as a CD Album), the ICPN of the PhysicalProduct may be used instead. More than one of these identifiers may be provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2617, 12)))

Release._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=Release, documentation='A Composite containing details of the ReferenceTitle of the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2622, 12)))

Release._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseResourceReferenceList'), ReleaseResourceReferenceList, scope=Release, documentation='A Composite containing details of one or more Resources contained in the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2627, 12)))

Release._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseType'), ReleaseType, scope=Release, documentation='A Composite containing details of the form in which a ReleaseCreator anticipates offering the Release to Consumers. This may be overridden by the ReleaseType for specific Territories as specified in the ReleaseDetailsByTerritory Composite.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2632, 12)))

Release._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseDetailsByTerritory'), ReleaseDetailsByTerritory, scope=Release, documentation='A Composite containing details of Descriptors and other attributes of the Release which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2637, 12)))

Release._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=Release, documentation='The sum of the Durations of all Resources contained in the Release (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2642, 12)))

Release._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=Release, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2647, 12)))

Release._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLine'), PLine, scope=Release, documentation='A Composite containing details of the PLine for the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2652, 12)))

Release._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=Release, documentation='A Composite containing details of the CLine for the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2657, 12)))

def _BuildAutomaton_41 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_41
    del _BuildAutomaton_41
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2627, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2632, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2642, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2647, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2652, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2657, 12))
    counters.add(cc_5)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Release._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2617, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Release._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2622, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Release._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseResourceReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2627, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Release._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2632, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Release._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2637, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Release._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2642, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Release._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2647, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Release._UseForTag(pyxb.namespace.ExpandedName(None, 'PLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2652, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Release._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2657, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Release._Automaton = _BuildAutomaton_41()




ReleaseCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), pyxb.binding.datatypes.integer, scope=ReleaseCollectionReferenceList, documentation='The number of referenced Collections (typically Chapters).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2707, 12)))

ReleaseCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseCollectionReference'), ReleaseCollectionReference, scope=ReleaseCollectionReferenceList, documentation='A Composite containing a ReleaseCollectionReference for a Collection (specific to this Message). The referenced Collection has to be of CollectionType Series, Season or Episode.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2712, 12)))

def _BuildAutomaton_42 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_42
    del _BuildAutomaton_42
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2707, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'NumberOfCollections')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2707, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2712, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseCollectionReferenceList._Automaton = _BuildAutomaton_42()




ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'GRid'), pyxb.binding.datatypes.string, scope=ReleaseId, documentation='The GRid identifying the Release. This is the preferred Element and is mandatory if a GRid is available. A GRid comprises four parts: the string "A1", followed by five alphanumeric characters, ten alphanumeric characters and and one alphanumeric character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2765, 12)))

ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=ReleaseId, documentation='The ISRC (International Standard Recording Code as defined in ISO 3901) used as proxy for identification of the Release. Only applicable when the Release only contains one SoundRecording or one MusicalWorkVideo. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2770, 12)))

ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ICPN'), ICPN, scope=ReleaseId, documentation='A Composite containing details of the ICPN used as proxy for identification of the Release. Only applicable when the Release is an abstraction of a complete PhysicalProduct. An ICPN comprises 12 or 13 digits, depending whether it is an EAN (13) or a UPC (12).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2775, 12)))

ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=ReleaseId, documentation='A Composite containing details of the CatalogNumber of the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2780, 12)))

ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=ReleaseId, documentation='A Composite containing details of a ProprietaryIdentifier of the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2785, 12)))

def _BuildAutomaton_43 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_43
    del _BuildAutomaton_43
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2765, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2770, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2775, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2780, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2785, 12))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'GRid')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2765, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2770, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ICPN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2775, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2780, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2785, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ReleaseId._Automaton = _BuildAutomaton_43()




ReleaseResourceReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseResourceReference'), ReleaseResourceReference, scope=ReleaseResourceReferenceList, documentation='A Composite containing a Reference for a Resource (specific to this Message). The LocalAnchorReference in this Composite is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2830, 12)))

def _BuildAutomaton_44 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_44
    del _BuildAutomaton_44
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseResourceReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2830, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseResourceReferenceList._Automaton = _BuildAutomaton_44()




ReleaseSummary._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=ReleaseSummary, documentation='A Composite containing details of ReleaseIds. If available, a GRid shall always to be used. If the Release contains only one SoundRecording, the ISRC of the SoundRecording may be used instead. If the Release is an abstraction of a complete PhysicalProduct (such as a CD Album), the ICPN of the PhysicalProduct may be used instead. More than one of these identifiers may be provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2842, 12)))

ReleaseSummary._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=ReleaseSummary, documentation='A Composite containing details of the ReferenceTitle of the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2847, 12)))

ReleaseSummary._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory'), ReleaseSummaryDetailsByTerritory, scope=ReleaseSummary, documentation='A Composite containing summary details of Descriptors and other attributes of the Release which may vary according to Territory of Release. Territory of Release may be the world.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2852, 12)))

ReleaseSummary._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=ReleaseSummary, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2857, 12)))

def _BuildAutomaton_45 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_45
    del _BuildAutomaton_45
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2852, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2857, 12))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2842, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2847, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2852, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2857, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseSummary._Automaton = _BuildAutomaton_45()




ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=ReleaseSummaryDetailsByTerritory, documentation='A Territory to which the ReleaseSummaryDetailsByTerritory apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2875, 16)))

ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=ReleaseSummaryDetailsByTerritory, documentation='A Territory to which the ReleaseSummaryDetailsByTerritory do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2880, 16)))

ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtistName'), Name, scope=ReleaseSummaryDetailsByTerritory, documentation='A Composite containing the Name to be used by a DSP when presenting Artist details of the Release to a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2886, 12)))

ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LabelName'), Name, scope=ReleaseSummaryDetailsByTerritory, documentation='A Composite containing the Name of the Label for the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2891, 12)))

ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=ReleaseSummaryDetailsByTerritory, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2896, 12)))

def _BuildAutomaton_46 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_46
    del _BuildAutomaton_46
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2886, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2891, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2896, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2875, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2880, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtistName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2886, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2891, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2896, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseSummaryDetailsByTerritory._Automaton = _BuildAutomaton_46()




ResourceContainedResourceReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference'), _ImportedBinding__ddex.LocalResourceAnchorReference, scope=ResourceContainedResourceReference, documentation='A Reference for a Resource (specific to this Message). This LocalAnchorReference is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2984, 12)))

ResourceContainedResourceReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DurationUsed'), pyxb.binding.datatypes.duration, scope=ResourceContainedResourceReference, documentation='The total Duration of the Resource that has been used in a specified context (this may be less than the total Duration of the Resource) (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2989, 12)))

ResourceContainedResourceReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartPoint'), pyxb.binding.datatypes.decimal, scope=ResourceContainedResourceReference, documentation='The start point of the preview given in seconds from the start of the referenced Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2994, 12)))

ResourceContainedResourceReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Purpose'), Purpose, scope=ResourceContainedResourceReference, documentation='A Composite containing details of the Purpose of the usage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2999, 12)))

def _BuildAutomaton_47 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_47
    del _BuildAutomaton_47
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2989, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2994, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2999, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReference._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2984, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReference._UseForTag(pyxb.namespace.ExpandedName(None, 'DurationUsed')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2989, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReference._UseForTag(pyxb.namespace.ExpandedName(None, 'StartPoint')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2994, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReference._UseForTag(pyxb.namespace.ExpandedName(None, 'Purpose')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2999, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceContainedResourceReference._Automaton = _BuildAutomaton_47()




ResourceContainedResourceReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference'), ResourceContainedResourceReference, scope=ResourceContainedResourceReferenceList, documentation='A Composite containing details of a ResourceContainedResourceReference.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3011, 12)))

def _BuildAutomaton_48 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_48
    del _BuildAutomaton_48
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3011, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceContainedResourceReferenceList._Automaton = _BuildAutomaton_48()




ResourceGroupResourceReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceGroupResourceReference'), _ImportedBinding__ddex.LocalResourceAnchorReference, scope=ResourceGroupResourceReferenceList, documentation='A Reference for a Resource (specific to this Message). This LocalAnchorReference is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3063, 12)))

def _BuildAutomaton_49 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_49
    del _BuildAutomaton_49
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceGroupResourceReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceGroupResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3063, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceGroupResourceReferenceList._Automaton = _BuildAutomaton_49()




ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The ISRC (International Standard Recording Code as defined in ISO 3901) for the Resource. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3075, 12)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISMN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The ISMN (International Standard Music Number defined in ISO 10957) for the Resource. An ISMN is a thirteen-digit number. Pre-2008 ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ("M") with "979-0".', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3080, 12)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISAN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the Resource. An ISAN comprises four blocks of four hexadecimal charaters followed by a check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3085, 12)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VISAN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The V-ISAN (Version Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the Resource. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3090, 12)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISBN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The ISBN (International Standard Book Number defined in ISO 2108) for the Resource. An ISBN is a 13-digit number. Pre-2007, ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix "978" and re-calculating the check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3095, 12)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISSN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The ISSN (International Standard Serial Number defined in ISO 3297) for the Resource. An ISSN comprises two groups of four digits, separated by a hyphen and a control digit.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3100, 12)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SICI'), _ImportedBinding__ddex.SICI, scope=ResourceId, documentation='The SICI (Serial Item and Contribution Identifier defined in ANSI/NISO Z39.56-199) for the Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3105, 12)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=ResourceId, documentation='A Composite containing details of the CatalogNumber of the Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3110, 12)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=ResourceId, documentation='A Composite containing details of a ProprietaryIdentifier of the Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3115, 12)))

def _BuildAutomaton_50 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_50
    del _BuildAutomaton_50
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3075, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3080, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3085, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3090, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3095, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3100, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3105, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3110, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3115, 12))
    counters.add(cc_8)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3075, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISMN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3080, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3085, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'VISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3090, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISBN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3095, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISSN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3100, 12))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'SICI')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3105, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3110, 12))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3115, 12))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ResourceId._Automaton = _BuildAutomaton_50()




ResourceMusicalWorkReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), pyxb.binding.datatypes.integer, scope=ResourceMusicalWorkReference, documentation='The number indicating the order of the MusicalWork in a group of MusicalWorks within a Medley, SoundRecording or other Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3127, 12)))

ResourceMusicalWorkReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DurationUsed'), pyxb.binding.datatypes.duration, scope=ResourceMusicalWorkReference, documentation='The total Duration of the MusicalWork that has been used in a specified context (this may be less than the total Duration of the MusicalWork) (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3132, 12)))

ResourceMusicalWorkReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsFragment'), pyxb.binding.datatypes.boolean, scope=ResourceMusicalWorkReference, documentation='The Flag indicating whether the MusicalWork is a Fragment (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3137, 12)))

ResourceMusicalWorkReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference'), _ImportedBinding__ddex.LocalMusicalWorkAnchorReference, scope=ResourceMusicalWorkReference, documentation='A Reference for a MusicalWork (specific to this Message). This LocalAnchorReference is a string starting with the letter W.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3142, 12)))

def _BuildAutomaton_51 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_51
    del _BuildAutomaton_51
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3127, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3132, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3137, 12))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReference._UseForTag(pyxb.namespace.ExpandedName(None, 'SequenceNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3127, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReference._UseForTag(pyxb.namespace.ExpandedName(None, 'DurationUsed')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3132, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReference._UseForTag(pyxb.namespace.ExpandedName(None, 'IsFragment')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3137, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReference._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3142, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceMusicalWorkReference._Automaton = _BuildAutomaton_51()




ResourceMusicalWorkReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference'), ResourceMusicalWorkReference, scope=ResourceMusicalWorkReferenceList, documentation='A Composite containing a ResourceMusicalWorkReference for a MusicalWork (specific to this Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3154, 12)))

def _BuildAutomaton_52 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_52
    del _BuildAutomaton_52
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3154, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceMusicalWorkReferenceList._Automaton = _BuildAutomaton_52()




RightsAgreementId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MWLI'), pyxb.binding.datatypes.string, scope=RightsAgreementId, documentation='A MusicalWork License Identifier identifying a License. If the Composite is meant to describe a Claim, RightShare or contract, then the License relates to that Claim, RightShare or contract. A MWLI comprises four parts: one of the strings "M1" or "M2" or "M3" or "M4", followed by five alphanumeric characters, ten alphanumeric characters and one alphanumeric check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3185, 12)))

RightsAgreementId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=RightsAgreementId, documentation='A Composite containing details of a ProprietaryIdentifier of the License, Claim, RightShare or contract.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3190, 12)))

def _BuildAutomaton_53 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_53
    del _BuildAutomaton_53
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3185, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3190, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(RightsAgreementId._UseForTag(pyxb.namespace.ExpandedName(None, 'MWLI')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3185, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(RightsAgreementId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3190, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
RightsAgreementId._Automaton = _BuildAutomaton_53()




RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareId'), RightsAgreementId, scope=RightShare, documentation='A Composite containing details of Identifiers for the RightShare.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3235, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareReference'), _ImportedBinding__ddex.LocalRightShareAnchor, scope=RightShare, documentation='The Identifier (specific to the Message) of the RightShare within the Release which contains it. This LocalAnchor is a string starting with the letter S.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3240, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareCreationReferenceList'), RightShareCreationReferenceList, scope=RightShare, documentation='A Composite containing details of one or more Creations contained in the RightShare.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3245, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=RightShare, documentation='A Territory to which the RightShare applies (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3251, 16)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=RightShare, documentation='A Territory to which the RightShare does not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3256, 16)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsType'), RightsType, scope=RightShare, documentation='A Type of Right covered by the RightShare. One of the Elements RightsType and UseType must be present. The RightsType is defined according to the jurisdiction of the Territory indicated in the TerritoryCode XmlAttribute.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3262, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=RightShare, documentation='A Composite containing details of a nature of a Service, or a Release, as used by a Consumer. One of the Elements RightsType and UseType must be present.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3267, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=RightShare, documentation='A Composite containing details of a physical interface by which a Consumer uses a Service or Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3272, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=RightShare, documentation='A Composite containing details of a distribution channel used to disseminate a Service or Release to a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3277, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=RightShare, documentation='A Composite containing details of a Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3282, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CommercialModelType'), CommercialModelType, scope=RightShare, documentation='A Composite containing details of the fundamental business model which applies (e.g. SubscriptionModel and PayAsYouGoModel). The CommercialModelType indicates how the Consumer pays for the Service or Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3287, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkRightsClaimType'), _ImportedBinding__ddex.MusicalWorkRightsClaimType, scope=RightShare, documentation='A Type of the RightsClaim related to a MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3292, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsController'), RightsController, scope=RightShare, documentation='A Composite containing details of a RightsController of Rights in a Creation.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3297, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ValidityPeriod'), Period, scope=RightShare, documentation='A Composite containing details about the Period of Time for which the RightShare is valid.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3302, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PercentageUnknown'), pyxb.binding.datatypes.boolean, scope=RightShare, documentation='The Flag indicating whether the RightSharePercentage is unknown (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3308, 16)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PercentageRate'), pyxb.binding.datatypes.string, scope=RightShare, documentation='The share of the licensed Rights owned by the RightsController. RightShare information is given as a decimal value (e.g. "0.125" represents 12.5%) or as a fraction (e.g. "1/8" represents 12.5%).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3313, 16)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TariffReference'), TariffReference, scope=RightShare, documentation='A Composite containing details of a Reference to a TextDocument containing details of a Tariff (in the form of an Identifier, Name or Description) that is to be applied to the RightShare.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3319, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LicenseStatus'), _ImportedBinding__ddex.LicenseStatus, scope=RightShare, documentation='The legal status of a License for the RightShare.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3324, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HasFirstLicenseRefusal'), pyxb.binding.datatypes.boolean, scope=RightShare, documentation='The Flag indicating whether a RightsController retains the right of refusal regarding the granting of the first licence for creating a SoundRecording of a Musical Work (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3329, 12)))

def _BuildAutomaton_54 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_54
    del _BuildAutomaton_54
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3235, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3245, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3262, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3267, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3272, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3277, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3282, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3287, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3292, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3297, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3313, 16))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3319, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3324, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3329, 12))
    counters.add(cc_13)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3235, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3240, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareCreationReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3245, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3251, 16))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3256, 16))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3262, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3267, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3272, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3277, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3282, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'CommercialModelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3287, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkRightsClaimType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3292, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsController')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3297, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'ValidityPeriod')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3302, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'PercentageUnknown')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3308, 16))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'PercentageRate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3313, 16))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'TariffReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3319, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'LicenseStatus')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3324, 12))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'HasFirstLicenseRefusal')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3329, 12))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, True) ]))
    st_18._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RightShare._Automaton = _BuildAutomaton_54()




RightShareCreationReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareWorkReference'), _ImportedBinding__ddex.LocalMusicalWorkAnchorReference, scope=RightShareCreationReferenceList, documentation='A Reference for a Work (specific to this Message) that is part of the RightShare. This LocalAnchorReference is a string starting with the letter W.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3346, 12)))

RightShareCreationReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareResourceReference'), _ImportedBinding__ddex.LocalResourceAnchorReference, scope=RightShareCreationReferenceList, documentation='A Reference for a Resource (specific to this Message) that is part of the RightShare. This LocalAnchorReference is a string starting with the letter A. The RightShare covers the Works used in the Resource(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3351, 12)))

RightShareCreationReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareReleaseReference'), _ImportedBinding__ddex.LocalReleaseAnchorReference, scope=RightShareCreationReferenceList, documentation='A Reference for a Release (specific to this Message) that is part of the RightShare. This LocalAnchorReference is a string starting with the letter R. The RightShare covers the Works used in the Release(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3356, 12)))

def _BuildAutomaton_55 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_55
    del _BuildAutomaton_55
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3346, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3351, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3356, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(RightShareCreationReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3346, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(RightShareCreationReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3351, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(RightShareCreationReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareReleaseReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3356, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
RightShareCreationReferenceList._Automaton = _BuildAutomaton_55()




SalesReportingProxyReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=SalesReportingProxyReleaseId, documentation='A Composite containing details of ReleaseIds. If available, a GRid should always be used.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3420, 12)))

SalesReportingProxyReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Reason'), Reason, scope=SalesReportingProxyReleaseId, documentation='A Composite containing the textual Description of the reason for the Identifier being used as a proxy.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3425, 12)))

SalesReportingProxyReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReasonType'), ReasonType, scope=SalesReportingProxyReleaseId, documentation='A Composite containing details of a ReasonType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3430, 12)))

def _BuildAutomaton_56 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_56
    del _BuildAutomaton_56
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3425, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SalesReportingProxyReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3420, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SalesReportingProxyReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'Reason')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3425, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SalesReportingProxyReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ReasonType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3430, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SalesReportingProxyReleaseId._Automaton = _BuildAutomaton_56()




SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SheetMusicType'), SheetMusicType, scope=SheetMusic, documentation='A Composite containing details of the Type of the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3456, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), pyxb.binding.datatypes.boolean, scope=SheetMusic, documentation='The Flag indicating whether the SheetMusic is related to an Artist (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3461, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SheetMusicId'), SheetMusicId, scope=SheetMusic, documentation='A Composite containing details of Identifiers of the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3466, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectSheetMusicId'), MusicalWorkId, scope=SheetMusic, documentation='A Composite containing details of a MusicalWorkId of a MusicalWork used in the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3471, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReference'), _ImportedBinding__ddex.LocalResourceAnchor, scope=SheetMusic, documentation='The Identifier (specific to the Message) of the SheetMusic within the Release which contains it. This LocalAnchor is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3476, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LanguageOfLyrics'), _ImportedBinding__iso639a2.LanguageCode, scope=SheetMusic, documentation='The Language of the lyrics of the SheetMusic (represented by an ISO 639-2 LanguageCode).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3481, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=SheetMusic, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) related to the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3486, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), ResourceMusicalWorkReferenceList, scope=SheetMusic, documentation='A Composite containing details of one or more MusicalWorks contained in the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3491, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), ResourceContainedResourceReferenceList, scope=SheetMusic, documentation='A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3496, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=SheetMusic, documentation='A Composite containing details of the ReferenceTitle of the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3501, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CreationDate'), EventDate, scope=SheetMusic, documentation='A Composite containing details of the Date and Place of the Event in which the SheetMusic was created.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3506, 12)))

SheetMusic._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SheetMusicDetailsByTerritory'), SheetMusicDetailsByTerritory, scope=SheetMusic, documentation='A Composite containing details of the SheetMusic which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3511, 12)))

def _BuildAutomaton_57 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_57
    del _BuildAutomaton_57
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3456, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3461, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3471, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3481, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3486, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3491, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3496, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3506, 12))
    counters.add(cc_7)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'SheetMusicType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3456, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'IsArtistRelated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3461, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'SheetMusicId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3466, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectSheetMusicId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3471, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3476, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'LanguageOfLyrics')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3481, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3486, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3491, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3496, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3501, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'CreationDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3506, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SheetMusic._UseForTag(pyxb.namespace.ExpandedName(None, 'SheetMusicDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3511, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SheetMusic._Automaton = _BuildAutomaton_57()




SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=SheetMusicDetailsByTerritory, documentation='A Territory to which the SheetMusic details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3553, 16)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=SheetMusicDetailsByTerritory, documentation='A Territory to which the SheetMusic details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3558, 16)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=SheetMusicDetailsByTerritory, documentation='A Composite containing details of a Title of the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3564, 12)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=SheetMusicDetailsByTerritory, documentation='A Composite containing details of a Contributor to the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3569, 12)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=SheetMusicDetailsByTerritory, documentation='A Composite containing details of an indirect Contributor to the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3574, 12)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=SheetMusicDetailsByTerritory, documentation='A Composite containing details of the CLine for the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3579, 12)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), CourtesyLine, scope=SheetMusicDetailsByTerritory, documentation='A Composite containing an Annotation which acknowledges record companies and/or other Parties giving permission for Artists or others featured in the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3584, 12)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=SheetMusicDetailsByTerritory, documentation='A Composite containing details of the Date and Place of the Event in which the SheetMusic was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3589, 12)))

def _BuildAutomaton_58 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_58
    del _BuildAutomaton_58
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3564, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3569, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3574, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3579, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3584, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3589, 12))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3553, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3558, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3564, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3569, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3574, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3579, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CourtesyLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3584, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3589, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SheetMusicDetailsByTerritory._Automaton = _BuildAutomaton_58()




SheetMusicId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISMN'), pyxb.binding.datatypes.string, scope=SheetMusicId, documentation='The ISMN (International Standard Music Number defined in ISO 10957) for the SheetMusic. An ISMN is a thirteen-digit number. Pre-2008 ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ("M") with "979-0".', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3606, 12)))

SheetMusicId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=SheetMusicId, documentation='A Composite containing details of a ProprietaryIdentifier of the SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3611, 12)))

def _BuildAutomaton_59 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_59
    del _BuildAutomaton_59
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3606, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3611, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISMN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3606, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3611, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SheetMusicId._Automaton = _BuildAutomaton_59()




SimpleProfileMessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageThreadId'), pyxb.binding.datatypes.string, scope=SimpleProfileMessageHeader, documentation='A string used to uniquely identify the thread of Messages of which the current Message is a part.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3663, 12)))

SimpleProfileMessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageId'), pyxb.binding.datatypes.string, scope=SimpleProfileMessageHeader, documentation='A string used to uniquely identify the current Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3668, 12)))

SimpleProfileMessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageFileName'), pyxb.binding.datatypes.string, scope=SimpleProfileMessageHeader, documentation='The FileName, possibly including the FilePath, of the XML File containing the current Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3673, 12)))

SimpleProfileMessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageSender'), SimpleProfileMessagingParty, scope=SimpleProfileMessageHeader, documentation='A Composite containing details of the MessageSender.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3678, 12)))

SimpleProfileMessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageRecipient'), SimpleProfileMessagingParty, scope=SimpleProfileMessageHeader, documentation='A Composite containing details of the MessageRecipient.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3683, 12)))

SimpleProfileMessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageCreatedDateTime'), pyxb.binding.datatypes.dateTime, scope=SimpleProfileMessageHeader, documentation='The DateTime on which the Message was created (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3688, 12)))

SimpleProfileMessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Comment'), Comment, scope=SimpleProfileMessageHeader, documentation='A Composite containing a human-readable Comment about the Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3693, 12)))

SimpleProfileMessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageControlType'), _ImportedBinding__ddex.MessageControlType, scope=SimpleProfileMessageHeader, documentation='The indicator used to distinguish a live Message from a test Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3698, 12)))

def _BuildAutomaton_60 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_60
    del _BuildAutomaton_60
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3673, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3693, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3698, 12))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageThreadId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3663, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3668, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageFileName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3673, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageSender')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3678, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageRecipient')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3683, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageCreatedDateTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3688, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'Comment')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3693, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageControlType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3698, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SimpleProfileMessageHeader._Automaton = _BuildAutomaton_60()




SimpleProfileMessagingParty._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=SimpleProfileMessagingParty, documentation='A Composite containing details of the PartyId for the Party handling the Message. If no Namespace is given, the Identifier is a DdexPartyId (DPID). Note that DPIDs are not normally used to identify Artists, Producers or other Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3715, 12)))

SimpleProfileMessagingParty._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), SimpleProfilePartyName, scope=SimpleProfileMessagingParty, documentation='A Composite containing details of the PartyNames for the Party handling the Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3720, 12)))

def _BuildAutomaton_61 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_61
    del _BuildAutomaton_61
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3720, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessagingParty._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3715, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SimpleProfileMessagingParty._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3720, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SimpleProfileMessagingParty._Automaton = _BuildAutomaton_61()




SimpleProfilePartyDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=SimpleProfilePartyDescriptor, documentation='A Composite containing details of the PartyId for the Party. If no Namespace is given, the Identifier is a DdexPartyId (DPID). Note that DPIDs are not normally used to identify Artists, Producers or other Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3737, 12)))

SimpleProfilePartyDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), SimpleProfilePartyName, scope=SimpleProfilePartyDescriptor, documentation='A Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3743, 16)))

def _BuildAutomaton_62 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_62
    del _BuildAutomaton_62
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3748, 16))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SimpleProfilePartyDescriptor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3737, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SimpleProfilePartyDescriptor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3743, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SimpleProfilePartyDescriptor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3748, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SimpleProfilePartyDescriptor._Automaton = _BuildAutomaton_62()




SimpleProfilePartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FullName'), Name, scope=SimpleProfilePartyName, documentation='A Composite containing the complete Name of the Party, in its normal form of presentation (e.g. John H. Smith, Acme Music Inc, A Composite containing the Beatles).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3761, 12)))

def _BuildAutomaton_63 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_63
    del _BuildAutomaton_63
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SimpleProfilePartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'FullName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3761, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SimpleProfilePartyName._Automaton = _BuildAutomaton_63()




SocietyAffiliation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=SocietyAffiliation, documentation='A Territory to which the affiliation details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3800, 16)))

SocietyAffiliation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=SocietyAffiliation, documentation='A Territory to which the affiliation details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3805, 16)))

SocietyAffiliation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicRightsSociety'), PartyDescriptor, scope=SocietyAffiliation, documentation='A Composite containing details of a MusicRightsSociety.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3811, 12)))

def _BuildAutomaton_64 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_64
    del _BuildAutomaton_64
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SocietyAffiliation._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3800, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SocietyAffiliation._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3805, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SocietyAffiliation._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicRightsSociety')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3811, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SocietyAffiliation._Automaton = _BuildAutomaton_64()




Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoftwareType'), SoftwareType, scope=Software, documentation='A Composite containing details of the Type of the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3823, 12)))

Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), pyxb.binding.datatypes.boolean, scope=Software, documentation='The Flag indicating whether the Software is related to an Artist (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3828, 12)))

Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoftwareId'), SoftwareId, scope=Software, documentation='A Composite containing details of Identifiers of the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3833, 12)))

Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectSoftwareId'), MusicalWorkId, scope=Software, documentation='A Composite containing details of a MusicalWorkId of a MusicalWork used in the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3838, 12)))

Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReference'), _ImportedBinding__ddex.LocalResourceAnchor, scope=Software, documentation='The Identifier (specific to the Message) of the Software within the Release which contains it. This LocalAnchor is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3843, 12)))

Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), ResourceMusicalWorkReferenceList, scope=Software, documentation='A Composite containing details of one or more MusicalWorks contained in the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3848, 12)))

Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), ResourceContainedResourceReferenceList, scope=Software, documentation='A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3853, 12)))

Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=Software, documentation='A Composite containing details of a Title of the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3858, 12)))

Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CreationDate'), EventDate, scope=Software, documentation='A Composite containing details of the Date and Place of the Event in which the Software was created.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3863, 12)))

Software._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoftwareDetailsByTerritory'), SoftwareDetailsByTerritory, scope=Software, documentation='A Composite containing details of the Software which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3868, 12)))

def _BuildAutomaton_65 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_65
    del _BuildAutomaton_65
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3823, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3828, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3838, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3848, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3853, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3858, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3863, 12))
    counters.add(cc_6)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'SoftwareType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3823, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'IsArtistRelated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3828, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'SoftwareId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3833, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectSoftwareId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3838, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3843, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3848, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3853, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3858, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'CreationDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3863, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Software._UseForTag(pyxb.namespace.ExpandedName(None, 'SoftwareDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3868, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Software._Automaton = _BuildAutomaton_65()




SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=SoftwareDetailsByTerritory, documentation='A Territory to which the Software details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3886, 16)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=SoftwareDetailsByTerritory, documentation='A Territory to which the Software details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3891, 16)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=SoftwareDetailsByTerritory, documentation='A Composite containing details of a Contributor to the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3897, 12)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=SoftwareDetailsByTerritory, documentation='A Composite containing details of an indirect Contributor to the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3902, 12)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLine'), PLine, scope=SoftwareDetailsByTerritory, documentation='A Composite containing details of the PLine for the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3907, 12)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=SoftwareDetailsByTerritory, documentation='A Composite containing details of the CLine for the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3912, 12)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), CourtesyLine, scope=SoftwareDetailsByTerritory, documentation='A Composite containing an Annotation which acknowledges record companies and/or other Parties giving permission for Artists or others featured in the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3917, 12)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=SoftwareDetailsByTerritory, documentation='A Composite containing details of the Date and Place of the Event in which the Software was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3922, 12)))

def _BuildAutomaton_66 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_66
    del _BuildAutomaton_66
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3897, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3902, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3907, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3912, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3917, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3922, 12))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3886, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3891, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3897, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3902, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'PLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3907, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3912, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CourtesyLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3917, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3922, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoftwareDetailsByTerritory._Automaton = _BuildAutomaton_66()




SoftwareId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=SoftwareId, documentation='A Composite containing details of a ProprietaryIdentifier of the Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3939, 12)))

def _BuildAutomaton_67 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_67
    del _BuildAutomaton_67
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoftwareId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3939, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoftwareId._Automaton = _BuildAutomaton_67()




SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoundRecordingType'), SoundRecordingType, scope=SoundRecording, documentation='A Composite containing details of the Type of the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3994, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), pyxb.binding.datatypes.boolean, scope=SoundRecording, documentation='The Flag indicating whether the SoundRecording is related to an Artist (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3999, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoundRecordingId'), SoundRecordingId, scope=SoundRecording, documentation='A Composite containing details of SoundRecordingIds.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4004, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectSoundRecordingId'), MusicalWorkId, scope=SoundRecording, documentation='A Composite containing details of a MusicalWorkId of a MusicalWork used in the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4009, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReference'), _ImportedBinding__ddex.LocalResourceAnchor, scope=SoundRecording, documentation='The Identifier (specific to the Message) of the SoundRecording within the Release which contains it. This LocalAnchor is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4014, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=SoundRecording, documentation='A Composite containing details of the ReferenceTitle of the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4019, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'InstrumentationDescription'), Description, scope=SoundRecording, documentation='A Composite containing a Description of the Type of instrumentation of the MusicalWork(s) in the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4024, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsMedley'), pyxb.binding.datatypes.boolean, scope=SoundRecording, documentation='The Flag indicating whether the SoundRecording is a Medley (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4029, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsPotpourri'), pyxb.binding.datatypes.boolean, scope=SoundRecording, documentation='The Flag indicating whether the SoundRecording is a Potpourri (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4034, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsInstrumental'), pyxb.binding.datatypes.boolean, scope=SoundRecording, documentation='The Flag indicating whether the SoundRecording is instrumental (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4039, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsBackground'), pyxb.binding.datatypes.boolean, scope=SoundRecording, documentation='The Flag indicating whether the SoundRecording is used as background to other audio or audiovisual material (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4044, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsHiddenResource'), pyxb.binding.datatypes.boolean, scope=SoundRecording, documentation='The Flag indicating whether the SoundRecording is hidden in some way from the Consumer (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4049, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsBonusResource'), pyxb.binding.datatypes.boolean, scope=SoundRecording, documentation='The Flag indicating whether the SoundRecording is additional to those on the original Release of which this is a Version (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4054, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsComputerGenerated'), pyxb.binding.datatypes.boolean, scope=SoundRecording, documentation='The Flag indicating whether the SoundRecording is generated by a computer (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4059, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LanguageOfPerformance'), _ImportedBinding__iso639a2.LanguageCode, scope=SoundRecording, documentation='The Language of the Performance recorded in the SoundRecording (represented by an ISO 639-2 LanguageCode).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4064, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=SoundRecording, documentation='The Duration of the SoundRecording (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4069, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=SoundRecording, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4074, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), ResourceMusicalWorkReferenceList, scope=SoundRecording, documentation='A Composite containing details of one or more MusicalWorks contained in the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4079, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), ResourceContainedResourceReferenceList, scope=SoundRecording, documentation='A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4084, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CreationDate'), EventDate, scope=SoundRecording, documentation='A Composite containing details of the Date and Place of the Event in which the SoundRecording was created.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4089, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MasteredDate'), EventDate, scope=SoundRecording, documentation='A Composite containing details of the Date and Place of the Event in which the SoundRecording was originally mastered (either in analogue or digital form).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4094, 12)))

SoundRecording._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoundRecordingDetailsByTerritory'), SoundRecordingDetailsByTerritory, scope=SoundRecording, documentation='A Composite containing details of Descriptors and other attributes of the SoundRecording which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4099, 12)))

def _BuildAutomaton_68 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_68
    del _BuildAutomaton_68
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3994, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3999, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4009, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4024, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4029, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4034, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4039, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4044, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4049, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4054, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4059, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4064, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4074, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4079, 12))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4084, 12))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4089, 12))
    counters.add(cc_15)
    cc_16 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4094, 12))
    counters.add(cc_16)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'SoundRecordingType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3994, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'IsArtistRelated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3999, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'SoundRecordingId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4004, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectSoundRecordingId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4009, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4014, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4019, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'InstrumentationDescription')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4024, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'IsMedley')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4029, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'IsPotpourri')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4034, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'IsInstrumental')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4039, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'IsBackground')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4044, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'IsHiddenResource')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4049, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'IsBonusResource')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4054, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'IsComputerGenerated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4059, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'LanguageOfPerformance')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4064, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4069, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4074, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4079, 12))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4084, 12))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'CreationDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4089, 12))
    st_19 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_19)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'MasteredDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4094, 12))
    st_20 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_20)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoundRecording._UseForTag(pyxb.namespace.ExpandedName(None, 'SoundRecordingDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4099, 12))
    st_21 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_21)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    transitions.append(fac.Transition(st_19, [
         ]))
    transitions.append(fac.Transition(st_20, [
         ]))
    transitions.append(fac.Transition(st_21, [
         ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_18._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_15, True) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_15, False) ]))
    st_19._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_16, True) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_16, False) ]))
    st_20._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_21, [
         ]))
    st_21._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoundRecording._Automaton = _BuildAutomaton_68()




SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), pyxb.binding.datatypes.integer, scope=SoundRecordingCollectionReference, documentation='The number indicating the order of the Collection in a group of Collections within a Medley, SoundRecording or other Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4116, 12)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference'), _ImportedBinding__ddex.LocalCollectionAnchorReference, scope=SoundRecordingCollectionReference, documentation='A Reference for a Collection (specific to this Message). This LocalAnchorReference is a string starting with the letter X. The referenced Collection has to be of CollectionType Series, Season or Episode.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4121, 12)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartTime'), pyxb.binding.datatypes.duration, scope=SoundRecordingCollectionReference, documentation='The start time of the Creation, measured from the start of the Resource from which the CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4126, 12)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=SoundRecordingCollectionReference, documentation='The Duration of the use of the Creation that is referenced in the CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4131, 12)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndTime'), pyxb.binding.datatypes.duration, scope=SoundRecordingCollectionReference, documentation='The end time of the Creation, measured from the start of the Resource from which the CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4136, 12)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType'), _ImportedBinding__ddex.ReleaseResourceType, scope=SoundRecordingCollectionReference, documentation='A Type of Collection in the context of a Video. This is represented in an XML schema as an XML Attribute.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4141, 12)))

def _BuildAutomaton_69 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_69
    del _BuildAutomaton_69
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4116, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4126, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4131, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4136, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4141, 12))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'SequenceNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4116, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4121, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'StartTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4126, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4131, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'EndTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4136, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4141, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoundRecordingCollectionReference._Automaton = _BuildAutomaton_69()




SoundRecordingCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), pyxb.binding.datatypes.integer, scope=SoundRecordingCollectionReferenceList, documentation='The number of referenced Collections (typically Chapters).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4153, 12)))

SoundRecordingCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference'), SoundRecordingCollectionReference, scope=SoundRecordingCollectionReferenceList, documentation='A Composite containing a SoundRecordingCollectionReference for a Collection (specific to this Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4158, 12)))

def _BuildAutomaton_70 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_70
    del _BuildAutomaton_70
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4153, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'NumberOfCollections')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4153, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4158, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoundRecordingCollectionReferenceList._Automaton = _BuildAutomaton_70()




SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=SoundRecordingDetailsByTerritory, documentation='A Territory to which the SoundRecording details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4171, 16)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=SoundRecordingDetailsByTerritory, documentation='A Territory to which the SoundRecording details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4176, 16)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing details of a Title of the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4182, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), DisplayArtist, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing details of the DisplayArtist for the SoundRecording. The DisplayArtist may be described through Name, Identifier and Roles.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4187, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing details of a Contributor to the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4192, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing details of an indirect Contributor to the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4197, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4202, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LabelName'), Name, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing the Name of the Label under which the Release is to be marketed.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4207, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsController'), RightsController, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing details of RightsController of Rights in the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4212, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), EventDate, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing details of the Date and Place of the Event in which the SoundRecording was re-mastered (usually digitally).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4217, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing details of the Date and Place of the Event in which the SoundRecording was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4222, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLine'), PLine, scope=SoundRecordingDetailsByTerritory, documentation='A Composite containing details of the PLine for the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4227, 12)))

def _BuildAutomaton_71 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_71
    del _BuildAutomaton_71
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4182, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4187, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4192, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4197, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4202, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4207, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4212, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4217, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4222, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4227, 12))
    counters.add(cc_9)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4171, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4176, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4182, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4187, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4192, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4197, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4202, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4207, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsController')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4212, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RemasteredDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4217, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4222, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'PLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4227, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoundRecordingDetailsByTerritory._Automaton = _BuildAutomaton_71()




SoundRecordingId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=SoundRecordingId, documentation='The ISRC (International Standard Recording Code as defined in ISO 3901) for the SoundRecording. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4244, 12)))

SoundRecordingId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=SoundRecordingId, documentation='A Composite containing details of the CatalogNumber of the SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4249, 12)))

SoundRecordingId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=SoundRecordingId, documentation='A Composite containing details of a ProprietaryIdentifier of the SoundRecording (usually one per society involved in the messaging).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4254, 12)))

def _BuildAutomaton_72 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_72
    del _BuildAutomaton_72
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4244, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4249, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4254, 12))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4244, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4249, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4254, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SoundRecordingId._Automaton = _BuildAutomaton_72()




TaxRate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Rate'), pyxb.binding.datatypes.decimal, scope=TaxRate, documentation='The TaxRate as a percentage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4379, 12)))

TaxRate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TaxType'), TaxType, scope=TaxRate, documentation='A Composite containing details of the Type of Tax.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4384, 12)))

TaxRate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TaxScope'), TaxScope, scope=TaxRate, documentation='A Composite containing details of the Type of Tax according to its scope.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4389, 12)))

def _BuildAutomaton_73 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_73
    del _BuildAutomaton_73
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(TaxRate._UseForTag(pyxb.namespace.ExpandedName(None, 'Rate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4379, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(TaxRate._UseForTag(pyxb.namespace.ExpandedName(None, 'TaxType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4384, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(TaxRate._UseForTag(pyxb.namespace.ExpandedName(None, 'TaxScope')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4389, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
TaxRate._Automaton = _BuildAutomaton_73()




TechnicalInstantiation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DrmEnforcementType'), _ImportedBinding__ddex.DrmEnforcementType, scope=TechnicalInstantiation, documentation='A Type of DRM enforcement.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4439, 12)))

TechnicalInstantiation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VideoDefinitionType'), _ImportedBinding__ddex.VideoDefinitionType, scope=TechnicalInstantiation, documentation='A Type of resolution (or definition) in which a Video is provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4444, 12)))

TechnicalInstantiation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CodingType'), _ImportedBinding__ddex.CodingType, scope=TechnicalInstantiation, documentation='A Type of coding used to encode a Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4449, 12)))

TechnicalInstantiation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'BitRate'), BitRate, scope=TechnicalInstantiation, documentation='A Composite containing the BitRate for the audio data and a UnitOfMeasure (the default is kbps).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4454, 12)))

def _BuildAutomaton_74 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_74
    del _BuildAutomaton_74
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4439, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4444, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4449, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4454, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(TechnicalInstantiation._UseForTag(pyxb.namespace.ExpandedName(None, 'DrmEnforcementType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4439, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(TechnicalInstantiation._UseForTag(pyxb.namespace.ExpandedName(None, 'VideoDefinitionType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4444, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(TechnicalInstantiation._UseForTag(pyxb.namespace.ExpandedName(None, 'CodingType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4449, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(TechnicalInstantiation._UseForTag(pyxb.namespace.ExpandedName(None, 'BitRate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4454, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
TechnicalInstantiation._Automaton = _BuildAutomaton_74()




Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TextType'), TextType, scope=Text, documentation='A Composite containing details of the Type of the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4472, 12)))

Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), pyxb.binding.datatypes.boolean, scope=Text, documentation='The Flag indicating whether the Text is related to an Artist (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4477, 12)))

Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TextId'), TextId, scope=Text, documentation='A Composite containing details of an Identifier of the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4482, 12)))

Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectTextId'), MusicalWorkId, scope=Text, documentation='A Composite containing details of a MusicalWorkId of a MusicalWork used in the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4487, 12)))

Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReference'), _ImportedBinding__ddex.LocalResourceAnchor, scope=Text, documentation='The Identifier (specific to the Message) of the Text within the Release which contains it. This LocalAnchor is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4492, 12)))

Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), ResourceMusicalWorkReferenceList, scope=Text, documentation='A Composite containing details of one or more MusicalWorks contained in the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4497, 12)))

Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), ResourceContainedResourceReferenceList, scope=Text, documentation='A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4502, 12)))

Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=Text, documentation='A Composite containing details of a Title of the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4507, 12)))

Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CreationDate'), EventDate, scope=Text, documentation='A Composite containing details of the Date and Place of the Event in which the Text was created.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4512, 12)))

Text._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TextDetailsByTerritory'), TextDetailsByTerritory, scope=Text, documentation='A Composite containing details of the Text which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4517, 12)))

def _BuildAutomaton_75 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_75
    del _BuildAutomaton_75
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4472, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4477, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4482, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4487, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4497, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4502, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4507, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4512, 12))
    counters.add(cc_7)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'TextType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4472, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'IsArtistRelated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4477, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'TextId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4482, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectTextId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4487, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4492, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4497, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4502, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4507, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'CreationDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4512, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Text._UseForTag(pyxb.namespace.ExpandedName(None, 'TextDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4517, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Text._Automaton = _BuildAutomaton_75()




TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=TextDetailsByTerritory, documentation='A Territory to which the Text details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4559, 16)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=TextDetailsByTerritory, documentation='A Territory to which the Text details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4564, 16)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=TextDetailsByTerritory, documentation='A Composite containing details of a Contributor to the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4570, 12)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=TextDetailsByTerritory, documentation='A Composite containing details of an indirect Contributor to the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4575, 12)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=TextDetailsByTerritory, documentation='A Composite containing details of the CLine for the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4580, 12)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), CourtesyLine, scope=TextDetailsByTerritory, documentation='A Composite containing an Annotation which acknowledges record companies and/or other Parties giving permission for Artists or others featured in the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4585, 12)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=TextDetailsByTerritory, documentation='A Composite containing details of the Date and Place of the Event in which the Text was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4590, 12)))

def _BuildAutomaton_76 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_76
    del _BuildAutomaton_76
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4570, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4575, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4580, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4585, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4590, 12))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4559, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4564, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4570, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4575, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4580, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CourtesyLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4585, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4590, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
TextDetailsByTerritory._Automaton = _BuildAutomaton_76()




TextId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISBN'), pyxb.binding.datatypes.string, scope=TextId, documentation='The ISBN (International Standard Book Number defined in ISO 2108) for the Text. An ISBN is a 13-digit number. Pre-2007, ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix "978" and re-calculating the check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4607, 12)))

TextId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISSN'), pyxb.binding.datatypes.string, scope=TextId, documentation='The ISSN (International Standard Serial Number defined in ISO 3297) identifying the Text. An ISSN comprises two groups of four digits, separated by a hyphen and a control digit.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4612, 12)))

TextId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SICI'), _ImportedBinding__ddex.SICI, scope=TextId, documentation='The SICI (Serial Item and Contribution Identifier defined in ANSI/NISO Z39.56-199) for the Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4617, 12)))

TextId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=TextId, documentation='A Composite containing details of a ProprietaryIdentifier of the Text (usually one per society involved in the messaging).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4622, 12)))

def _BuildAutomaton_77 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_77
    del _BuildAutomaton_77
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4607, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4612, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4617, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4622, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(TextId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISBN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4607, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(TextId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISSN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4612, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(TextId._UseForTag(pyxb.namespace.ExpandedName(None, 'SICI')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4617, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(TextId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4622, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
TextId._Automaton = _BuildAutomaton_77()




TotalRoyaltyAmount._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseType'), ReleaseType, scope=TotalRoyaltyAmount, documentation='A Composite containing details of the ReleaseType for which the RoyaltyAmount is calculated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4694, 12)))

TotalRoyaltyAmount._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsType'), RightsType, scope=TotalRoyaltyAmount, documentation='A Composite containing details of the RightsType for which the RoyaltyAmount is calculated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4699, 12)))

TotalRoyaltyAmount._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RoyaltyAmount'), RoyaltyAmount, scope=TotalRoyaltyAmount, documentation='A Composite containing details of the RoyaltyAmount due.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4704, 12)))

def _BuildAutomaton_78 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_78
    del _BuildAutomaton_78
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4694, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4699, 12))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(TotalRoyaltyAmount._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4694, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(TotalRoyaltyAmount._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4699, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(TotalRoyaltyAmount._UseForTag(pyxb.namespace.ExpandedName(None, 'RoyaltyAmount')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4704, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
TotalRoyaltyAmount._Automaton = _BuildAutomaton_78()




Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=Usage, documentation='A Composite containing details of a nature of a Service, or a Release, as used by a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4716, 12)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=Usage, documentation='A Composite containing details of a physical interface by which a Consumer is intended to use a Service or Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4721, 12)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=Usage, documentation='A Composite containing details of a distribution channel intended to be used to disseminate a Service or Release to a Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4726, 12)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=Usage, documentation='A Composite containing details of a Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4731, 12)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TechnicalInstantiation'), TechnicalInstantiation, scope=Usage, documentation='A Composite containing technical details of the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4736, 12)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NumberOfUsages'), pyxb.binding.datatypes.integer, scope=Usage, documentation='The number of times a Release can be used under the terms of the Deal.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4741, 12)))

def _BuildAutomaton_79 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_79
    del _BuildAutomaton_79
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4721, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4726, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4731, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4736, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4741, 12))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4716, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4721, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4726, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4731, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'TechnicalInstantiation')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4736, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'NumberOfUsages')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4741, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Usage._Automaton = _BuildAutomaton_79()




UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserDefinedResourceType'), UserDefinedResourceType, scope=UserDefinedResource, documentation='A Composite containing details of the Type of the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4753, 12)))

UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), pyxb.binding.datatypes.boolean, scope=UserDefinedResource, documentation='The Flag indicating whether the UserDefinedResource is related to an Artist (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4758, 12)))

UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserDefinedResourceId'), UserDefinedResourceId, scope=UserDefinedResource, documentation='A Composite containing details of Identifiers of the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4763, 12)))

UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectUserDefinedResourceId'), MusicalWorkId, scope=UserDefinedResource, documentation='A Composite containing details of a MusicalWorkId of a MusicalWork used in the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4768, 12)))

UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReference'), _ImportedBinding__ddex.LocalResourceAnchor, scope=UserDefinedResource, documentation='The Identifier (specific to the Message) of the UserDefinedResource within the Release which contains it. This LocalAnchor is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4773, 12)))

UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), ResourceMusicalWorkReferenceList, scope=UserDefinedResource, documentation='A Composite containing details of one or more MusicalWorks contained in the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4778, 12)))

UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), ResourceContainedResourceReferenceList, scope=UserDefinedResource, documentation='A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4783, 12)))

UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=UserDefinedResource, documentation='A Composite containing details of a Title of the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4788, 12)))

UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), UserDefinedValue, scope=UserDefinedResource, documentation='A Composite containing details of a UserDefinedValue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4793, 12)))

UserDefinedResource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserDefinedResourceDetailsByTerritory'), UserDefinedResourceDetailsByTerritory, scope=UserDefinedResource, documentation='A Composite containing details of the UserDefinedResource which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4798, 12)))

def _BuildAutomaton_80 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_80
    del _BuildAutomaton_80
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4753, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4758, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4768, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4778, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4783, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4788, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4793, 12))
    counters.add(cc_6)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'UserDefinedResourceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4753, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'IsArtistRelated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4758, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'UserDefinedResourceId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4763, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectUserDefinedResourceId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4768, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4773, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4778, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4783, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4788, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'UserDefinedValue')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4793, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(UserDefinedResource._UseForTag(pyxb.namespace.ExpandedName(None, 'UserDefinedResourceDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4798, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
UserDefinedResource._Automaton = _BuildAutomaton_80()




UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=UserDefinedResourceDetailsByTerritory, documentation='A Territory to which the UserDefinedResource details apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4816, 16)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=UserDefinedResourceDetailsByTerritory, documentation='A Territory to which the UserDefinedResource details do not apply (represented by an ISO 3166-1 TerritoryCode). Either this Element or Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4821, 16)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=UserDefinedResourceDetailsByTerritory, documentation='A Composite containing details of a Contributor to the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4827, 12)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=UserDefinedResourceDetailsByTerritory, documentation='A Composite containing details of an indirect Contributor to the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4832, 12)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), UserDefinedValue, scope=UserDefinedResourceDetailsByTerritory, documentation='A Composite containing details of a UserDefinedValue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4837, 12)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLine'), PLine, scope=UserDefinedResourceDetailsByTerritory, documentation='A Composite containing details of the PLine for the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4842, 12)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=UserDefinedResourceDetailsByTerritory, documentation='A Composite containing details of the CLine for the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4847, 12)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=UserDefinedResourceDetailsByTerritory, documentation='A Composite containing details of the Date and Place of the Event in which the UserDefinedResource was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4852, 12)))

def _BuildAutomaton_81 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_81
    del _BuildAutomaton_81
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4827, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4832, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4837, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4842, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4847, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4852, 12))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4816, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4821, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4827, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4832, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'UserDefinedValue')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4837, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'PLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4842, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4847, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4852, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
UserDefinedResourceDetailsByTerritory._Automaton = _BuildAutomaton_81()




UserDefinedResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=UserDefinedResourceId, documentation='A Composite containing details of a ProprietaryIdentifier of the UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4869, 12)))

def _BuildAutomaton_82 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_82
    del _BuildAutomaton_82
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4869, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
UserDefinedResourceId._Automaton = _BuildAutomaton_82()




Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VideoType'), VideoType, scope=Video, documentation='A Composite containing details of the Type of the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4957, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsArtistRelated'), pyxb.binding.datatypes.boolean, scope=Video, documentation='The Flag indicating whether the Video is related to an Artist (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4962, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VideoId'), VideoId, scope=Video, documentation='A Composite containing details of an Identifier of the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4967, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectVideoId'), MusicalWorkId, scope=Video, documentation='A Composite containing details of a MusicalWorkId of a MusicalWork used in the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4972, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReference'), _ImportedBinding__ddex.LocalResourceAnchor, scope=Video, documentation='The Identifier (specific to the Message) of the Video within the Release which contains it. This LocalAnchor is a string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4977, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=Video, documentation='A Composite containing details of the ReferenceTitle of the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4982, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=Video, documentation='A Composite containing details of a Title of the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4987, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'InstrumentationDescription'), Description, scope=Video, documentation='A Composite containing a Description of the Type of instrumentation of the MusicalWork(s) in the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4992, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsMedley'), pyxb.binding.datatypes.boolean, scope=Video, documentation='The Flag indicating whether the Video is a Medley (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4997, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsPotpourri'), pyxb.binding.datatypes.boolean, scope=Video, documentation='The Flag indicating whether the Video is a Potpourri (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5002, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsInstrumental'), pyxb.binding.datatypes.boolean, scope=Video, documentation='The Flag indicating whether the Video is instrumental (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5007, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsBackground'), pyxb.binding.datatypes.boolean, scope=Video, documentation='The Flag indicating whether the Video is used as background to other audio or audiovisual material (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5012, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsHiddenResource'), pyxb.binding.datatypes.boolean, scope=Video, documentation='The Flag indicating whether the Video is hidden in some way from the Consumer (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5017, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsBonusResource'), pyxb.binding.datatypes.boolean, scope=Video, documentation='The Flag indicating whether the Video is additional to those on the original Release of which this is a Version (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5022, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LanguageOfPerformance'), _ImportedBinding__iso639a2.LanguageCode, scope=Video, documentation='The Language of the Performance recorded in the Video (represented by an ISO 639-2 LanguageCode).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5027, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=Video, documentation='The Duration of the Video (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5032, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=Video, documentation='A Composite containing details of Identifiers of a License, Claim, RightShare or contract for the MusicalWork(s) used in the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5037, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList'), ResourceMusicalWorkReferenceList, scope=Video, documentation='A Composite containing details of one or more MusicalWorks contained in the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5042, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList'), ResourceContainedResourceReferenceList, scope=Video, documentation='A Composite containing details of ResourceContainedResourceReferences referring to a Resource that is contained in the current Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5047, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CreationDate'), EventDate, scope=Video, documentation='A Composite containing details of the Date and Place of the Event in which the Video was created.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5052, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MasteredDate'), EventDate, scope=Video, documentation='A Composite containing details of the Date and Place of the Event in which the Video was originally mastered (either in analogue or digital form).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5057, 12)))

Video._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VideoDetailsByTerritory'), VideoDetailsByTerritory, scope=Video, documentation='A Composite containing details of Descriptors and other attributes of the Video which may vary according to Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5062, 12)))

def _BuildAutomaton_83 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_83
    del _BuildAutomaton_83
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4957, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4962, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4967, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4972, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4987, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4992, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4997, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5002, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5007, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5012, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5017, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5022, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5027, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5037, 12))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5042, 12))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5047, 12))
    counters.add(cc_15)
    cc_16 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5052, 12))
    counters.add(cc_16)
    cc_17 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5057, 12))
    counters.add(cc_17)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'VideoType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4957, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'IsArtistRelated')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4962, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'VideoId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4967, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectVideoId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4972, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4977, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4982, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4987, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'InstrumentationDescription')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4992, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'IsMedley')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4997, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'IsPotpourri')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5002, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'IsInstrumental')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5007, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'IsBackground')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5012, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'IsHiddenResource')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5017, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'IsBonusResource')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5022, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'LanguageOfPerformance')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5027, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5032, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5037, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5042, 12))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5047, 12))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'CreationDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5052, 12))
    st_19 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_19)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'MasteredDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5057, 12))
    st_20 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_20)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Video._UseForTag(pyxb.namespace.ExpandedName(None, 'VideoDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5062, 12))
    st_21 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_21)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    transitions.append(fac.Transition(st_19, [
         ]))
    transitions.append(fac.Transition(st_20, [
         ]))
    transitions.append(fac.Transition(st_21, [
         ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_15, True) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_15, False) ]))
    st_18._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_16, True) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_16, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_16, False) ]))
    st_19._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_17, True) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_17, False) ]))
    st_20._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_21, [
         ]))
    st_21._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Video._Automaton = _BuildAutomaton_83()




VideoCueSheetReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VideoCueSheetReference'), _ImportedBinding__ddex.LocalCueSheetAnchorReference, scope=VideoCueSheetReference, documentation='A Reference for a CueSheet (specific to this Message). This LocalAnchorReference is a string starting with the letter Q.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5103, 12)))

def _BuildAutomaton_84 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_84
    del _BuildAutomaton_84
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoCueSheetReference._UseForTag(pyxb.namespace.ExpandedName(None, 'VideoCueSheetReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5103, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoCueSheetReference._Automaton = _BuildAutomaton_84()




VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=VideoId, documentation='The ISRC (International Standard Recording Code as defined in ISO 3901) for the Video. An ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5131, 12)))

VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISAN'), pyxb.binding.datatypes.string, scope=VideoId, documentation='The ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the Video. An ISAN comprises four blocks of four hexadecimal charaters followed by a check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5136, 12)))

VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VISAN'), pyxb.binding.datatypes.string, scope=VideoId, documentation='The V-ISAN (Version Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the Video. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5141, 12)))

VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=VideoId, documentation='A Composite containing details of the CatalogNumber of the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5146, 12)))

VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=VideoId, documentation='A Composite containing details of a ProprietaryIdentifier of the Video (usually one per society involved in the messaging).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5151, 12)))

def _BuildAutomaton_85 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_85
    del _BuildAutomaton_85
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5131, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5136, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5141, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5146, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5151, 12))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5131, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5136, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'VISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5141, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5146, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5151, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoId._Automaton = _BuildAutomaton_85()




WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PageName'), Name, scope=WebPage, documentation='A Composite containing the Name of the WebPage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5182, 12)))

WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'URL'), pyxb.binding.datatypes.string, scope=WebPage, documentation='A URL of the WebPage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5187, 12)))

WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserName'), pyxb.binding.datatypes.string, scope=WebPage, documentation='An Identifier of a computer user who is granted maintenance access to the WebPage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5192, 12)))

WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Password'), pyxb.binding.datatypes.string, scope=WebPage, documentation='A Password needed to grant a user maintenance access to the WebPage in combination with the UserName.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5197, 12)))

def _BuildAutomaton_86 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_86
    del _BuildAutomaton_86
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5182, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5187, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5192, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5197, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'PageName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5182, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'URL')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5187, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'UserName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5192, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'Password')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5197, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
WebPage._Automaton = _BuildAutomaton_86()




WorkList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWork'), MusicalWork, scope=WorkList, documentation='A Composite containing details of a MusicalWork contained in a Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5209, 12)))

def _BuildAutomaton_87 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_87
    del _BuildAutomaton_87
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(WorkList._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWork')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5209, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
WorkList._Automaton = _BuildAutomaton_87()




def _BuildAutomaton_88 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_88
    del _BuildAutomaton_88
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AdministratingRecordCompany._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AdministratingRecordCompany._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AdministratingRecordCompany._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AdministratingRecordCompany._Automaton = _BuildAutomaton_88()




Character._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=Character, documentation='A Composite containing details of the Name, Identifier and role(s) of a Contributor.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 258, 20)))

def _BuildAutomaton_89 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_89
    del _BuildAutomaton_89
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 258, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Character._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Character._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Character._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Character._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 258, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Character._Automaton = _BuildAutomaton_89()




ContainedReleaseSummary._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RelatedRelease'), RelatedRelease, scope=ContainedReleaseSummary, documentation='A Composite containing details of a Release (or a PhysicalProduct or a DigitalProduct derived from such a Release) which is related to the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 581, 20)))

def _BuildAutomaton_90 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_90
    del _BuildAutomaton_90
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2852, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2857, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 581, 20))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ContainedReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2842, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ContainedReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2847, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ContainedReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2852, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ContainedReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2857, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ContainedReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'RelatedRelease')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 581, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ContainedReleaseSummary._Automaton = _BuildAutomaton_90()




DisplayArtist._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ArtistRole'), ArtistRole, scope=DisplayArtist, documentation='A Composite containing details of a role played by the DisplayArtist in relation to other DisplayArtists.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 796, 20)))

def _BuildAutomaton_91 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_91
    del _BuildAutomaton_91
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 796, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DisplayArtist._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DisplayArtist._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(DisplayArtist._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(DisplayArtist._UseForTag(pyxb.namespace.ExpandedName(None, 'ArtistRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 796, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
DisplayArtist._Automaton = _BuildAutomaton_91()




DSP._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TradingName'), Name, scope=DSP, documentation='A Composite containing a TradingName of the DSP.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 874, 20)))

DSP._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'URL'), pyxb.binding.datatypes.string, scope=DSP, documentation="A URL for the DSP's web site.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 879, 20)))

DSP._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=DSP, documentation='The Territory from which the DSP operates (represented by an ISO 3166-1 TerritoryCode). This Territory may differ from the one in which SalesTransactions occur.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 884, 20)))

def _BuildAutomaton_92 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_92
    del _BuildAutomaton_92
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 874, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 879, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 884, 20))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'TradingName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 874, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'URL')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 879, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 884, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
DSP._Automaton = _BuildAutomaton_92()




IndirectResourceContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributorRole'), MusicalWorkContributorRole, scope=IndirectResourceContributor, documentation='A Composite containing details of a role played by the indirect Contributor.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1406, 20)))

def _BuildAutomaton_93 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_93
    del _BuildAutomaton_93
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1406, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(IndirectResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(IndirectResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(IndirectResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(IndirectResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributorRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1406, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
IndirectResourceContributor._Automaton = _BuildAutomaton_93()




MusicalWorkContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributorRole'), MusicalWorkContributorRole, scope=MusicalWorkContributor, documentation='A Composite containing details of a role played by the Contributor in relation to the MusicalWork. Note: This can be used in a DdexMessage in relation to any Work, Performance or Fixation any of which may form the whole or part of the Resource itself. Example: if an "AssociatedPerformer" is shown as a Contributor to a MusicalWork it refers to a performer of a Resource (e.g. a SoundRecording) expressing the MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1922, 20)))

MusicalWorkContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SocietyAffiliation'), SocietyAffiliation, scope=MusicalWorkContributor, documentation='A Composite containing details of a society affiliation for the MusicalWorkContributor.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1927, 20)))

def _BuildAutomaton_94 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_94
    del _BuildAutomaton_94
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1922, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1927, 20))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributorRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1922, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'SocietyAffiliation')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 1927, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MusicalWorkContributor._Automaton = _BuildAutomaton_94()




ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=ReleaseDetailsByTerritory, documentation='A Composite containing details of a Title of the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2726, 20)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), DisplayArtist, scope=ReleaseDetailsByTerritory, documentation='A Composite containing details of the DisplayArtist for the Release. The DisplayArtist may be described through Name, Identifier and Roles.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2731, 20)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsMultiArtistCompilation'), pyxb.binding.datatypes.boolean, scope=ReleaseDetailsByTerritory, documentation='The Flag indicating whether the Release is a multiartist compilation (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2736, 20)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany'), AdministratingRecordCompany, scope=ReleaseDetailsByTerritory, documentation='A Composite containing details of the AdministratingRecordCompany for the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2741, 20)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseType'), ReleaseType, scope=ReleaseDetailsByTerritory, documentation='A Composite containing details of the form in which a ReleaseCreator anticipates offering the Release to Consumers. This overrides the ReleaseType specified globally for the Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2746, 20)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RelatedRelease'), RelatedRelease, scope=ReleaseDetailsByTerritory, documentation='A Composite containing details of a Release (or a PhysicalProduct or a DigitalProduct derived from such a Release) which is related to this Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2751, 20)))

def _BuildAutomaton_95 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_95
    del _BuildAutomaton_95
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2886, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2891, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2896, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2726, 20))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2736, 20))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2741, 20))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2746, 20))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2751, 20))
    counters.add(cc_7)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2875, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2880, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtistName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2886, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2891, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2896, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2726, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2731, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IsMultiArtistCompilation')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2736, 20))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2741, 20))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2746, 20))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RelatedRelease')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2751, 20))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    st_10._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseDetailsByTerritory._Automaton = _BuildAutomaton_95()




ResourceContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributorRole'), ResourceContributorRole, scope=ResourceContributor, documentation='A Composite containing details of a role played by the Contributor.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3025, 20)))

def _BuildAutomaton_96 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_96
    del _BuildAutomaton_96
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3025, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributorRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3025, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceContributor._Automaton = _BuildAutomaton_96()




RightsController._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsControllerRole'), _ImportedBinding__ddex.RightsControllerRole, scope=RightsController, documentation='A role that describes the Party involved in the administration of Rights.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3204, 20)))

RightsController._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareUnknown'), pyxb.binding.datatypes.boolean, scope=RightsController, documentation='The Flag indicating whether the RightSharePercentage is unknown (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3210, 24)))

RightsController._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightSharePercentage'), pyxb.binding.datatypes.string, scope=RightsController, documentation='The share of the licensed Rights owned by the RightsController. RightShare information is given as a decimal value (e.g. "0.125" represents 12.5%). If no information is given, 100% is assumed.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3215, 24)))

def _BuildAutomaton_97 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_97
    del _BuildAutomaton_97
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3204, 20))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2162, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2168, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 2173, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsControllerRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3204, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareUnknown')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3210, 24))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'RightSharePercentage')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3215, 24))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RightsController._Automaton = _BuildAutomaton_97()




SimpleProfileDisplayArtist._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ArtistRole'), ArtistRole, scope=SimpleProfileDisplayArtist, documentation='A Composite containing details of a role played by the DisplayArtist in relation to other DisplayArtists.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3644, 20)))

def _BuildAutomaton_98 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_98
    del _BuildAutomaton_98
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3748, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3644, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SimpleProfileDisplayArtist._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3737, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SimpleProfileDisplayArtist._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3743, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SimpleProfileDisplayArtist._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3748, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SimpleProfileDisplayArtist._UseForTag(pyxb.namespace.ExpandedName(None, 'ArtistRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3644, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SimpleProfileDisplayArtist._Automaton = _BuildAutomaton_98()




SimpleProfileResourceContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributorRole'), ResourceContributorRole, scope=SimpleProfileResourceContributor, documentation='A Composite containing details of a role played by the Contributor.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3780, 20)))

def _BuildAutomaton_99 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_99
    del _BuildAutomaton_99
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3748, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3780, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SimpleProfileResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3737, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SimpleProfileResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3743, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SimpleProfileResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3748, 16))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SimpleProfileResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributorRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 3780, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SimpleProfileResourceContributor._Automaton = _BuildAutomaton_99()




Title._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TitleText'), TitleText, scope=Title, documentation='A Composite containing the text of the Title.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4653, 12)))

Title._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SubTitle'), SubTitle, scope=Title, documentation='A Composite containing details of a SubTitle of the Title, including Titles of Versions used to differentiate different versions of the same Title, as required by the GRId and ISRC ReferenceDescriptiveMetadataSets.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4658, 12)))

def _BuildAutomaton_100 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_100
    del _BuildAutomaton_100
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4658, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Title._UseForTag(pyxb.namespace.ExpandedName(None, 'TitleText')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4653, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Title._UseForTag(pyxb.namespace.ExpandedName(None, 'SubTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4658, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Title._Automaton = _BuildAutomaton_100()




VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=VideoDetailsByTerritory, documentation='A Composite containing details of the CLine for the Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5117, 20)))

def _BuildAutomaton_101 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_101
    del _BuildAutomaton_101
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4182, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4187, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4192, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4197, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4202, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4207, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4212, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4217, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4222, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4227, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5117, 20))
    counters.add(cc_10)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4171, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4176, 16))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4182, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4187, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4192, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4197, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4202, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4207, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsController')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4212, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RemasteredDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4217, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4222, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'PLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 4227, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20100712/ddexC.xsd', 5117, 20))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, True) ]))
    st_12._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoDetailsByTerritory._Automaton = _BuildAutomaton_101()

