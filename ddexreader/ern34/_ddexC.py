# ./_ddexC.py
# -*- coding: utf-8 -*-
# PyXB bindings for NM:ca8e8e08ec1b087b497899d49d0b8f45aa6d91e7
# Generated 2015-07-06 15:44:16.580979 by PyXB version 1.2.4 using Python 2.7.6.final.0
# Namespace http://ddex.net/xml/20120214/ddexC [xmlns:ddexC]

from __future__ import unicode_literals
import pyxb
import pyxb.binding
import pyxb.binding.saxer
import io
import pyxb.utils.utility
import pyxb.utils.domutils
import sys
import pyxb.utils.six as _six

# Unique identifier for bindings created at the same time
_GenerationUID = pyxb.utils.utility.UniqueIdentifier('urn:uuid:cb6895cc-23f5-11e5-aa57-080027960975')

# Version of PyXB used to generate the bindings
_PyXBVersion = '1.2.4'
# Generated bindings are not compatible across PyXB versions
if pyxb.__version__ != _PyXBVersion:
    raise pyxb.PyXBVersionError(_PyXBVersion)

# Import bindings for namespaces imported into schema
import pyxb.binding.datatypes
import _iso3166a2 as _ImportedBinding__iso3166a2
import _iso639a2 as _ImportedBinding__iso639a2
import _ddex as _ImportedBinding__ddex
import _iso4217a as _ImportedBinding__iso4217a

# NOTE: All namespace declarations are reserved within the binding
Namespace = pyxb.namespace.NamespaceForURI('http://ddex.net/xml/20120214/ddexC', create_if_missing=True)
Namespace.configureCategories(['typeBinding', 'elementBinding'])

def CreateFromDocument (xml_text, default_namespace=None, location_base=None):
    """Parse the given XML and use the document element to create a
    Python instance.

    @param xml_text An XML document.  This should be data (Python 2
    str or Python 3 bytes), or a text (Python 2 unicode or Python 3
    str) in the L{pyxb._InputEncoding} encoding.

    @keyword default_namespace The L{pyxb.Namespace} instance to use as the
    default namespace where there is no default namespace in scope.
    If unspecified or C{None}, the namespace of the module containing
    this function will be used.

    @keyword location_base: An object to be recorded as the base of all
    L{pyxb.utils.utility.Location} instances associated with events and
    objects handled by the parser.  You might pass the URI from which
    the document was obtained.
    """

    if pyxb.XMLStyle_saxer != pyxb._XMLStyle:
        dom = pyxb.utils.domutils.StringToDOM(xml_text)
        return CreateFromDOM(dom.documentElement, default_namespace=default_namespace)
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    saxer = pyxb.binding.saxer.make_parser(fallback_namespace=default_namespace, location_base=location_base)
    handler = saxer.getContentHandler()
    xmld = xml_text
    if isinstance(xmld, _six.text_type):
        xmld = xmld.encode(pyxb._InputEncoding)
    saxer.parse(io.BytesIO(xmld))
    instance = handler.rootObject()
    return instance

def CreateFromDOM (node, default_namespace=None):
    """Create a Python instance from the given DOM node.
    The node tag must correspond to an element declaration in this module.

    @deprecated: Forcing use of DOM interface is unnecessary; use L{CreateFromDocument}."""
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    return pyxb.binding.basis.element.AnyCreateFromDOM(node, default_namespace)


# Atomic simple type: [anonymous]
class STD_ANON (pyxb.binding.datatypes.ID):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 424, 12)
    _Documentation = None
STD_ANON._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON._CF_pattern.addPattern(pattern='X[\\d\\-_a-zA-Z]+')
STD_ANON._InitializeFacetMap(STD_ANON._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_ (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 505, 12)
    _Documentation = None
STD_ANON_._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_._CF_pattern.addPattern(pattern='X[\\d\\-_a-zA-Z]+')
STD_ANON_._InitializeFacetMap(STD_ANON_._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_2 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 660, 12)
    _Documentation = None
STD_ANON_2._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_2._CF_pattern.addPattern(pattern='A[\\d\\-_a-zA-Z]+')
STD_ANON_2._InitializeFacetMap(STD_ANON_2._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_3 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 936, 15)
    _Documentation = None
STD_ANON_3._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_3._CF_pattern.addPattern(pattern='W[\\d\\-_a-zA-Z]+')
STD_ANON_3._InitializeFacetMap(STD_ANON_3._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_4 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 946, 15)
    _Documentation = None
STD_ANON_4._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_4._CF_pattern.addPattern(pattern='A[\\d\\-_a-zA-Z]+')
STD_ANON_4._InitializeFacetMap(STD_ANON_4._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_5 (pyxb.binding.datatypes.ID):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 989, 12)
    _Documentation = None
STD_ANON_5._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_5._CF_pattern.addPattern(pattern='Q[\\d\\-_a-zA-Z]+')
STD_ANON_5._InitializeFacetMap(STD_ANON_5._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_6 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1615, 12)
    _Documentation = None
STD_ANON_6._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_6._CF_pattern.addPattern(pattern='R[\\d\\-_a-zA-Z]+')
STD_ANON_6._InitializeFacetMap(STD_ANON_6._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_7 (pyxb.binding.datatypes.ID):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2325, 12)
    _Documentation = None
STD_ANON_7._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_7._CF_pattern.addPattern(pattern='W[\\d\\-_a-zA-Z]+')
STD_ANON_7._InitializeFacetMap(STD_ANON_7._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_8 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3536, 12)
    _Documentation = None
STD_ANON_8._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_8._CF_pattern.addPattern(pattern='A[\\d\\-_a-zA-Z]+')
STD_ANON_8._InitializeFacetMap(STD_ANON_8._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_9 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3637, 12)
    _Documentation = None
STD_ANON_9._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_9._CF_pattern.addPattern(pattern='A[\\d\\-_a-zA-Z]+')
STD_ANON_9._InitializeFacetMap(STD_ANON_9._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_10 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3727, 12)
    _Documentation = None
STD_ANON_10._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_10._CF_pattern.addPattern(pattern='W[\\d\\-_a-zA-Z]+')
STD_ANON_10._InitializeFacetMap(STD_ANON_10._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_11 (pyxb.binding.datatypes.ID):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3800, 12)
    _Documentation = None
STD_ANON_11._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_11._CF_pattern.addPattern(pattern='S[\\d\\-_a-zA-Z]+')
STD_ANON_11._InitializeFacetMap(STD_ANON_11._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_12 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3917, 12)
    _Documentation = None
STD_ANON_12._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_12._CF_pattern.addPattern(pattern='W[\\d\\-_a-zA-Z]+')
STD_ANON_12._InitializeFacetMap(STD_ANON_12._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_13 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3927, 12)
    _Documentation = None
STD_ANON_13._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_13._CF_pattern.addPattern(pattern='A[\\d\\-_a-zA-Z]+')
STD_ANON_13._InitializeFacetMap(STD_ANON_13._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_14 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3937, 12)
    _Documentation = None
STD_ANON_14._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_14._CF_pattern.addPattern(pattern='R[\\d\\-_a-zA-Z]+')
STD_ANON_14._InitializeFacetMap(STD_ANON_14._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_15 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4376, 12)
    _Documentation = None
STD_ANON_15._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_15._CF_pattern.addPattern(pattern='X[\\d\\-_a-zA-Z]+')
STD_ANON_15._InitializeFacetMap(STD_ANON_15._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_16 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5158, 12)
    _Documentation = None
STD_ANON_16._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_16._CF_pattern.addPattern(pattern='Q[\\d\\-_a-zA-Z]+')
STD_ANON_16._InitializeFacetMap(STD_ANON_16._CF_pattern)

# Atomic simple type: [anonymous]
class STD_ANON_17 (pyxb.binding.datatypes.IDREF):

    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5175, 12)
    _Documentation = None
STD_ANON_17._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_17._CF_pattern.addPattern(pattern='Q[\\d\\-_a-zA-Z]+')
STD_ANON_17._InitializeFacetMap(STD_ANON_17._CF_pattern)

# Union simple type: {http://ddex.net/xml/20120214/ddexC}CurrencyCode
# superclasses pyxb.binding.datatypes.anySimpleType
class CurrencyCode (pyxb.binding.basis.STD_union):

    """A code representing a ddex:Currency."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CurrencyCode')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5395, 3)
    _Documentation = 'A code representing a ddex:Currency.'

    _MemberTypes = ( _ImportedBinding__iso4217a.CurrencyCode, _ImportedBinding__ddex.DeprecatedCurrencyCode, )
CurrencyCode._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=CurrencyCode)
CurrencyCode._CF_pattern = pyxb.binding.facets.CF_pattern()
CurrencyCode.AED = 'AED'                          # originally _ImportedBinding__iso4217a.CurrencyCode.AED
CurrencyCode.AFN = 'AFN'                          # originally _ImportedBinding__iso4217a.CurrencyCode.AFN
CurrencyCode.ALL = 'ALL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ALL
CurrencyCode.AMD = 'AMD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.AMD
CurrencyCode.ANG = 'ANG'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ANG
CurrencyCode.AOA = 'AOA'                          # originally _ImportedBinding__iso4217a.CurrencyCode.AOA
CurrencyCode.ARS = 'ARS'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ARS
CurrencyCode.AUD = 'AUD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.AUD
CurrencyCode.AWG = 'AWG'                          # originally _ImportedBinding__iso4217a.CurrencyCode.AWG
CurrencyCode.AZN = 'AZN'                          # originally _ImportedBinding__iso4217a.CurrencyCode.AZN
CurrencyCode.BAM = 'BAM'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BAM
CurrencyCode.BBD = 'BBD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BBD
CurrencyCode.BDT = 'BDT'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BDT
CurrencyCode.BGN = 'BGN'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BGN
CurrencyCode.BHD = 'BHD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BHD
CurrencyCode.BIF = 'BIF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BIF
CurrencyCode.BMD = 'BMD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BMD
CurrencyCode.BND = 'BND'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BND
CurrencyCode.BOB = 'BOB'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BOB
CurrencyCode.BOV = 'BOV'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BOV
CurrencyCode.BRL = 'BRL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BRL
CurrencyCode.BSD = 'BSD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BSD
CurrencyCode.BTN = 'BTN'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BTN
CurrencyCode.BWP = 'BWP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BWP
CurrencyCode.BYR = 'BYR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BYR
CurrencyCode.BZD = 'BZD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.BZD
CurrencyCode.CAD = 'CAD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CAD
CurrencyCode.CDF = 'CDF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CDF
CurrencyCode.CHF = 'CHF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CHF
CurrencyCode.CLF = 'CLF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CLF
CurrencyCode.CLP = 'CLP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CLP
CurrencyCode.CNY = 'CNY'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CNY
CurrencyCode.COP = 'COP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.COP
CurrencyCode.COU = 'COU'                          # originally _ImportedBinding__iso4217a.CurrencyCode.COU
CurrencyCode.CRC = 'CRC'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CRC
CurrencyCode.CUC = 'CUC'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CUC
CurrencyCode.CUP = 'CUP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CUP
CurrencyCode.CVE = 'CVE'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CVE
CurrencyCode.CZK = 'CZK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.CZK
CurrencyCode.DJF = 'DJF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.DJF
CurrencyCode.DKK = 'DKK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.DKK
CurrencyCode.DOP = 'DOP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.DOP
CurrencyCode.DZD = 'DZD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.DZD
CurrencyCode.EEK = 'EEK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.EEK
CurrencyCode.EGP = 'EGP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.EGP
CurrencyCode.ERN = 'ERN'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ERN
CurrencyCode.ETB = 'ETB'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ETB
CurrencyCode.EUR = 'EUR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.EUR
CurrencyCode.FJD = 'FJD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.FJD
CurrencyCode.FKP = 'FKP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.FKP
CurrencyCode.GBP = 'GBP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.GBP
CurrencyCode.GEL = 'GEL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.GEL
CurrencyCode.GHS = 'GHS'                          # originally _ImportedBinding__iso4217a.CurrencyCode.GHS
CurrencyCode.GIP = 'GIP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.GIP
CurrencyCode.GMD = 'GMD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.GMD
CurrencyCode.GNF = 'GNF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.GNF
CurrencyCode.GTQ = 'GTQ'                          # originally _ImportedBinding__iso4217a.CurrencyCode.GTQ
CurrencyCode.GYD = 'GYD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.GYD
CurrencyCode.HKD = 'HKD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.HKD
CurrencyCode.HNL = 'HNL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.HNL
CurrencyCode.HRK = 'HRK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.HRK
CurrencyCode.HTG = 'HTG'                          # originally _ImportedBinding__iso4217a.CurrencyCode.HTG
CurrencyCode.HUF = 'HUF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.HUF
CurrencyCode.IDR = 'IDR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.IDR
CurrencyCode.ILS = 'ILS'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ILS
CurrencyCode.INR = 'INR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.INR
CurrencyCode.IQD = 'IQD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.IQD
CurrencyCode.IRR = 'IRR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.IRR
CurrencyCode.ISK = 'ISK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ISK
CurrencyCode.JMD = 'JMD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.JMD
CurrencyCode.JOD = 'JOD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.JOD
CurrencyCode.JPY = 'JPY'                          # originally _ImportedBinding__iso4217a.CurrencyCode.JPY
CurrencyCode.KES = 'KES'                          # originally _ImportedBinding__iso4217a.CurrencyCode.KES
CurrencyCode.KGS = 'KGS'                          # originally _ImportedBinding__iso4217a.CurrencyCode.KGS
CurrencyCode.KHR = 'KHR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.KHR
CurrencyCode.KMF = 'KMF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.KMF
CurrencyCode.KPW = 'KPW'                          # originally _ImportedBinding__iso4217a.CurrencyCode.KPW
CurrencyCode.KRW = 'KRW'                          # originally _ImportedBinding__iso4217a.CurrencyCode.KRW
CurrencyCode.KWD = 'KWD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.KWD
CurrencyCode.KYD = 'KYD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.KYD
CurrencyCode.KZT = 'KZT'                          # originally _ImportedBinding__iso4217a.CurrencyCode.KZT
CurrencyCode.LAK = 'LAK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.LAK
CurrencyCode.LBP = 'LBP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.LBP
CurrencyCode.LKR = 'LKR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.LKR
CurrencyCode.LRD = 'LRD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.LRD
CurrencyCode.LSL = 'LSL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.LSL
CurrencyCode.LTL = 'LTL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.LTL
CurrencyCode.LVL = 'LVL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.LVL
CurrencyCode.LYD = 'LYD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.LYD
CurrencyCode.MAD = 'MAD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MAD
CurrencyCode.MDL = 'MDL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MDL
CurrencyCode.MGA = 'MGA'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MGA
CurrencyCode.MKD = 'MKD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MKD
CurrencyCode.MMK = 'MMK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MMK
CurrencyCode.MNT = 'MNT'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MNT
CurrencyCode.MOP = 'MOP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MOP
CurrencyCode.MRO = 'MRO'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MRO
CurrencyCode.MUR = 'MUR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MUR
CurrencyCode.MVR = 'MVR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MVR
CurrencyCode.MWK = 'MWK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MWK
CurrencyCode.MXN = 'MXN'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MXN
CurrencyCode.MXV = 'MXV'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MXV
CurrencyCode.MYR = 'MYR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MYR
CurrencyCode.MZM = 'MZM'                          # originally _ImportedBinding__iso4217a.CurrencyCode.MZM
CurrencyCode.NAD = 'NAD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.NAD
CurrencyCode.NGN = 'NGN'                          # originally _ImportedBinding__iso4217a.CurrencyCode.NGN
CurrencyCode.NIO = 'NIO'                          # originally _ImportedBinding__iso4217a.CurrencyCode.NIO
CurrencyCode.NOK = 'NOK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.NOK
CurrencyCode.NPR = 'NPR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.NPR
CurrencyCode.NZD = 'NZD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.NZD
CurrencyCode.OMR = 'OMR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.OMR
CurrencyCode.PAB = 'PAB'                          # originally _ImportedBinding__iso4217a.CurrencyCode.PAB
CurrencyCode.PEN = 'PEN'                          # originally _ImportedBinding__iso4217a.CurrencyCode.PEN
CurrencyCode.PGK = 'PGK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.PGK
CurrencyCode.PHP = 'PHP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.PHP
CurrencyCode.PKR = 'PKR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.PKR
CurrencyCode.PLN = 'PLN'                          # originally _ImportedBinding__iso4217a.CurrencyCode.PLN
CurrencyCode.PYG = 'PYG'                          # originally _ImportedBinding__iso4217a.CurrencyCode.PYG
CurrencyCode.QAR = 'QAR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.QAR
CurrencyCode.RON = 'RON'                          # originally _ImportedBinding__iso4217a.CurrencyCode.RON
CurrencyCode.RSD = 'RSD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.RSD
CurrencyCode.RUB = 'RUB'                          # originally _ImportedBinding__iso4217a.CurrencyCode.RUB
CurrencyCode.RWF = 'RWF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.RWF
CurrencyCode.SAR = 'SAR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SAR
CurrencyCode.SBD = 'SBD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SBD
CurrencyCode.SCR = 'SCR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SCR
CurrencyCode.SDG = 'SDG'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SDG
CurrencyCode.SEK = 'SEK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SEK
CurrencyCode.SGD = 'SGD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SGD
CurrencyCode.SHP = 'SHP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SHP
CurrencyCode.SLL = 'SLL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SLL
CurrencyCode.SOS = 'SOS'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SOS
CurrencyCode.SRD = 'SRD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SRD
CurrencyCode.STD = 'STD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.STD
CurrencyCode.SVC = 'SVC'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SVC
CurrencyCode.SYP = 'SYP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SYP
CurrencyCode.SZL = 'SZL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.SZL
CurrencyCode.THB = 'THB'                          # originally _ImportedBinding__iso4217a.CurrencyCode.THB
CurrencyCode.TJS = 'TJS'                          # originally _ImportedBinding__iso4217a.CurrencyCode.TJS
CurrencyCode.TMT = 'TMT'                          # originally _ImportedBinding__iso4217a.CurrencyCode.TMT
CurrencyCode.TND = 'TND'                          # originally _ImportedBinding__iso4217a.CurrencyCode.TND
CurrencyCode.TOP = 'TOP'                          # originally _ImportedBinding__iso4217a.CurrencyCode.TOP
CurrencyCode.TRY = 'TRY'                          # originally _ImportedBinding__iso4217a.CurrencyCode.TRY
CurrencyCode.TTD = 'TTD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.TTD
CurrencyCode.TWD = 'TWD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.TWD
CurrencyCode.TZS = 'TZS'                          # originally _ImportedBinding__iso4217a.CurrencyCode.TZS
CurrencyCode.UAH = 'UAH'                          # originally _ImportedBinding__iso4217a.CurrencyCode.UAH
CurrencyCode.UGX = 'UGX'                          # originally _ImportedBinding__iso4217a.CurrencyCode.UGX
CurrencyCode.USD = 'USD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.USD
CurrencyCode.UYI = 'UYI'                          # originally _ImportedBinding__iso4217a.CurrencyCode.UYI
CurrencyCode.UYU = 'UYU'                          # originally _ImportedBinding__iso4217a.CurrencyCode.UYU
CurrencyCode.UZS = 'UZS'                          # originally _ImportedBinding__iso4217a.CurrencyCode.UZS
CurrencyCode.VEF = 'VEF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.VEF
CurrencyCode.VND = 'VND'                          # originally _ImportedBinding__iso4217a.CurrencyCode.VND
CurrencyCode.VUV = 'VUV'                          # originally _ImportedBinding__iso4217a.CurrencyCode.VUV
CurrencyCode.WST = 'WST'                          # originally _ImportedBinding__iso4217a.CurrencyCode.WST
CurrencyCode.XAF = 'XAF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.XAF
CurrencyCode.XCD = 'XCD'                          # originally _ImportedBinding__iso4217a.CurrencyCode.XCD
CurrencyCode.XOF = 'XOF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.XOF
CurrencyCode.XPF = 'XPF'                          # originally _ImportedBinding__iso4217a.CurrencyCode.XPF
CurrencyCode.YER = 'YER'                          # originally _ImportedBinding__iso4217a.CurrencyCode.YER
CurrencyCode.ZAR = 'ZAR'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ZAR
CurrencyCode.ZMK = 'ZMK'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ZMK
CurrencyCode.ZWL = 'ZWL'                          # originally _ImportedBinding__iso4217a.CurrencyCode.ZWL
CurrencyCode.CYP = 'CYP'                          # originally _ImportedBinding__ddex.DeprecatedCurrencyCode.CYP
CurrencyCode.MTL = 'MTL'                          # originally _ImportedBinding__ddex.DeprecatedCurrencyCode.MTL
CurrencyCode.ROL = 'ROL'                          # originally _ImportedBinding__ddex.DeprecatedCurrencyCode.ROL
CurrencyCode.SIT = 'SIT'                          # originally _ImportedBinding__ddex.DeprecatedCurrencyCode.SIT
CurrencyCode.SKK = 'SKK'                          # originally _ImportedBinding__ddex.DeprecatedCurrencyCode.SKK
CurrencyCode._InitializeFacetMap(CurrencyCode._CF_enumeration,
   CurrencyCode._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'CurrencyCode', CurrencyCode)

# Union simple type: {http://ddex.net/xml/20120214/ddexC}TerritoryCode
# superclasses pyxb.binding.datatypes.anySimpleType
class TerritoryCode (pyxb.binding.basis.STD_union):

    """A code representing a ddex:Territory. This includes ISO 3166-1 two-letter codes plus a code for ddex:Worldwide."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TerritoryCode')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5401, 3)
    _Documentation = 'A code representing a ddex:Territory. This includes ISO 3166-1 two-letter codes plus a code for ddex:Worldwide.'

    _MemberTypes = ( _ImportedBinding__iso3166a2.TerritoryCode, _ImportedBinding__ddex.NonIsoTerritoryCode, )
TerritoryCode._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=TerritoryCode)
TerritoryCode._CF_pattern = pyxb.binding.facets.CF_pattern()
TerritoryCode.AF = 'AF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AF
TerritoryCode.AX = 'AX'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AX
TerritoryCode.AL = 'AL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AL
TerritoryCode.DZ = 'DZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DZ
TerritoryCode.AD = 'AD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AD
TerritoryCode.AO = 'AO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AO
TerritoryCode.AG = 'AG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AG
TerritoryCode.AR = 'AR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AR
TerritoryCode.AM = 'AM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AM
TerritoryCode.AU = 'AU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AU
TerritoryCode.AT = 'AT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AT
TerritoryCode.AZ = 'AZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AZ
TerritoryCode.BS = 'BS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BS
TerritoryCode.BH = 'BH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BH
TerritoryCode.BD = 'BD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BD
TerritoryCode.BB = 'BB'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BB
TerritoryCode.BY = 'BY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BY
TerritoryCode.BE = 'BE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BE
TerritoryCode.BZ = 'BZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BZ
TerritoryCode.BJ = 'BJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BJ
TerritoryCode.BT = 'BT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BT
TerritoryCode.BO = 'BO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BO
TerritoryCode.BA = 'BA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BA
TerritoryCode.BW = 'BW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BW
TerritoryCode.BR = 'BR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BR
TerritoryCode.BN = 'BN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BN
TerritoryCode.BG = 'BG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BG
TerritoryCode.BF = 'BF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BF
TerritoryCode.BI = 'BI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BI
TerritoryCode.KH = 'KH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KH
TerritoryCode.CM = 'CM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CM
TerritoryCode.CA = 'CA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CA
TerritoryCode.CV = 'CV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CV
TerritoryCode.CF = 'CF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CF
TerritoryCode.TD = 'TD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TD
TerritoryCode.CL = 'CL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CL
TerritoryCode.CN = 'CN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CN
TerritoryCode.CO = 'CO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CO
TerritoryCode.KM = 'KM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KM
TerritoryCode.CG = 'CG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CG
TerritoryCode.CD = 'CD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CD
TerritoryCode.CR = 'CR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CR
TerritoryCode.CI = 'CI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CI
TerritoryCode.HR = 'HR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HR
TerritoryCode.CU = 'CU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CU
TerritoryCode.CY = 'CY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CY
TerritoryCode.CZ = 'CZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CZ
TerritoryCode.DK = 'DK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DK
TerritoryCode.DJ = 'DJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DJ
TerritoryCode.DM = 'DM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DM
TerritoryCode.DO = 'DO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DO
TerritoryCode.TL = 'TL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TL
TerritoryCode.EC = 'EC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.EC
TerritoryCode.EG = 'EG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.EG
TerritoryCode.SV = 'SV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SV
TerritoryCode.GQ = 'GQ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GQ
TerritoryCode.ER = 'ER'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ER
TerritoryCode.EE = 'EE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.EE
TerritoryCode.ET = 'ET'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ET
TerritoryCode.FJ = 'FJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FJ
TerritoryCode.FI = 'FI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FI
TerritoryCode.FR = 'FR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FR
TerritoryCode.GA = 'GA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GA
TerritoryCode.GM = 'GM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GM
TerritoryCode.GE = 'GE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GE
TerritoryCode.DE = 'DE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.DE
TerritoryCode.GH = 'GH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GH
TerritoryCode.GR = 'GR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GR
TerritoryCode.GD = 'GD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GD
TerritoryCode.GT = 'GT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GT
TerritoryCode.GG = 'GG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GG
TerritoryCode.GN = 'GN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GN
TerritoryCode.GW = 'GW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GW
TerritoryCode.GY = 'GY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GY
TerritoryCode.HT = 'HT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HT
TerritoryCode.VA = 'VA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VA
TerritoryCode.HN = 'HN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HN
TerritoryCode.HU = 'HU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HU
TerritoryCode.IS = 'IS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IS
TerritoryCode.IN = 'IN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IN
TerritoryCode.ID = 'ID'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ID
TerritoryCode.IR = 'IR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IR
TerritoryCode.IQ = 'IQ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IQ
TerritoryCode.IE = 'IE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IE
TerritoryCode.IM = 'IM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IM
TerritoryCode.IL = 'IL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IL
TerritoryCode.IT = 'IT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IT
TerritoryCode.JM = 'JM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.JM
TerritoryCode.JP = 'JP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.JP
TerritoryCode.JE = 'JE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.JE
TerritoryCode.JO = 'JO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.JO
TerritoryCode.KZ = 'KZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KZ
TerritoryCode.KE = 'KE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KE
TerritoryCode.KI = 'KI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KI
TerritoryCode.KP = 'KP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KP
TerritoryCode.KR = 'KR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KR
TerritoryCode.KW = 'KW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KW
TerritoryCode.KG = 'KG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KG
TerritoryCode.LA = 'LA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LA
TerritoryCode.LV = 'LV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LV
TerritoryCode.LB = 'LB'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LB
TerritoryCode.LS = 'LS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LS
TerritoryCode.LR = 'LR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LR
TerritoryCode.LY = 'LY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LY
TerritoryCode.LI = 'LI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LI
TerritoryCode.LT = 'LT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LT
TerritoryCode.LU = 'LU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LU
TerritoryCode.MG = 'MG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MG
TerritoryCode.MW = 'MW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MW
TerritoryCode.MY = 'MY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MY
TerritoryCode.MV = 'MV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MV
TerritoryCode.ML = 'ML'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ML
TerritoryCode.MT = 'MT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MT
TerritoryCode.MH = 'MH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MH
TerritoryCode.MR = 'MR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MR
TerritoryCode.MU = 'MU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MU
TerritoryCode.MX = 'MX'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MX
TerritoryCode.FM = 'FM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FM
TerritoryCode.MD = 'MD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MD
TerritoryCode.MC = 'MC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MC
TerritoryCode.MN = 'MN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MN
TerritoryCode.ME = 'ME'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ME
TerritoryCode.MA = 'MA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MA
TerritoryCode.MZ = 'MZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MZ
TerritoryCode.MM = 'MM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MM
TerritoryCode.NA = 'NA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NA
TerritoryCode.NR = 'NR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NR
TerritoryCode.NP = 'NP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NP
TerritoryCode.NL = 'NL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NL
TerritoryCode.NZ = 'NZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NZ
TerritoryCode.NI = 'NI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NI
TerritoryCode.NE = 'NE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NE
TerritoryCode.NG = 'NG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NG
TerritoryCode.NO = 'NO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NO
TerritoryCode.OM = 'OM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.OM
TerritoryCode.PK = 'PK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PK
TerritoryCode.PW = 'PW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PW
TerritoryCode.PA = 'PA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PA
TerritoryCode.PG = 'PG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PG
TerritoryCode.PY = 'PY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PY
TerritoryCode.PE = 'PE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PE
TerritoryCode.PH = 'PH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PH
TerritoryCode.PL = 'PL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PL
TerritoryCode.PT = 'PT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PT
TerritoryCode.QA = 'QA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.QA
TerritoryCode.RO = 'RO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RO
TerritoryCode.RU = 'RU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RU
TerritoryCode.RW = 'RW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RW
TerritoryCode.KN = 'KN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KN
TerritoryCode.LC = 'LC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LC
TerritoryCode.VC = 'VC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VC
TerritoryCode.WS = 'WS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.WS
TerritoryCode.SM = 'SM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SM
TerritoryCode.ST = 'ST'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ST
TerritoryCode.SA = 'SA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SA
TerritoryCode.SN = 'SN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SN
TerritoryCode.RS = 'RS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RS
TerritoryCode.SC = 'SC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SC
TerritoryCode.SL = 'SL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SL
TerritoryCode.SG = 'SG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SG
TerritoryCode.SK = 'SK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SK
TerritoryCode.SI = 'SI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SI
TerritoryCode.SB = 'SB'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SB
TerritoryCode.SO = 'SO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SO
TerritoryCode.ZA = 'ZA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ZA
TerritoryCode.ES = 'ES'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ES
TerritoryCode.LK = 'LK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.LK
TerritoryCode.SD = 'SD'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SD
TerritoryCode.SR = 'SR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SR
TerritoryCode.SZ = 'SZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SZ
TerritoryCode.SE = 'SE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SE
TerritoryCode.CH = 'CH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CH
TerritoryCode.SY = 'SY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SY
TerritoryCode.TJ = 'TJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TJ
TerritoryCode.TZ = 'TZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TZ
TerritoryCode.TH = 'TH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TH
TerritoryCode.MK = 'MK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MK
TerritoryCode.TG = 'TG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TG
TerritoryCode.TO = 'TO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TO
TerritoryCode.TT = 'TT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TT
TerritoryCode.TN = 'TN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TN
TerritoryCode.TR = 'TR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TR
TerritoryCode.TM = 'TM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TM
TerritoryCode.TV = 'TV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TV
TerritoryCode.UG = 'UG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UG
TerritoryCode.UA = 'UA'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UA
TerritoryCode.AE = 'AE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AE
TerritoryCode.GB = 'GB'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GB
TerritoryCode.US = 'US'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.US
TerritoryCode.UY = 'UY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UY
TerritoryCode.UZ = 'UZ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UZ
TerritoryCode.VU = 'VU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VU
TerritoryCode.VE = 'VE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VE
TerritoryCode.VN = 'VN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VN
TerritoryCode.YE = 'YE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.YE
TerritoryCode.ZM = 'ZM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ZM
TerritoryCode.ZW = 'ZW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.ZW
TerritoryCode.AS = 'AS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AS
TerritoryCode.AI = 'AI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AI
TerritoryCode.AQ = 'AQ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AQ
TerritoryCode.AW = 'AW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AW
TerritoryCode.BM = 'BM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BM
TerritoryCode.BV = 'BV'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BV
TerritoryCode.IO = 'IO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.IO
TerritoryCode.KY = 'KY'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.KY
TerritoryCode.CX = 'CX'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CX
TerritoryCode.CC = 'CC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CC
TerritoryCode.CK = 'CK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.CK
TerritoryCode.FK = 'FK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FK
TerritoryCode.FO = 'FO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.FO
TerritoryCode.GF = 'GF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GF
TerritoryCode.PF = 'PF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PF
TerritoryCode.TF = 'TF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TF
TerritoryCode.GI = 'GI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GI
TerritoryCode.GL = 'GL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GL
TerritoryCode.GP = 'GP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GP
TerritoryCode.GU = 'GU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GU
TerritoryCode.HM = 'HM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HM
TerritoryCode.HK = 'HK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.HK
TerritoryCode.MO = 'MO'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MO
TerritoryCode.MQ = 'MQ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MQ
TerritoryCode.YT = 'YT'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.YT
TerritoryCode.MS = 'MS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MS
TerritoryCode.AN = 'AN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.AN
TerritoryCode.NC = 'NC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NC
TerritoryCode.NU = 'NU'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NU
TerritoryCode.NF = 'NF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.NF
TerritoryCode.MP = 'MP'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MP
TerritoryCode.PS = 'PS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PS
TerritoryCode.PN = 'PN'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PN
TerritoryCode.PR = 'PR'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PR
TerritoryCode.RE = 'RE'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.RE
TerritoryCode.BL = 'BL'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.BL
TerritoryCode.SH = 'SH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SH
TerritoryCode.MF = 'MF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.MF
TerritoryCode.PM = 'PM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.PM
TerritoryCode.GS = 'GS'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.GS
TerritoryCode.SJ = 'SJ'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.SJ
TerritoryCode.TW = 'TW'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TW
TerritoryCode.TK = 'TK'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TK
TerritoryCode.TC = 'TC'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.TC
TerritoryCode.UM = 'UM'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.UM
TerritoryCode.VG = 'VG'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VG
TerritoryCode.VI = 'VI'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.VI
TerritoryCode.WF = 'WF'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.WF
TerritoryCode.EH = 'EH'                           # originally _ImportedBinding__iso3166a2.TerritoryCode.EH
TerritoryCode.Worldwide = 'Worldwide'             # originally _ImportedBinding__ddex.NonIsoTerritoryCode.Worldwide
TerritoryCode._InitializeFacetMap(TerritoryCode._CF_enumeration,
   TerritoryCode._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'TerritoryCode', TerritoryCode)

# Complex type {http://ddex.net/xml/20120214/ddexC}AdditionalInformation with content type SIMPLE
class AdditionalInformation (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:AdditionalInformation."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AdditionalInformation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 18, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_AdditionalInformation_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 24, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 24, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:AdditionalInformation as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'AdditionalInformation', AdditionalInformation)


# Complex type {http://ddex.net/xml/20120214/ddexC}AmountByUseAndDistributionChannelType with content type ELEMENT_ONLY
class AmountByUseAndDistributionChannelType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:Amount specified for a ddex:UseType and a ddex:DistributionChannelType."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AmountByUseAndDistributionChannelType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 71, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Amount uses Python identifier Amount
    __Amount = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Amount'), 'Amount', '__httpddex_netxml20120214ddexC_AmountByUseAndDistributionChannelType_Amount', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 76, 9), )

    
    Amount = property(__Amount.value, __Amount.set, None, 'The ddex:Amount specified for the ddex:UseType and the ddex:DistributionChannelType.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20120214ddexC_AmountByUseAndDistributionChannelType_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 81, 9), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20120214ddexC_AmountByUseAndDistributionChannelType_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 86, 9), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20120214ddexC_AmountByUseAndDistributionChannelType_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 92, 9), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20120214ddexC_AmountByUseAndDistributionChannelType_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 98, 9), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A ddex:Composite containing details of a ddex:Carrier.')

    _ElementMap.update({
        __Amount.name() : __Amount,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'AmountByUseAndDistributionChannelType', AmountByUseAndDistributionChannelType)


# Complex type {http://ddex.net/xml/20120214/ddexC}AmountPerCollection with content type ELEMENT_ONLY
class AmountPerCollection (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:Amount that has to be paid per ddex:Collection."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AmountPerCollection')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 105, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Amount uses Python identifier Amount
    __Amount = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Amount'), 'Amount', '__httpddex_netxml20120214ddexC_AmountPerCollection_Amount', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 110, 9), )

    
    Amount = property(__Amount.value, __Amount.set, None, 'The ddex:Amount specified for the ddex:CollectionType.')

    
    # Element CollectionType uses Python identifier CollectionType
    __CollectionType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionType'), 'CollectionType', '__httpddex_netxml20120214ddexC_AmountPerCollection_CollectionType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 115, 9), )

    
    CollectionType = property(__CollectionType.value, __CollectionType.set, None, 'A ddex:Composite containing details of the ddex:Type of the ddex:Collection.')

    _ElementMap.update({
        __Amount.name() : __Amount,
        __CollectionType.name() : __CollectionType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'AmountPerCollection', AmountPerCollection)


# Complex type {http://ddex.net/xml/20120214/ddexC}Annotation with content type SIMPLE
class Annotation (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:Annotation."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Annotation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 122, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Annotation_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 128, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 128, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:Annotation as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Annotation', Annotation)


# Complex type {http://ddex.net/xml/20120214/ddexC}Artist with content type ELEMENT_ONLY
class Artist (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:Artist. An ddex:Artist may be described through ddex:Name, ddex:Identifier and Roles."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Artist')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 165, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_Artist_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 171, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_Artist_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 177, 15), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the PartyName(s).')

    
    # Element ArtistRole uses Python identifier ArtistRole
    __ArtistRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ArtistRole'), 'ArtistRole', '__httpddex_netxml20120214ddexC_Artist_ArtistRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 189, 9), )

    
    ArtistRole = property(__ArtistRole.value, __ArtistRole.set, None, 'A ddex:Composite containing details of a role played by the ddexC:Artist in relation to other ddex:Artists.')

    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_Artist_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 195, 6)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 195, 6)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ddexC:Artist in a group of ddex:Artists. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName,
        __ArtistRole.name() : __ArtistRole
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'Artist', Artist)


# Complex type {http://ddex.net/xml/20120214/ddexC}AvRating with content type ELEMENT_ONLY
class AvRating (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a rating for an audio-visual ddex:Creation."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AvRating')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 244, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element RatingText uses Python identifier RatingText
    __RatingText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RatingText'), 'RatingText', '__httpddex_netxml20120214ddexC_AvRating_RatingText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 249, 9), )

    
    RatingText = property(__RatingText.value, __RatingText.set, None, 'The text of the ddexC:AvRating.')

    
    # Element RatingAgency uses Python identifier RatingAgency
    __RatingAgency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RatingAgency'), 'RatingAgency', '__httpddex_netxml20120214ddexC_AvRating_RatingAgency', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 254, 9), )

    
    RatingAgency = property(__RatingAgency.value, __RatingAgency.set, None, 'A Composite containing details of an Organization that issues the ddexC:AvRating.')

    _ElementMap.update({
        __RatingText.name() : __RatingText,
        __RatingAgency.name() : __RatingAgency
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'AvRating', AvRating)


# Complex type {http://ddex.net/xml/20120214/ddexC}CLine with content type ELEMENT_ONLY
class CLine (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CLine."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CLine')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 275, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Year uses Python identifier Year
    __Year = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Year'), 'Year', '__httpddex_netxml20120214ddexC_CLine_Year', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 280, 9), )

    
    Year = property(__Year.value, __Year.set, None, 'The ddex:Year of the ddexC:CLine.')

    
    # Element CLineCompany uses Python identifier CLineCompany
    __CLineCompany = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLineCompany'), 'CLineCompany', '__httpddex_netxml20120214ddexC_CLine_CLineCompany', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 285, 9), )

    
    CLineCompany = property(__CLineCompany.value, __CLineCompany.set, None, 'The ddex:Name of the company releasing the ddex:Creation. This may be an owner or a licensee of the ddex:Creation.')

    
    # Element CLineText uses Python identifier CLineText
    __CLineText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLineText'), 'CLineText', '__httpddex_netxml20120214ddexC_CLine_CLineText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 290, 9), )

    
    CLineText = property(__CLineText.value, __CLineText.set, None, 'The text of the ddexC:CLine. (Note: DDEX expects to deprecate the use of the CLineText element in a subsequent version of this standard. It will be deprecated once users of the standard are able to provide CLine information in a structured form.)')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_CLine_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 296, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 296, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddex:CLineText as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __Year.name() : __Year,
        __CLineCompany.name() : __CLineCompany,
        __CLineText.name() : __CLineText
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'CLine', CLine)


# Complex type {http://ddex.net/xml/20120214/ddexC}CatalogNumber with content type SIMPLE
class CatalogNumber (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CatalogNumber."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CatalogNumber')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 335, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CatalogNumber_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 341, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 341, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:CatalogNumber. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'CatalogNumber', CatalogNumber)


# Complex type {http://ddex.net/xml/20120214/ddexC}Character with content type ELEMENT_ONLY
class Character (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Character. A ddex:Character may be described through ddex:Name, ddex:Identifier and Roles."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Character')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 368, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_Character_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 374, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_Character_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 380, 15), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the PartyName(s).')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20120214ddexC_Character_ResourceContributor', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 392, 9), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A ddex:Composite containing details of the ddex:Name, ddex:Identifier and role(s) of a ddex:Contributor.')

    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_Character_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 398, 6)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 398, 6)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ddexC:Character in a group of ddex:Characters. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName,
        __ResourceContributor.name() : __ResourceContributor
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'Character', Character)


# Complex type {http://ddex.net/xml/20120214/ddexC}Collection with content type ELEMENT_ONLY
class Collection (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Collection."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Collection')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 404, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element CollectionId uses Python identifier CollectionId
    __CollectionId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionId'), 'CollectionId', '__httpddex_netxml20120214ddexC_Collection_CollectionId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 409, 9), )

    
    CollectionId = property(__CollectionId.value, __CollectionId.set, None, 'A ddex:Composite containing details of an ddex:Identifier of the ddex:Collection.')

    
    # Element CollectionType uses Python identifier CollectionType
    __CollectionType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionType'), 'CollectionType', '__httpddex_netxml20120214ddexC_Collection_CollectionType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 414, 9), )

    
    CollectionType = property(__CollectionType.value, __CollectionType.set, None, 'A ddex:Composite containing details of the ddex:Type of the ddex:Collection.')

    
    # Element CollectionReference uses Python identifier CollectionReference
    __CollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionReference'), 'CollectionReference', '__httpddex_netxml20120214ddexC_Collection_CollectionReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 420, 9), )

    
    CollectionReference = property(__CollectionReference.value, __CollectionReference.set, None, 'The ddex:Identifier (specific to the ddex:Message) of the ddex:Collection within the ddex:Release which contains it. This is a ddex:LocalCollectionAnchor starting with the letter X.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20120214ddexC_Collection_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 430, 9), )

    
    Title = property(__Title.value, __Title.set, None, 'A ddex:Composite containing details of a ddex:Title of the ddex:Collection.')

    
    # Element Contributor uses Python identifier Contributor
    __Contributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Contributor'), 'Contributor', '__httpddex_netxml20120214ddexC_Collection_Contributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 435, 9), )

    
    Contributor = property(__Contributor.value, __Contributor.set, None, 'A ddex:Composite containing details a ddex:Contributor to the ddex:Collection.')

    
    # Element CollectionCollectionReferenceList uses Python identifier CollectionCollectionReferenceList
    __CollectionCollectionReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReferenceList'), 'CollectionCollectionReferenceList', '__httpddex_netxml20120214ddexC_Collection_CollectionCollectionReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 441, 9), )

    
    CollectionCollectionReferenceList = property(__CollectionCollectionReferenceList.value, __CollectionCollectionReferenceList.set, None, 'A ddex:Composite containing a list of ddex:CollectionCollectionReferences for a ddex:Collection (specific to this ddex:Message).')

    
    # Element IsComplete uses Python identifier IsComplete
    __IsComplete = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsComplete'), 'IsComplete', '__httpddex_netxml20120214ddexC_Collection_IsComplete', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 447, 9), )

    
    IsComplete = property(__IsComplete.value, __IsComplete.set, None, 'The ddex:Flag indicating whether the ddex:Collection is complete (=True) or not (=False). Only one of the Elements ddex:IsComplete here and in the ddexC:CollectionDetailsByTerritory is valid for a given ddexC:Collection.')

    
    # Element DurationOfMusicalContent uses Python identifier DurationOfMusicalContent
    __DurationOfMusicalContent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DurationOfMusicalContent'), 'DurationOfMusicalContent', '__httpddex_netxml20120214ddexC_Collection_DurationOfMusicalContent', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 452, 9), )

    
    DurationOfMusicalContent = property(__DurationOfMusicalContent.value, __DurationOfMusicalContent.set, None, 'The ddex:Duration of the musical content (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element CreationDate uses Python identifier CreationDate
    __CreationDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CreationDate'), 'CreationDate', '__httpddex_netxml20120214ddexC_Collection_CreationDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 457, 9), )

    
    CreationDate = property(__CreationDate.value, __CreationDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Collection was created.')

    
    # Element OriginalReleaseDate uses Python identifier OriginalReleaseDate
    __OriginalReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate'), 'OriginalReleaseDate', '__httpddex_netxml20120214ddexC_Collection_OriginalReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 462, 9), )

    
    OriginalReleaseDate = property(__OriginalReleaseDate.value, __OriginalReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Collection was or will be first made available for Usage, whether for physical or electronic/online distribution (in ISO 8601:2004 format: YYYY-MM-DD).')

    
    # Element OriginalLanguage uses Python identifier OriginalLanguage
    __OriginalLanguage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalLanguage'), 'OriginalLanguage', '__httpddex_netxml20120214ddexC_Collection_OriginalLanguage', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 467, 9), )

    
    OriginalLanguage = property(__OriginalLanguage.value, __OriginalLanguage.set, None, 'The orignal ddex:Language of the ddex:Collection (represented by an ISO 639-2 iso639a2:LanguageCode).')

    
    # Element CollectionDetailsByTerritory uses Python identifier CollectionDetailsByTerritory
    __CollectionDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionDetailsByTerritory'), 'CollectionDetailsByTerritory', '__httpddex_netxml20120214ddexC_Collection_CollectionDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 472, 9), )

    
    CollectionDetailsByTerritory = property(__CollectionDetailsByTerritory.value, __CollectionDetailsByTerritory.set, None, 'A ddex:Composite containing details of ddex:Descriptors and other attributes of the ddex:Collection which may vary according to ddex:Territory of release.')

    
    # Element CollectionResourceReferenceList uses Python identifier CollectionResourceReferenceList
    __CollectionResourceReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionResourceReferenceList'), 'CollectionResourceReferenceList', '__httpddex_netxml20120214ddexC_Collection_CollectionResourceReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 478, 9), )

    
    CollectionResourceReferenceList = property(__CollectionResourceReferenceList.value, __CollectionResourceReferenceList.set, None, 'A ddex:Composite containing a list of ddex:CollectionResourceReferences for a ddex:Resource (specific to this ddex:Message).')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Collection_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 485, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 485, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddex:Collection as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __CollectionId.name() : __CollectionId,
        __CollectionType.name() : __CollectionType,
        __CollectionReference.name() : __CollectionReference,
        __Title.name() : __Title,
        __Contributor.name() : __Contributor,
        __CollectionCollectionReferenceList.name() : __CollectionCollectionReferenceList,
        __IsComplete.name() : __IsComplete,
        __DurationOfMusicalContent.name() : __DurationOfMusicalContent,
        __CreationDate.name() : __CreationDate,
        __OriginalReleaseDate.name() : __OriginalReleaseDate,
        __OriginalLanguage.name() : __OriginalLanguage,
        __CollectionDetailsByTerritory.name() : __CollectionDetailsByTerritory,
        __CollectionResourceReferenceList.name() : __CollectionResourceReferenceList
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Collection', Collection)


# Complex type {http://ddex.net/xml/20120214/ddexC}CollectionCollectionReference with content type ELEMENT_ONLY
class CollectionCollectionReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a ddex:CollectionCollectionReference."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionCollectionReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 491, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_CollectionCollectionReference_SequenceNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 496, 9), )

    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ddex:Collection in a group of ddex:Collections within a ddex:Medley, ddex:SoundRecording or other ddex:Collection.')

    
    # Element CollectionCollectionReference uses Python identifier CollectionCollectionReference
    __CollectionCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference'), 'CollectionCollectionReference', '__httpddex_netxml20120214ddexC_CollectionCollectionReference_CollectionCollectionReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 501, 9), )

    
    CollectionCollectionReference = property(__CollectionCollectionReference.value, __CollectionCollectionReference.set, None, 'A ddex:Reference for a ddex:Collection (specific to this ddex:Message). This is a ddex:LocalCollectionAnchorReference starting with the letter X. The referenced ddex:Collection has to be of ddex:CollectionType ddex:Series, ddex:Season or ddex:Episode.')

    
    # Element StartTime uses Python identifier StartTime
    __StartTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartTime'), 'StartTime', '__httpddex_netxml20120214ddexC_CollectionCollectionReference_StartTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 511, 9), )

    
    StartTime = property(__StartTime.value, __StartTime.set, None, 'The start time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20120214ddexC_CollectionCollectionReference_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 516, 9), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The ddex:Duration of the use of the ddex:Creation that is referenced in the ddex:CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element EndTime uses Python identifier EndTime
    __EndTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndTime'), 'EndTime', '__httpddex_netxml20120214ddexC_CollectionCollectionReference_EndTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 521, 9), )

    
    EndTime = property(__EndTime.value, __EndTime.set, None, 'The end time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element InclusionDate uses Python identifier InclusionDate
    __InclusionDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'InclusionDate'), 'InclusionDate', '__httpddex_netxml20120214ddexC_CollectionCollectionReference_InclusionDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 526, 9), )

    
    InclusionDate = property(__InclusionDate.value, __InclusionDate.set, None, 'A Date on which the ddex:Collection or ddex:Resource was included in the parent ddex:Collection.')

    _ElementMap.update({
        __SequenceNumber.name() : __SequenceNumber,
        __CollectionCollectionReference.name() : __CollectionCollectionReference,
        __StartTime.name() : __StartTime,
        __Duration.name() : __Duration,
        __EndTime.name() : __EndTime,
        __InclusionDate.name() : __InclusionDate
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CollectionCollectionReference', CollectionCollectionReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}CollectionCollectionReferenceList with content type ELEMENT_ONLY
class CollectionCollectionReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a list of ddex:CollectionCollectionReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionCollectionReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 533, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element NumberOfCollections uses Python identifier NumberOfCollections
    __NumberOfCollections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), 'NumberOfCollections', '__httpddex_netxml20120214ddexC_CollectionCollectionReferenceList_NumberOfCollections', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 538, 9), )

    
    NumberOfCollections = property(__NumberOfCollections.value, __NumberOfCollections.set, None, 'The number of referenced ddexC:Collections (typically Chapters).')

    
    # Element CollectionCollectionReference uses Python identifier CollectionCollectionReference
    __CollectionCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference'), 'CollectionCollectionReference', '__httpddex_netxml20120214ddexC_CollectionCollectionReferenceList_CollectionCollectionReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 543, 9), )

    
    CollectionCollectionReference = property(__CollectionCollectionReference.value, __CollectionCollectionReference.set, None, 'A ddex:Composite containing a ddex:CollectionCollectionReference for a ddex:Collection (specific to this ddex:Message).')

    _ElementMap.update({
        __NumberOfCollections.name() : __NumberOfCollections,
        __CollectionCollectionReference.name() : __CollectionCollectionReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CollectionCollectionReferenceList', CollectionCollectionReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}CollectionDetailsByTerritory with content type ELEMENT_ONLY
class CollectionDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors and other attributes of a ddex:Collection which may vary according to ddex:Territory of release. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 551, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_CollectionDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 557, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:Collection details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_CollectionDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 562, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:Collection details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20120214ddexC_CollectionDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 568, 9), )

    
    Title = property(__Title.value, __Title.set, None, 'A ddex:Composite containing details of a ddex:Title of the ddex:Collection.')

    
    # Element Contributor uses Python identifier Contributor
    __Contributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Contributor'), 'Contributor', '__httpddex_netxml20120214ddexC_CollectionDetailsByTerritory_Contributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 573, 9), )

    
    Contributor = property(__Contributor.value, __Contributor.set, None, 'A ddex:Composite containing details of a ddex:Contributor to the ddex:Collection.')

    
    # Element IsComplete uses Python identifier IsComplete
    __IsComplete = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsComplete'), 'IsComplete', '__httpddex_netxml20120214ddexC_CollectionDetailsByTerritory_IsComplete', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 579, 9), )

    
    IsComplete = property(__IsComplete.value, __IsComplete.set, None, 'The ddex:Flag indicating whether the ddex:Collection is complete (=True) or not (=False). Only one of the Elements ddex:IsComplete here and in the Collection is valid for a given Collection.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __Title.name() : __Title,
        __Contributor.name() : __Contributor,
        __IsComplete.name() : __IsComplete
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CollectionDetailsByTerritory', CollectionDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}CollectionId with content type ELEMENT_ONLY
class CollectionId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a CollectionId."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 586, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element GRid uses Python identifier GRid
    __GRid = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'GRid'), 'GRid', '__httpddex_netxml20120214ddexC_CollectionId_GRid', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 591, 9), )

    
    GRid = property(__GRid.value, __GRid.set, None, "The ddex:GRid identifying the ddex:Collection. This is the preferred ddex:Element and is mandatory if a ddex:GRid is available. A ddex:GRid comprises four parts: the xs:string 'A1', followed by five alphanumeric characters, ten alphanumeric characters and and one alphanumeric character.")

    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20120214ddexC_CollectionId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 596, 9), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:Collection. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ')

    
    # Element ISAN uses Python identifier ISAN
    __ISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISAN'), 'ISAN', '__httpddex_netxml20120214ddexC_CollectionId_ISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 601, 9), )

    
    ISAN = property(__ISAN.value, __ISAN.set, None, 'The ddex:ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the ddex:Collection. An ddex:ISAN comprises four blocks of four hexadecimal charaters followed by a check character.')

    
    # Element VISAN uses Python identifier VISAN
    __VISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VISAN'), 'VISAN', '__httpddex_netxml20120214ddexC_CollectionId_VISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 606, 9), )

    
    VISAN = property(__VISAN.value, __VISAN.set, None, 'The V-ISAN (Version ddex:Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the ddex:Collection. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.')

    
    # Element ICPN uses Python identifier ICPN
    __ICPN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ICPN'), 'ICPN', '__httpddex_netxml20120214ddexC_CollectionId_ICPN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 611, 9), )

    
    ICPN = property(__ICPN.value, __ICPN.set, None, 'A ddex:Composite containing details of the ddex:ICPN used as proxy for identification of the ddex:Collection. Only applicable when the ddex:Collection is an abstraction of a complete ddex:PhysicalProduct. An ddex:ICPN comprises 12 or 13 digits, depending whether it is an ddex:EAN (13) or a ddex:UPC (12).')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20120214ddexC_CollectionId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 616, 9), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Collection.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_CollectionId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 621, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Collection (usually one per society involved in the messaging).')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_CollectionId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 628, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 628, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __GRid.name() : __GRid,
        __ISRC.name() : __ISRC,
        __ISAN.name() : __ISAN,
        __VISAN.name() : __VISAN,
        __ICPN.name() : __ICPN,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'CollectionId', CollectionId)


# Complex type {http://ddex.net/xml/20120214/ddexC}CollectionList with content type ELEMENT_ONLY
class CollectionList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of one or more ddex:Collections."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 634, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Collection uses Python identifier Collection
    __Collection = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Collection'), 'Collection', '__httpddex_netxml20120214ddexC_CollectionList_Collection', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 639, 9), )

    
    Collection = property(__Collection.value, __Collection.set, None, 'A ddex:Composite containing details of a ddex:Collection contained in a ddex:Resource.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_CollectionList_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 645, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 645, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the CollectionList as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __Collection.name() : __Collection
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'CollectionList', CollectionList)


# Complex type {http://ddex.net/xml/20120214/ddexC}CollectionResourceReferenceList with content type ELEMENT_ONLY
class CollectionResourceReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a list of ddex:CollectionResourceReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionResourceReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 651, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element CollectionResourceReference uses Python identifier CollectionResourceReference
    __CollectionResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CollectionResourceReference'), 'CollectionResourceReference', '__httpddex_netxml20120214ddexC_CollectionResourceReferenceList_CollectionResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 656, 9), )

    
    CollectionResourceReference = property(__CollectionResourceReference.value, __CollectionResourceReference.set, None, 'A ddex:Reference for a ddex:Resource (specific to this ddex:Message). This is a ddex:LocalResourceAnchorReference starting with the letter A.')

    _ElementMap.update({
        __CollectionResourceReference.name() : __CollectionResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CollectionResourceReferenceList', CollectionResourceReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}Comment with content type SIMPLE
class Comment (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:Comment."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Comment')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 687, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Comment_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 693, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 693, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:Comment as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Comment', Comment)


# Complex type {http://ddex.net/xml/20120214/ddexC}ConsumerRentalPeriod with content type SIMPLE
class ConsumerRentalPeriod (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Period a ddex:DSP may rent something to a ddex:Customer."""
    _TypeDefinition = pyxb.binding.datatypes.duration
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ConsumerRentalPeriod')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 720, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.duration
    
    # Attribute IsExtensible uses Python identifier IsExtensible
    __IsExtensible = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsExtensible'), 'IsExtensible', '__httpddex_netxml20120214ddexC_ConsumerRentalPeriod_IsExtensible', pyxb.binding.datatypes.boolean)
    __IsExtensible._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 726, 12)
    __IsExtensible._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 726, 12)
    
    IsExtensible = property(__IsExtensible.value, __IsExtensible.set, None, 'A ddex:Flag indicating whether a ddex:Period can be extended after the end of a ddex:Deal (=True) or not (=False). This is represented in an XML schema as an XML Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __IsExtensible.name() : __IsExtensible
    })
Namespace.addCategoryObject('typeBinding', 'ConsumerRentalPeriod', ConsumerRentalPeriod)


# Complex type {http://ddex.net/xml/20120214/ddexC}CourtesyLine with content type SIMPLE
class CourtesyLine (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:CourtesyLine."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CourtesyLine')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 753, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_CourtesyLine_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 759, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 759, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:CourtesyLine as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'CourtesyLine', CourtesyLine)


# Complex type {http://ddex.net/xml/20120214/ddexC}CreationId with content type ELEMENT_ONLY
class CreationId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CreationIds."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CreationId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 767, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISWC uses Python identifier ISWC
    __ISWC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISWC'), 'ISWC', '__httpddex_netxml20120214ddexC_CreationId_ISWC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 772, 9), )

    
    ISWC = property(__ISWC.value, __ISWC.set, None, "The ddex:ISWC (International Standard Musical ddex:Work Code defined in ISO 15707) identifying the ddex:MusicalWork. An ddex:ISWC comprises three parts: the letter 'T', followed by nine digits and then one check digit.")

    
    # Element OpusNumber uses Python identifier OpusNumber
    __OpusNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OpusNumber'), 'OpusNumber', '__httpddex_netxml20120214ddexC_CreationId_OpusNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 777, 9), )

    
    OpusNumber = property(__OpusNumber.value, __OpusNumber.set, None, 'The ddexC:MusicalWorkId identifying the ddex:MusicalWork within the catalog of its ddex:Composer (typically of classical music) as an opus number.')

    
    # Element ComposerCatalogNumber uses Python identifier ComposerCatalogNumber
    __ComposerCatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ComposerCatalogNumber'), 'ComposerCatalogNumber', '__httpddex_netxml20120214ddexC_CreationId_ComposerCatalogNumber', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 782, 9), )

    
    ComposerCatalogNumber = property(__ComposerCatalogNumber.value, __ComposerCatalogNumber.set, None, "A ddexC:MusicalWorkId identifying a ddex:MusicalWork within the catalog of its ddex:Composer (typically of classical music) according to a standardized numbering (e.g. 'K' numbers for Koechel's catalog of Mozart).")

    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20120214ddexC_CreationId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 788, 9), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:Resource. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ')

    
    # Element ISMN uses Python identifier ISMN
    __ISMN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISMN'), 'ISMN', '__httpddex_netxml20120214ddexC_CreationId_ISMN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 793, 9), )

    
    ISMN = property(__ISMN.value, __ISMN.set, None, "The ddex:ISMN (International Standard Music Number defined in ISO 10957) for the ddex:Resource. An ddex:ISMN is a thirteen-digit number. Pre-2008 ddex:ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ('M') with '979-0'.")

    
    # Element ISAN uses Python identifier ISAN
    __ISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISAN'), 'ISAN', '__httpddex_netxml20120214ddexC_CreationId_ISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 798, 9), )

    
    ISAN = property(__ISAN.value, __ISAN.set, None, 'The ddex:ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the ddex:Resource. An ddex:ISAN comprises four blocks of four hexadecimal charaters followed by a check character.')

    
    # Element VISAN uses Python identifier VISAN
    __VISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VISAN'), 'VISAN', '__httpddex_netxml20120214ddexC_CreationId_VISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 803, 9), )

    
    VISAN = property(__VISAN.value, __VISAN.set, None, 'The V-ISAN (Version ddex:Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the ddex:Resource. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.')

    
    # Element ISBN uses Python identifier ISBN
    __ISBN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISBN'), 'ISBN', '__httpddex_netxml20120214ddexC_CreationId_ISBN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 808, 9), )

    
    ISBN = property(__ISBN.value, __ISBN.set, None, "The ddex:ISBN (International Standard Book Number defined in ISO 2108) for the ddex:Resource. An ddex:ISBN is a 13-digit number. Pre-2007, ddex:ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix '978' and re-calculating the check character.")

    
    # Element ISSN uses Python identifier ISSN
    __ISSN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISSN'), 'ISSN', '__httpddex_netxml20120214ddexC_CreationId_ISSN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 813, 9), )

    
    ISSN = property(__ISSN.value, __ISSN.set, None, 'The ddex:ISSN (International Standard Serial Number defined in ISO 3297) for the ddex:Resource. An ddex:ISSN comprises two groups of four digits, separated by a hyphen and a control digit.')

    
    # Element SICI uses Python identifier SICI
    __SICI = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SICI'), 'SICI', '__httpddex_netxml20120214ddexC_CreationId_SICI', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 818, 9), )

    
    SICI = property(__SICI.value, __SICI.set, None, 'The ddex:SICI (Serial Item and Contribution ddex:Identifier defined in ANSI/NISO Z39.56-199)  for the ddex:Resource.')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20120214ddexC_CreationId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 823, 9), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Resource.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_CreationId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 828, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Creation.')

    _ElementMap.update({
        __ISWC.name() : __ISWC,
        __OpusNumber.name() : __OpusNumber,
        __ComposerCatalogNumber.name() : __ComposerCatalogNumber,
        __ISRC.name() : __ISRC,
        __ISMN.name() : __ISMN,
        __ISAN.name() : __ISAN,
        __VISAN.name() : __VISAN,
        __ISBN.name() : __ISBN,
        __ISSN.name() : __ISSN,
        __SICI.name() : __SICI,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CreationId', CreationId)


# Complex type {http://ddex.net/xml/20120214/ddexC}Cue with content type ELEMENT_ONLY
class Cue (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Cue."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Cue')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 836, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element CueUseType uses Python identifier CueUseType
    __CueUseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueUseType'), 'CueUseType', '__httpddex_netxml20120214ddexC_Cue_CueUseType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 841, 9), )

    
    CueUseType = property(__CueUseType.value, __CueUseType.set, None, 'A ddex:Composite containing details of a ddex:UseType of the ddexC:Cue. It can be expected that this element will be contractually mandatory in many communications of cue sheets to music rights societies.')

    
    # Element CueThemeType uses Python identifier CueThemeType
    __CueThemeType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueThemeType'), 'CueThemeType', '__httpddex_netxml20120214ddexC_Cue_CueThemeType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 846, 9), )

    
    CueThemeType = property(__CueThemeType.value, __CueThemeType.set, None, 'A ddex:Composite containing details of a ddex:ThemeType for the ddex:Creation referenced in the ddexC:Cue.')

    
    # Element CueVocalType uses Python identifier CueVocalType
    __CueVocalType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueVocalType'), 'CueVocalType', '__httpddex_netxml20120214ddexC_Cue_CueVocalType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 851, 9), )

    
    CueVocalType = property(__CueVocalType.value, __CueVocalType.set, None, 'A ddex:Composite containing details of a ddex:VocalType for the ddex:Creation referenced in the ddexC:Cue.')

    
    # Element IsDance uses Python identifier IsDance
    __IsDance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsDance'), 'IsDance', '__httpddex_netxml20120214ddexC_Cue_IsDance', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 856, 9), )

    
    IsDance = property(__IsDance.value, __IsDance.set, None, 'A ddex:Flag indicating whether a ddex:Creation contains dancing (=True) or not (=False).')

    
    # Element CueVisualPerceptionType uses Python identifier CueVisualPerceptionType
    __CueVisualPerceptionType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueVisualPerceptionType'), 'CueVisualPerceptionType', '__httpddex_netxml20120214ddexC_Cue_CueVisualPerceptionType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 861, 9), )

    
    CueVisualPerceptionType = property(__CueVisualPerceptionType.value, __CueVisualPerceptionType.set, None, 'A ddex:Composite containing details of a ddex:VisualPerceptionType for the ddex:Creation referenced in the ddexC:Cue.')

    
    # Element CueOrigin uses Python identifier CueOrigin
    __CueOrigin = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueOrigin'), 'CueOrigin', '__httpddex_netxml20120214ddexC_Cue_CueOrigin', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 867, 9), )

    
    CueOrigin = property(__CueOrigin.value, __CueOrigin.set, None, 'A ddex:Composite containing details of a ddex:CueOrigin for the ddexC:Cue. It can be expected that this element will be contractually mandatory in many communications of cue sheets to music rights societies.')

    
    # Element CueCreationReference uses Python identifier CueCreationReference
    __CueCreationReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueCreationReference'), 'CueCreationReference', '__httpddex_netxml20120214ddexC_Cue_CueCreationReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 873, 12), )

    
    CueCreationReference = property(__CueCreationReference.value, __CueCreationReference.set, None, 'A ddex:Composite containing a ddex:CueCreationReference for a ddex:Creation (specific to this ddex:Message).')

    
    # Element ReferencedCreationType uses Python identifier ReferencedCreationType
    __ReferencedCreationType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferencedCreationType'), 'ReferencedCreationType', '__httpddex_netxml20120214ddexC_Cue_ReferencedCreationType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 880, 15), )

    
    ReferencedCreationType = property(__ReferencedCreationType.value, __ReferencedCreationType.set, None, 'A ddex:Type of the ddex:Creation referenced in the ddexC:Cue.')

    
    # Element ReferencedCreationId uses Python identifier ReferencedCreationId
    __ReferencedCreationId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferencedCreationId'), 'ReferencedCreationId', '__httpddex_netxml20120214ddexC_Cue_ReferencedCreationId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 885, 15), )

    
    ReferencedCreationId = property(__ReferencedCreationId.value, __ReferencedCreationId.set, None, 'A ddex:Composite containing details of a ddex:CreationIds.')

    
    # Element ReferencedCreationTitle uses Python identifier ReferencedCreationTitle
    __ReferencedCreationTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferencedCreationTitle'), 'ReferencedCreationTitle', '__httpddex_netxml20120214ddexC_Cue_ReferencedCreationTitle', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 890, 15), )

    
    ReferencedCreationTitle = property(__ReferencedCreationTitle.value, __ReferencedCreationTitle.set, None, 'A ddex:Composite containing details of a ddex:Title of the ddex:Creation referenced in the ddexC:Cue.')

    
    # Element ReferencedCreationContributor uses Python identifier ReferencedCreationContributor
    __ReferencedCreationContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferencedCreationContributor'), 'ReferencedCreationContributor', '__httpddex_netxml20120214ddexC_Cue_ReferencedCreationContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 896, 15), )

    
    ReferencedCreationContributor = property(__ReferencedCreationContributor.value, __ReferencedCreationContributor.set, None, 'A ddex:Composite containing details a ddex:Contributor of the ddex:Creation referenced in the ddexC:Cue.')

    
    # Element HasMusicalContent uses Python identifier HasMusicalContent
    __HasMusicalContent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HasMusicalContent'), 'HasMusicalContent', '__httpddex_netxml20120214ddexC_Cue_HasMusicalContent', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 904, 9), )

    
    HasMusicalContent = property(__HasMusicalContent.value, __HasMusicalContent.set, None, 'A ddex:Flag indicating whether whether the ddex:Creation referenced in the ddexC:Cue contains musical content such as a ddex:SoundRecording or a ddex:MusicalWork (=True) or not (=False).')

    
    # Element StartTime uses Python identifier StartTime
    __StartTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartTime'), 'StartTime', '__httpddex_netxml20120214ddexC_Cue_StartTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 909, 9), )

    
    StartTime = property(__StartTime.value, __StartTime.set, None, 'The start time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20120214ddexC_Cue_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 914, 9), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The ddex:Duration of the use of the ddex:Creation that is referenced in the ddex:CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element EndTime uses Python identifier EndTime
    __EndTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndTime'), 'EndTime', '__httpddex_netxml20120214ddexC_Cue_EndTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 919, 9), )

    
    EndTime = property(__EndTime.value, __EndTime.set, None, 'The end time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    _ElementMap.update({
        __CueUseType.name() : __CueUseType,
        __CueThemeType.name() : __CueThemeType,
        __CueVocalType.name() : __CueVocalType,
        __IsDance.name() : __IsDance,
        __CueVisualPerceptionType.name() : __CueVisualPerceptionType,
        __CueOrigin.name() : __CueOrigin,
        __CueCreationReference.name() : __CueCreationReference,
        __ReferencedCreationType.name() : __ReferencedCreationType,
        __ReferencedCreationId.name() : __ReferencedCreationId,
        __ReferencedCreationTitle.name() : __ReferencedCreationTitle,
        __ReferencedCreationContributor.name() : __ReferencedCreationContributor,
        __HasMusicalContent.name() : __HasMusicalContent,
        __StartTime.name() : __StartTime,
        __Duration.name() : __Duration,
        __EndTime.name() : __EndTime
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'Cue', Cue)


# Complex type {http://ddex.net/xml/20120214/ddexC}CueCreationReference with content type ELEMENT_ONLY
class CueCreationReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a ddex:CueCreationReference."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueCreationReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 926, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element CueWorkReference uses Python identifier CueWorkReference
    __CueWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueWorkReference'), 'CueWorkReference', '__httpddex_netxml20120214ddexC_CueCreationReference_CueWorkReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 932, 12), )

    
    CueWorkReference = property(__CueWorkReference.value, __CueWorkReference.set, None, 'A ddex:Reference for a ddex:Work (specific to this ddex:Message). This is a ddex:LocalMusicalWorkAnchorReference starting with the letter W.')

    
    # Element CueResourceReference uses Python identifier CueResourceReference
    __CueResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueResourceReference'), 'CueResourceReference', '__httpddex_netxml20120214ddexC_CueCreationReference_CueResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 942, 12), )

    
    CueResourceReference = property(__CueResourceReference.value, __CueResourceReference.set, None, 'A ddex:Reference for a ddex:Resource (specific to this ddex:Message). This is a ddex:LocalResourceAnchorReference starting with the letter A.')

    _ElementMap.update({
        __CueWorkReference.name() : __CueWorkReference,
        __CueResourceReference.name() : __CueResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CueCreationReference', CueCreationReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}CueSheet with content type ELEMENT_ONLY
class CueSheet (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CueSheet."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueSheet')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 974, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element CueSheetId uses Python identifier CueSheetId
    __CueSheetId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueSheetId'), 'CueSheetId', '__httpddex_netxml20120214ddexC_CueSheet_CueSheetId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 979, 9), )

    
    CueSheetId = property(__CueSheetId.value, __CueSheetId.set, None, 'A ddex:Composite containing details of a ddex:CueSheetId of the ddexC:CueSheet.')

    
    # Element CueSheetReference uses Python identifier CueSheetReference
    __CueSheetReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueSheetReference'), 'CueSheetReference', '__httpddex_netxml20120214ddexC_CueSheet_CueSheetReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 985, 9), )

    
    CueSheetReference = property(__CueSheetReference.value, __CueSheetReference.set, None, 'The ddex:Identifier (specific to the ddex:Message) of the ddexC:CueSheet within the ddex:Release which contains it. This is a ddex:LocalCueSheetAnchor starting with the letter Q.')

    
    # Element CueSheetType uses Python identifier CueSheetType
    __CueSheetType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueSheetType'), 'CueSheetType', '__httpddex_netxml20120214ddexC_CueSheet_CueSheetType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 995, 9), )

    
    CueSheetType = property(__CueSheetType.value, __CueSheetType.set, None, 'A ddex:Composite containing details of a ddex:Type of the ddexC:CueSheet.')

    
    # Element Cue uses Python identifier Cue
    __Cue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Cue'), 'Cue', '__httpddex_netxml20120214ddexC_CueSheet_Cue', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1000, 9), )

    
    Cue = property(__Cue.value, __Cue.set, None, 'A ddex:Composite containing details of a ddex:Cue.')

    _ElementMap.update({
        __CueSheetId.name() : __CueSheetId,
        __CueSheetReference.name() : __CueSheetReference,
        __CueSheetType.name() : __CueSheetType,
        __Cue.name() : __Cue
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CueSheet', CueSheet)


# Complex type {http://ddex.net/xml/20120214/ddexC}CueSheetList with content type ELEMENT_ONLY
class CueSheetList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of one or more ddex:CueSheets."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueSheetList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1007, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element CueSheet uses Python identifier CueSheet
    __CueSheet = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CueSheet'), 'CueSheet', '__httpddex_netxml20120214ddexC_CueSheetList_CueSheet', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1012, 9), )

    
    CueSheet = property(__CueSheet.value, __CueSheet.set, None, 'A ddex:Composite containing details of a ddex:CueSheet contained in a ddex:Resource.')

    _ElementMap.update({
        __CueSheet.name() : __CueSheet
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'CueSheetList', CueSheetList)


# Complex type {http://ddex.net/xml/20120214/ddexC}DSP with content type ELEMENT_ONLY
class DSP (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:DSP acting as a ddex:Licensee in a commercial relationship."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DSP')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1114, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_DSP_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1120, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_DSP_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1126, 15), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the PartyName(s).')

    
    # Element TradingName uses Python identifier TradingName
    __TradingName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TradingName'), 'TradingName', '__httpddex_netxml20120214ddexC_DSP_TradingName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1138, 9), )

    
    TradingName = property(__TradingName.value, __TradingName.set, None, 'A ddex:Composite containing a ddex:TradingName of the ddexC:DSP.')

    
    # Element URL uses Python identifier URL
    __URL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'URL'), 'URL', '__httpddex_netxml20120214ddexC_DSP_URL', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1143, 9), )

    
    URL = property(__URL.value, __URL.set, None, "A ddex:URL for the DSP's web site.")

    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_DSP_TerritoryCode', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1148, 9), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'The ddex:Territory from which the ddexC:DSP operates (represented by an ISO 3166-1 iso3166a2:TerritoryCode). This ddex:Territory may differ from the one in which ddex:SalesTransactions occur.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_DSP_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1154, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1154, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:DSP as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName,
        __TradingName.name() : __TradingName,
        __URL.name() : __URL,
        __TerritoryCode.name() : __TerritoryCode
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'DSP', DSP)


# Complex type {http://ddex.net/xml/20120214/ddexC}DealReference with content type SIMPLE
class DealReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:DealReference."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DealReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1160, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_DealReference_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1166, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1166, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:DealReference as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'DealReference', DealReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}Description with content type SIMPLE
class Description (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:Description."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Description')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1198, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Description_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1204, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1204, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:Description as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Description', Description)


# Complex type {http://ddex.net/xml/20120214/ddexC}DistributionChannelDescriptor with content type SIMPLE
class DistributionChannelDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:DistributionChannelDescriptor."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DistributionChannelDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1212, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_DistributionChannelDescriptor_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1218, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1218, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:DistributionChannelDescriptor as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'DistributionChannelDescriptor', DistributionChannelDescriptor)


# Complex type {http://ddex.net/xml/20120214/ddexC}DurationByUseType with content type ELEMENT_ONLY
class DurationByUseType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Duration specified for a ddex:UseType."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DurationByUseType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1269, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20120214ddexC_DurationByUseType_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1274, 9), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The ddex:Duration specified for the ddex:UseType.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20120214ddexC_DurationByUseType_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1279, 9), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20120214ddexC_DurationByUseType_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1284, 9), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20120214ddexC_DurationByUseType_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1290, 9), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20120214ddexC_DurationByUseType_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1296, 9), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A ddex:Composite containing details of a ddex:Carrier.')

    _ElementMap.update({
        __Duration.name() : __Duration,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'DurationByUseType', DurationByUseType)


# Complex type {http://ddex.net/xml/20120214/ddexC}ErnMessageInBatch with content type ELEMENT_ONLY
class ErnMessageInBatch (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an Release Notification ddex:Message in a ddex:Batch."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ErnMessageInBatch')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1303, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MessageType uses Python identifier MessageType
    __MessageType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageType'), 'MessageType', '__httpddex_netxml20120214ddexC_ErnMessageInBatch_MessageType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1308, 9), )

    
    MessageType = property(__MessageType.value, __MessageType.set, None, 'The ddex:Type of ddex:Message.')

    
    # Element MessageId uses Python identifier MessageId
    __MessageId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageId'), 'MessageId', '__httpddex_netxml20120214ddexC_ErnMessageInBatch_MessageId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1313, 9), )

    
    MessageId = property(__MessageId.value, __MessageId.set, None, 'An ddex:Identifier of the ddex:Message.')

    
    # Element URL uses Python identifier URL
    __URL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'URL'), 'URL', '__httpddex_netxml20120214ddexC_ErnMessageInBatch_URL', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1318, 9), )

    
    URL = property(__URL.value, __URL.set, None, 'A ddex:URL of the ddex:Message.')

    
    # Element IncludedReleaseId uses Python identifier IncludedReleaseId
    __IncludedReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IncludedReleaseId'), 'IncludedReleaseId', '__httpddex_netxml20120214ddexC_ErnMessageInBatch_IncludedReleaseId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1323, 9), )

    
    IncludedReleaseId = property(__IncludedReleaseId.value, __IncludedReleaseId.set, None, 'A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid should always be used.')

    
    # Element DeliveryType uses Python identifier DeliveryType
    __DeliveryType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DeliveryType'), 'DeliveryType', '__httpddex_netxml20120214ddexC_ErnMessageInBatch_DeliveryType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1328, 9), )

    
    DeliveryType = property(__DeliveryType.value, __DeliveryType.set, None, 'A ddex:Composite containing details of the ddex:Type of action that the ddex:MessageSender applies to the ddex:Message.')

    
    # Element ProductType uses Python identifier ProductType
    __ProductType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProductType'), 'ProductType', '__httpddex_netxml20120214ddexC_ErnMessageInBatch_ProductType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1333, 9), )

    
    ProductType = property(__ProductType.value, __ProductType.set, None, 'A ddex:Composite containing details of the ddex:Type of a ddex:Product defining which kinds of ddex:Products are within the delivered batch. Each batch may only contain one type of ddex:Products.')

    
    # Element HashSum uses Python identifier HashSum
    __HashSum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HashSum'), 'HashSum', '__httpddex_netxml20120214ddexC_ErnMessageInBatch_HashSum', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1339, 12), )

    
    HashSum = property(__HashSum.value, __HashSum.set, None, 'A ddex:Composite containing a ddex:HashSum of the ddexC:File and information about the algorithm with which it has been generated.')

    
    # Element Signature uses Python identifier Signature
    __Signature = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Signature'), 'Signature', '__httpddex_netxml20120214ddexC_ErnMessageInBatch_Signature', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1344, 12), )

    
    Signature = property(__Signature.value, __Signature.set, None, 'A digital signature in accordance with DDEX-DSIG.')

    _ElementMap.update({
        __MessageType.name() : __MessageType,
        __MessageId.name() : __MessageId,
        __URL.name() : __URL,
        __IncludedReleaseId.name() : __IncludedReleaseId,
        __DeliveryType.name() : __DeliveryType,
        __ProductType.name() : __ProductType,
        __HashSum.name() : __HashSum,
        __Signature.name() : __Signature
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ErnMessageInBatch', ErnMessageInBatch)


# Complex type {http://ddex.net/xml/20120214/ddexC}ExternalLocationDescriptor with content type SIMPLE
class ExternalLocationDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:ExternalLocationDescriptor."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ExternalLocationDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1444, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute DescriptorSyntax uses Python identifier DescriptorSyntax
    __DescriptorSyntax = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'DescriptorSyntax'), 'DescriptorSyntax', '__httpddex_netxml20120214ddexC_ExternalLocationDescriptor_DescriptorSyntax', pyxb.binding.datatypes.string)
    __DescriptorSyntax._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1450, 12)
    __DescriptorSyntax._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1450, 12)
    
    DescriptorSyntax = property(__DescriptorSyntax.value, __DescriptorSyntax.set, None, "A ddex:Type of the ddex:Descriptor according to how it is defined syntactically. For example, using a namespace (typically using a DPID) for a proprietary syntax or 'URI' for a uniform resource identifier as defined in RFC 1630). This is represented in an XML schema as an XML ddex:Attribute.")

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __DescriptorSyntax.name() : __DescriptorSyntax
    })
Namespace.addCategoryObject('typeBinding', 'ExternalLocationDescriptor', ExternalLocationDescriptor)


# Complex type {http://ddex.net/xml/20120214/ddexC}ExternalResourceLink with content type ELEMENT_ONLY
class ExternalResourceLink (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of promotional or other material in digital form related to a ddex:Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ExternalResourceLink')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1458, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element URL uses Python identifier URL
    __URL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'URL'), 'URL', '__httpddex_netxml20120214ddexC_ExternalResourceLink_URL', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1463, 9), )

    
    URL = property(__URL.value, __URL.set, None, 'A ddex:URL of the linked external ddex:Resource.')

    
    # Element ValidityPeriod uses Python identifier ValidityPeriod
    __ValidityPeriod = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ValidityPeriod'), 'ValidityPeriod', '__httpddex_netxml20120214ddexC_ExternalResourceLink_ValidityPeriod', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1468, 9), )

    
    ValidityPeriod = property(__ValidityPeriod.value, __ValidityPeriod.set, None, 'A ddex:Composite containing details about the ddex:Period of ddex:Time during which the ddexC:ExternalResourceLink is active.')

    
    # Element ExternalLink uses Python identifier ExternalLink
    __ExternalLink = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExternalLink'), 'ExternalLink', '__httpddex_netxml20120214ddexC_ExternalResourceLink_ExternalLink', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1473, 9), )

    
    ExternalLink = property(__ExternalLink.value, __ExternalLink.set, None, 'The ddex:Identifier which provides a communication link to the related external ddex:Resource.')

    
    # Element ExternallyLinkedResourceType uses Python identifier ExternallyLinkedResourceType
    __ExternallyLinkedResourceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExternallyLinkedResourceType'), 'ExternallyLinkedResourceType', '__httpddex_netxml20120214ddexC_ExternalResourceLink_ExternallyLinkedResourceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1478, 9), )

    
    ExternallyLinkedResourceType = property(__ExternallyLinkedResourceType.value, __ExternallyLinkedResourceType.set, None, 'A ddex:Composite containing details of the ddex:Type of a ddex:Resource pointed to by the ddexC:ExternalResourceLink.')

    
    # Element FileFormat uses Python identifier FileFormat
    __FileFormat = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FileFormat'), 'FileFormat', '__httpddex_netxml20120214ddexC_ExternalResourceLink_FileFormat', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1484, 9), )

    
    FileFormat = property(__FileFormat.value, __FileFormat.set, None, 'The ddex:FileFormat of the external ddex:Resource.')

    _ElementMap.update({
        __URL.name() : __URL,
        __ValidityPeriod.name() : __ValidityPeriod,
        __ExternalLink.name() : __ExternalLink,
        __ExternallyLinkedResourceType.name() : __ExternallyLinkedResourceType,
        __FileFormat.name() : __FileFormat
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ExternalResourceLink', ExternalResourceLink)


# Complex type {http://ddex.net/xml/20120214/ddexC}File with content type ELEMENT_ONLY
class File (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:File."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'File')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1510, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element FileName uses Python identifier FileName
    __FileName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FileName'), 'FileName', '__httpddex_netxml20120214ddexC_File_FileName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1517, 15), )

    
    FileName = property(__FileName.value, __FileName.set, None, 'A ddex:Name of the ddexC:File.')

    
    # Element FilePath uses Python identifier FilePath
    __FilePath = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FilePath'), 'FilePath', '__httpddex_netxml20120214ddexC_File_FilePath', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1522, 15), )

    
    FilePath = property(__FilePath.value, __FilePath.set, None, 'A location of the ddexC:File.')

    
    # Element URL uses Python identifier URL
    __URL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'URL'), 'URL', '__httpddex_netxml20120214ddexC_File_URL', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1528, 12), )

    
    URL = property(__URL.value, __URL.set, None, 'A ddex:URL of the ddex:File.')

    
    # Element HashSum uses Python identifier HashSum
    __HashSum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HashSum'), 'HashSum', '__httpddex_netxml20120214ddexC_File_HashSum', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1534, 9), )

    
    HashSum = property(__HashSum.value, __HashSum.set, None, 'A ddex:Composite containing a ddex:HashSum of the ddexC:File and information about the algorithm with which it has been generated.')

    _ElementMap.update({
        __FileName.name() : __FileName,
        __FilePath.name() : __FilePath,
        __URL.name() : __URL,
        __HashSum.name() : __HashSum
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'File', File)


# Complex type {http://ddex.net/xml/20120214/ddexC}Fingerprint with content type ELEMENT_ONLY
class Fingerprint (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Fingerprint and its governing algorithm."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Fingerprint')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1541, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Fingerprint uses Python identifier Fingerprint
    __Fingerprint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Fingerprint'), 'Fingerprint', '__httpddex_netxml20120214ddexC_Fingerprint_Fingerprint', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1546, 9), )

    
    Fingerprint = property(__Fingerprint.value, __Fingerprint.set, None, 'The value of the ddexC:Fingerprint.')

    
    # Element FingerprintAlgorithmType uses Python identifier FingerprintAlgorithmType
    __FingerprintAlgorithmType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FingerprintAlgorithmType'), 'FingerprintAlgorithmType', '__httpddex_netxml20120214ddexC_Fingerprint_FingerprintAlgorithmType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1551, 9), )

    
    FingerprintAlgorithmType = property(__FingerprintAlgorithmType.value, __FingerprintAlgorithmType.set, None, 'A ddex:Composite containing details of the ddex:Type of FingerprintAlgorithm governing the ddexC:Fingerprint.')

    
    # Element FingerprintAlgorithmVersion uses Python identifier FingerprintAlgorithmVersion
    __FingerprintAlgorithmVersion = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FingerprintAlgorithmVersion'), 'FingerprintAlgorithmVersion', '__httpddex_netxml20120214ddexC_Fingerprint_FingerprintAlgorithmVersion', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1556, 9), )

    
    FingerprintAlgorithmVersion = property(__FingerprintAlgorithmVersion.value, __FingerprintAlgorithmVersion.set, None, 'The ddex:Identifier of the ddex:Version of the FingerprintAlgorithm.')

    
    # Element FingerprintAlgorithmParameter uses Python identifier FingerprintAlgorithmParameter
    __FingerprintAlgorithmParameter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FingerprintAlgorithmParameter'), 'FingerprintAlgorithmParameter', '__httpddex_netxml20120214ddexC_Fingerprint_FingerprintAlgorithmParameter', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1561, 9), )

    
    FingerprintAlgorithmParameter = property(__FingerprintAlgorithmParameter.value, __FingerprintAlgorithmParameter.set, None, 'A parameter of the FingerprintAlgorithm.')

    _ElementMap.update({
        __Fingerprint.name() : __Fingerprint,
        __FingerprintAlgorithmType.name() : __FingerprintAlgorithmType,
        __FingerprintAlgorithmVersion.name() : __FingerprintAlgorithmVersion,
        __FingerprintAlgorithmParameter.name() : __FingerprintAlgorithmParameter
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'Fingerprint', Fingerprint)


# Complex type {http://ddex.net/xml/20120214/ddexC}FulfillmentDate with content type ELEMENT_ONLY
class FulfillmentDate (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:FulfillmentDate."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'FulfillmentDate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1601, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element FulfillmentDate uses Python identifier FulfillmentDate
    __FulfillmentDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FulfillmentDate'), 'FulfillmentDate', '__httpddex_netxml20120214ddexC_FulfillmentDate_FulfillmentDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1606, 9), )

    
    FulfillmentDate = property(__FulfillmentDate.value, __FulfillmentDate.set, None, 'A Date after which an end user can receive the ddex:Resource (in ISO 8601:2004 format: YYYY-MM-DD). If no ddexC:FulfillmentDate is provided the ddexC:FulfillmentDate is the ddex:StartDate of the respective ddex:Deal. ')

    
    # Element ResourceReleaseReference uses Python identifier ResourceReleaseReference
    __ResourceReleaseReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceReleaseReference'), 'ResourceReleaseReference', '__httpddex_netxml20120214ddexC_FulfillmentDate_ResourceReleaseReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1611, 9), )

    
    ResourceReleaseReference = property(__ResourceReleaseReference.value, __ResourceReleaseReference.set, None, 'The ddex:Identifier (specific to the ddex:Message) of a ddex:Release for a ddex:Resource. This is a ddex:LocalReleaseAnchorReference starting with the letter R.')

    _ElementMap.update({
        __FulfillmentDate.name() : __FulfillmentDate,
        __ResourceReleaseReference.name() : __ResourceReleaseReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'FulfillmentDate', FulfillmentDate)


# Complex type {http://ddex.net/xml/20120214/ddexC}Genre with content type ELEMENT_ONLY
class Genre (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Genre."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Genre')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1623, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element GenreText uses Python identifier GenreText
    __GenreText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'GenreText'), 'GenreText', '__httpddex_netxml20120214ddexC_Genre_GenreText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1628, 9), )

    
    GenreText = property(__GenreText.value, __GenreText.set, None, 'A ddex:Composite containing a ddex:Description of a genre or style (such as Musical, literary or audio-visual) with which a ddex:Creation is associated.')

    
    # Element SubGenre uses Python identifier SubGenre
    __SubGenre = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SubGenre'), 'SubGenre', '__httpddex_netxml20120214ddexC_Genre_SubGenre', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1633, 9), )

    
    SubGenre = property(__SubGenre.value, __SubGenre.set, None, 'A ddex:Composite containing a ddex:Description of a secondary genre or style with which a ddex:Creation is associated.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Genre_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1639, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1639, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:Genre as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __GenreText.name() : __GenreText,
        __SubGenre.name() : __SubGenre
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Genre', Genre)


# Complex type {http://ddex.net/xml/20120214/ddexC}HashSum with content type ELEMENT_ONLY
class HashSum (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:HashSum and its governing algorithm."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'HashSum')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1683, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element HashSum uses Python identifier HashSum
    __HashSum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HashSum'), 'HashSum', '__httpddex_netxml20120214ddexC_HashSum_HashSum', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1688, 9), )

    
    HashSum = property(__HashSum.value, __HashSum.set, None, 'The value of the ddexC:HashSum.')

    
    # Element HashSumAlgorithmType uses Python identifier HashSumAlgorithmType
    __HashSumAlgorithmType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HashSumAlgorithmType'), 'HashSumAlgorithmType', '__httpddex_netxml20120214ddexC_HashSum_HashSumAlgorithmType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1693, 9), )

    
    HashSumAlgorithmType = property(__HashSumAlgorithmType.value, __HashSumAlgorithmType.set, None, 'A ddex:Composite containing details of the ddex:Type of ddex:HashSumAlgorithm governing the ddexC:HashSum.')

    _ElementMap.update({
        __HashSum.name() : __HashSum,
        __HashSumAlgorithmType.name() : __HashSumAlgorithmType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'HashSum', HashSum)


# Complex type {http://ddex.net/xml/20120214/ddexC}HostSoundCarrier with content type ELEMENT_ONLY
class HostSoundCarrier (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:HostSoundCarrier of a ddex:SoundRecording. This ddex:Composite exists in the Release Notification Message Suite Standard to support the identification and matching of ddex:SoundRecording information."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'HostSoundCarrier')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1719, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20120214ddexC_HostSoundCarrier_ReleaseId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1724, 9), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A ddex:Composite containing details of ddex:ReleaseIds of the ddexC:HostSoundCarrier. If available, a ddex:GRid has to be used. If the ddexC:HostSoundCarrier contains only one ddex:SoundRecording, the ddex:ISRC of the ddex:SoundRecording may be used instead.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20120214ddexC_HostSoundCarrier_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1729, 9), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddexC:HostSoundCarrier.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20120214ddexC_HostSoundCarrier_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1734, 9), )

    
    Title = property(__Title.value, __Title.set, None, 'A ddex:Composite containing details of a ddex:Title of the ddexC:HostSoundCarrier.')

    
    # Element DisplayArtist uses Python identifier DisplayArtist
    __DisplayArtist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), 'DisplayArtist', '__httpddex_netxml20120214ddexC_HostSoundCarrier_DisplayArtist', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1739, 9), )

    
    DisplayArtist = property(__DisplayArtist.value, __DisplayArtist.set, None, 'A ddex:Composite containing details of the ddex:DisplayArtist for the ddexC:HostSoundCarrier. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.')

    
    # Element AdministratingRecordCompany uses Python identifier AdministratingRecordCompany
    __AdministratingRecordCompany = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany'), 'AdministratingRecordCompany', '__httpddex_netxml20120214ddexC_HostSoundCarrier_AdministratingRecordCompany', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1744, 9), )

    
    AdministratingRecordCompany = property(__AdministratingRecordCompany.value, __AdministratingRecordCompany.set, None, 'A ddex:Composite containing details of the ddex:AdministratingRecordCompany for the Rights in the ddexC:HostSoundCarrier.')

    
    # Element TrackNumber uses Python identifier TrackNumber
    __TrackNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TrackNumber'), 'TrackNumber', '__httpddex_netxml20120214ddexC_HostSoundCarrier_TrackNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1750, 9), )

    
    TrackNumber = property(__TrackNumber.value, __TrackNumber.set, None, 'The ddex:TrackNumber of the ddex:SoundRecording within the ddexC:HostSoundCarrier.')

    
    # Element VolumeNumberInSet uses Python identifier VolumeNumberInSet
    __VolumeNumberInSet = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VolumeNumberInSet'), 'VolumeNumberInSet', '__httpddex_netxml20120214ddexC_HostSoundCarrier_VolumeNumberInSet', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1755, 9), )

    
    VolumeNumberInSet = property(__VolumeNumberInSet.value, __VolumeNumberInSet.set, None, "The ddex:SequenceNumber within the ddex:Set of the volume containing the ddex:SoundRecording, where the ddexC:HostSoundCarrier is a ddex:Set (such as a 'box set' of CDs).")

    _ElementMap.update({
        __ReleaseId.name() : __ReleaseId,
        __RightsAgreementId.name() : __RightsAgreementId,
        __Title.name() : __Title,
        __DisplayArtist.name() : __DisplayArtist,
        __AdministratingRecordCompany.name() : __AdministratingRecordCompany,
        __TrackNumber.name() : __TrackNumber,
        __VolumeNumberInSet.name() : __VolumeNumberInSet
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'HostSoundCarrier', HostSoundCarrier)


# Complex type {http://ddex.net/xml/20120214/ddexC}ICPN with content type SIMPLE
class ICPN (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:ICPN."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ICPN')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1762, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute IsEan uses Python identifier IsEan
    __IsEan = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsEan'), 'IsEan', '__httpddex_netxml20120214ddexC_ICPN_IsEan', pyxb.binding.datatypes.boolean, required=True)
    __IsEan._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1768, 12)
    __IsEan._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1768, 12)
    
    IsEan = property(__IsEan.value, __IsEan.set, None, 'The ddex:Flag indicating whether the ddexC:ICPN is specifically an ddex:EAN (=True) or a ddex:UPC (=False). This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __IsEan.name() : __IsEan
    })
Namespace.addCategoryObject('typeBinding', 'ICPN', ICPN)


# Complex type {http://ddex.net/xml/20120214/ddexC}ImageDetailsByTerritory with content type ELEMENT_ONLY
class ImageDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors, Dates and other attributes of an ddex:Image which may vary according to ddex:Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ImageDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1800, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_ImageDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1806, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:Image details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_ImageDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1811, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:Image details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20120214ddexC_ImageDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1817, 9), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A ddex:Composite containing details of a ddex:Contributor to the ddex:Image.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20120214ddexC_ImageDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1823, 9), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:Image.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20120214ddexC_ImageDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1829, 9), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A ddex:Composite containing details of the ddex:CLine for the ddex:Image.')

    
    # Element Description uses Python identifier Description
    __Description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Description'), 'Description', '__httpddex_netxml20120214ddexC_ImageDetailsByTerritory_Description', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1834, 9), )

    
    Description = property(__Description.value, __Description.set, None, 'A ddex:Composite containing a ddex:Description of the subject of the ddex:Image.')

    
    # Element CourtesyLine uses Python identifier CourtesyLine
    __CourtesyLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), 'CourtesyLine', '__httpddex_netxml20120214ddexC_ImageDetailsByTerritory_CourtesyLine', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1839, 9), )

    
    CourtesyLine = property(__CourtesyLine.value, __CourtesyLine.set, None, 'A ddex:Composite containing an ddex:Annotation which acknowledges record companies and/or other Parties giving permission for ddex:Artists or others featured on the ddex:Image.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20120214ddexC_ImageDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1844, 9), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Image was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_ImageDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1850, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1850, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:ImageDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __CLine.name() : __CLine,
        __Description.name() : __Description,
        __CourtesyLine.name() : __CourtesyLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'ImageDetailsByTerritory', ImageDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}ImageId with content type ELEMENT_ONLY
class ImageId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Identifiers of an ddex:Image."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ImageId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1856, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_ImageId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1861, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Image.')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_ImageId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1867, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1867, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'ImageId', ImageId)


# Complex type {http://ddex.net/xml/20120214/ddexC}IndirectResourceContributor with content type ELEMENT_ONLY
class IndirectResourceContributor (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of the ddex:Name, ddex:Identifier and role(s) of an indirect ddex:Contributor to a ddex:Resource."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'IndirectResourceContributor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1892, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_IndirectResourceContributor_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1898, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_IndirectResourceContributor_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1904, 15), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the PartyName(s).')

    
    # Element IndirectResourceContributorRole uses Python identifier IndirectResourceContributorRole
    __IndirectResourceContributorRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributorRole'), 'IndirectResourceContributorRole', '__httpddex_netxml20120214ddexC_IndirectResourceContributor_IndirectResourceContributorRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1916, 9), )

    
    IndirectResourceContributorRole = property(__IndirectResourceContributorRole.value, __IndirectResourceContributorRole.set, None, 'A ddex:Composite containing details of a role played by the indirect ddex:Contributor.')

    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_IndirectResourceContributor_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1923, 6)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1923, 6)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the indirect ResourceContributor in a group of ResourceContributors that have contributed to a ddex:Resource. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName,
        __IndirectResourceContributorRole.name() : __IndirectResourceContributorRole
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'IndirectResourceContributor', IndirectResourceContributor)


# Complex type {http://ddex.net/xml/20120214/ddexC}Keywords with content type SIMPLE
class Keywords (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Description containing ddex:Keywords."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Keywords')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1929, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Keywords_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1935, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1935, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:Keywords as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Keywords', Keywords)


# Complex type {http://ddex.net/xml/20120214/ddexC}LabelName with content type SIMPLE
class LabelName (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:LabelName."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'LabelName')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1943, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_LabelName_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1949, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1949, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:LabelName as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute LabelNameType uses Python identifier LabelNameType
    __LabelNameType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LabelNameType'), 'LabelNameType', '__httpddex_netxml20120214ddexC_LabelName_LabelNameType', pyxb.binding.datatypes.string)
    __LabelNameType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1954, 12)
    __LabelNameType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1954, 12)
    
    LabelNameType = property(__LabelNameType.value, __LabelNameType.set, None, 'A ddex:Type of ddex:LabelName. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode,
        __LabelNameType.name() : __LabelNameType
    })
Namespace.addCategoryObject('typeBinding', 'LabelName', LabelName)


# Complex type {http://ddex.net/xml/20120214/ddexC}MessageAuditTrail with content type ELEMENT_ONLY
class MessageAuditTrail (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing information about Parties in between the original ddex:MessageSender and ultimate ddex:MessageRecipient."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageAuditTrail')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2057, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MessageAuditTrailEvent uses Python identifier MessageAuditTrailEvent
    __MessageAuditTrailEvent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageAuditTrailEvent'), 'MessageAuditTrailEvent', '__httpddex_netxml20120214ddexC_MessageAuditTrail_MessageAuditTrailEvent', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2062, 9), )

    
    MessageAuditTrailEvent = property(__MessageAuditTrailEvent.value, __MessageAuditTrailEvent.set, None, 'A ddex:Composite containing details of a ddex:Party handling the ddex:Message and the ddex:Time at which the handling took place.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_MessageAuditTrail_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2069, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2069, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:MessageAuditTrail as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __MessageAuditTrailEvent.name() : __MessageAuditTrailEvent
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MessageAuditTrail', MessageAuditTrail)


# Complex type {http://ddex.net/xml/20120214/ddexC}MessageAuditTrailEvent with content type ELEMENT_ONLY
class MessageAuditTrailEvent (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Party handling a ddex:Message and the ddex:Time at which the handling took place."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageAuditTrailEvent')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2075, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MessagingPartyDescriptor uses Python identifier MessagingPartyDescriptor
    __MessagingPartyDescriptor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessagingPartyDescriptor'), 'MessagingPartyDescriptor', '__httpddex_netxml20120214ddexC_MessageAuditTrailEvent_MessagingPartyDescriptor', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2080, 9), )

    
    MessagingPartyDescriptor = property(__MessagingPartyDescriptor.value, __MessagingPartyDescriptor.set, None, 'A ddex:Composite containing details of a ddex:MessagingParty.')

    
    # Element DateTime uses Python identifier DateTime
    __DateTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DateTime'), 'DateTime', '__httpddex_netxml20120214ddexC_MessageAuditTrailEvent_DateTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2085, 9), )

    
    DateTime = property(__DateTime.value, __DateTime.set, None, 'The ddex:DateTime at which the ddex:Message was handled by the ddex:MessagingParty (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).')

    _ElementMap.update({
        __MessagingPartyDescriptor.name() : __MessagingPartyDescriptor,
        __DateTime.name() : __DateTime
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'MessageAuditTrailEvent', MessageAuditTrailEvent)


# Complex type {http://ddex.net/xml/20120214/ddexC}MessageHeader with content type ELEMENT_ONLY
class MessageHeader (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite placed at the beginning of each ddex:DdexMessage providing information about the ddex:Message, such as ddex:MessageSender, ddex:MessageRecipient and a ddex:Message creation time stamp."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageHeader')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2092, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MessageThreadId uses Python identifier MessageThreadId
    __MessageThreadId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageThreadId'), 'MessageThreadId', '__httpddex_netxml20120214ddexC_MessageHeader_MessageThreadId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2097, 9), )

    
    MessageThreadId = property(__MessageThreadId.value, __MessageThreadId.set, None, "A xs:string used to uniquely identify the thread of ddex:Messages of which the current ddex:Message is a part. One example of such a 'thread' is the chain of NewReleaseMessages being sent from ddex:ReleaseCreator to wholesale ddex:ReleaseDistributor 1 to retail ddex:DSP when communicating information about the same Release(s). A common ddex:MessageThreadId will allow all these messages to be tied together.")

    
    # Element MessageId uses Python identifier MessageId
    __MessageId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageId'), 'MessageId', '__httpddex_netxml20120214ddexC_MessageHeader_MessageId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2102, 9), )

    
    MessageId = property(__MessageId.value, __MessageId.set, None, 'A xs:string used to uniquely identify the current ddex:Message.')

    
    # Element MessageFileName uses Python identifier MessageFileName
    __MessageFileName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageFileName'), 'MessageFileName', '__httpddex_netxml20120214ddexC_MessageHeader_MessageFileName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2107, 9), )

    
    MessageFileName = property(__MessageFileName.value, __MessageFileName.set, None, 'The ddex:FileName, possibly including the ddex:FilePath, of the XML ddex:File containing the current ddex:Message.')

    
    # Element MessageSender uses Python identifier MessageSender
    __MessageSender = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageSender'), 'MessageSender', '__httpddex_netxml20120214ddexC_MessageHeader_MessageSender', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2112, 9), )

    
    MessageSender = property(__MessageSender.value, __MessageSender.set, None, 'A ddex:Composite containing details of the ddex:MessageSender.')

    
    # Element SentOnBehalfOf uses Python identifier SentOnBehalfOf
    __SentOnBehalfOf = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SentOnBehalfOf'), 'SentOnBehalfOf', '__httpddex_netxml20120214ddexC_MessageHeader_SentOnBehalfOf', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2117, 9), )

    
    SentOnBehalfOf = property(__SentOnBehalfOf.value, __SentOnBehalfOf.set, None, 'A ddex:Composite containing details of the ddex:Party on whose behalf the ddex:Message is sent.')

    
    # Element MessageRecipient uses Python identifier MessageRecipient
    __MessageRecipient = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageRecipient'), 'MessageRecipient', '__httpddex_netxml20120214ddexC_MessageHeader_MessageRecipient', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2122, 9), )

    
    MessageRecipient = property(__MessageRecipient.value, __MessageRecipient.set, None, 'A ddex:Composite containing details of the ddex:MessageRecipient.')

    
    # Element MessageCreatedDateTime uses Python identifier MessageCreatedDateTime
    __MessageCreatedDateTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageCreatedDateTime'), 'MessageCreatedDateTime', '__httpddex_netxml20120214ddexC_MessageHeader_MessageCreatedDateTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2127, 9), )

    
    MessageCreatedDateTime = property(__MessageCreatedDateTime.value, __MessageCreatedDateTime.set, None, 'The ddex:DateTime on which the ddex:Message was created (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).')

    
    # Element MessageAuditTrail uses Python identifier MessageAuditTrail
    __MessageAuditTrail = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageAuditTrail'), 'MessageAuditTrail', '__httpddex_netxml20120214ddexC_MessageHeader_MessageAuditTrail', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2132, 9), )

    
    MessageAuditTrail = property(__MessageAuditTrail.value, __MessageAuditTrail.set, None, 'A ddex:Composite containing information about Parties in between the original ddex:MessageSender and ultimate ddex:MessageRecipient.')

    
    # Element Comment uses Python identifier Comment
    __Comment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Comment'), 'Comment', '__httpddex_netxml20120214ddexC_MessageHeader_Comment', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2137, 9), )

    
    Comment = property(__Comment.value, __Comment.set, None, 'A ddex:Composite containing a human-readable ddex:Comment about the ddex:Message.')

    
    # Element MessageControlType uses Python identifier MessageControlType
    __MessageControlType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MessageControlType'), 'MessageControlType', '__httpddex_netxml20120214ddexC_MessageHeader_MessageControlType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2142, 9), )

    
    MessageControlType = property(__MessageControlType.value, __MessageControlType.set, None, 'The indicator used to distinguish a live ddex:Message from a test ddex:Message.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_MessageHeader_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2148, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2148, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:MessageHeader as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __MessageThreadId.name() : __MessageThreadId,
        __MessageId.name() : __MessageId,
        __MessageFileName.name() : __MessageFileName,
        __MessageSender.name() : __MessageSender,
        __SentOnBehalfOf.name() : __SentOnBehalfOf,
        __MessageRecipient.name() : __MessageRecipient,
        __MessageCreatedDateTime.name() : __MessageCreatedDateTime,
        __MessageAuditTrail.name() : __MessageAuditTrail,
        __Comment.name() : __Comment,
        __MessageControlType.name() : __MessageControlType
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MessageHeader', MessageHeader)


# Complex type {http://ddex.net/xml/20120214/ddexC}MessageNotificationPeriod with content type ELEMENT_ONLY
class MessageNotificationPeriod (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a reporting ddex:Period covered by a ddex:Message. It must contain at least one out of ddex:StartDate or ddex:EndDate. The ddex:StartDate must be earlier than the ddex:EndDate if both are provided."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageNotificationPeriod')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2154, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element StartDate uses Python identifier StartDate
    __StartDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartDate'), 'StartDate', '__httpddex_netxml20120214ddexC_MessageNotificationPeriod_StartDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2159, 9), )

    
    StartDate = property(__StartDate.value, __StartDate.set, None, 'The Date that marks the beginning of the ddex:Period (in ISO 8601:2004 format: YYYY-MM-DD). This cannot be a Date in the future.')

    
    # Element EndDate uses Python identifier EndDate
    __EndDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndDate'), 'EndDate', '__httpddex_netxml20120214ddexC_MessageNotificationPeriod_EndDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2164, 9), )

    
    EndDate = property(__EndDate.value, __EndDate.set, None, 'The Date that marks the end of the ddex:Period (in ISO 8601:2004 format: YYYY-MM-DD). This cannot be a Date in the future.')

    _ElementMap.update({
        __StartDate.name() : __StartDate,
        __EndDate.name() : __EndDate
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'MessageNotificationPeriod', MessageNotificationPeriod)


# Complex type {http://ddex.net/xml/20120214/ddexC}MessagingParty with content type ELEMENT_ONLY
class MessagingParty (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:MessagingParty."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessagingParty')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2171, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_MessagingParty_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2176, 9), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party handling the ddex:Message. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_MessagingParty_PartyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2181, 9), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the ddex:PartyNames for the ddex:Party handling the ddex:Message.')

    
    # Element TradingName uses Python identifier TradingName
    __TradingName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TradingName'), 'TradingName', '__httpddex_netxml20120214ddexC_MessagingParty_TradingName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2186, 9), )

    
    TradingName = property(__TradingName.value, __TradingName.set, None, 'A ddex:Composite containing a ddex:TradingName for the ddex:Party handling the ddex:Message.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_MessagingParty_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2192, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2192, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:MessagingParty as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName,
        __TradingName.name() : __TradingName
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MessagingParty', MessagingParty)


# Complex type {http://ddex.net/xml/20120214/ddexC}MidiDetailsByTerritory with content type ELEMENT_ONLY
class MidiDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors and other attributes of a ddex:MIDI which may vary according to ddex:Territory of release. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MidiDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2198, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2204, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:MIDI details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2209, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:MIDI details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2215, 9), )

    
    Title = property(__Title.value, __Title.set, None, 'A ddex:Composite containing details of a ddex:Title of the ddex:MIDI.')

    
    # Element DisplayArtist uses Python identifier DisplayArtist
    __DisplayArtist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), 'DisplayArtist', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_DisplayArtist', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2220, 9), )

    
    DisplayArtist = property(__DisplayArtist.value, __DisplayArtist.set, None, 'A ddex:Composite containing details of the ddex:DisplayArtist for the ddex:MIDI. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2225, 9), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A ddex:Composite containing details of a ddex:Contributor to the ddex:MIDI.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2231, 9), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:MIDI.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2237, 9), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:MIDI.')

    
    # Element LabelName uses Python identifier LabelName
    __LabelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LabelName'), 'LabelName', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_LabelName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2242, 9), )

    
    LabelName = property(__LabelName.value, __LabelName.set, None, 'A ddex:Composite containing the ddex:Name of the ddex:Label under which the ddex:Release is to be marketed.')

    
    # Element RightsController uses Python identifier RightsController
    __RightsController = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsController'), 'RightsController', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_RightsController', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2247, 9), )

    
    RightsController = property(__RightsController.value, __RightsController.set, None, 'A ddex:Composite containing details of ddex:RightsController of Rights in the ddex:MIDI.')

    
    # Element RemasteredDate uses Python identifier RemasteredDate
    __RemasteredDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), 'RemasteredDate', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_RemasteredDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2253, 9), )

    
    RemasteredDate = property(__RemasteredDate.value, __RemasteredDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:MIDI was re-mastered (usually digitally).')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2258, 9), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:MIDI was originally published, whether for physical or electronic/online distribution.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2263, 9), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A ddex:Composite containing details of the ddex:CLine for the ddex:MIDI.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_MidiDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2269, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2269, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:MidiDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __Title.name() : __Title,
        __DisplayArtist.name() : __DisplayArtist,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __RightsAgreementId.name() : __RightsAgreementId,
        __LabelName.name() : __LabelName,
        __RightsController.name() : __RightsController,
        __RemasteredDate.name() : __RemasteredDate,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate,
        __CLine.name() : __CLine
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MidiDetailsByTerritory', MidiDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}MidiId with content type ELEMENT_ONLY
class MidiId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Identifiers of a Midi."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MidiId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2275, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_MidiId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2280, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the Midi.')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_MidiId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2286, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2286, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'MidiId', MidiId)


# Complex type {http://ddex.net/xml/20120214/ddexC}MusicalWork with content type ELEMENT_ONLY
class MusicalWork (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:MusicalWork."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWork')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2311, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MusicalWorkId uses Python identifier MusicalWorkId
    __MusicalWorkId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkId'), 'MusicalWorkId', '__httpddex_netxml20120214ddexC_MusicalWork_MusicalWorkId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2316, 9), )

    
    MusicalWorkId = property(__MusicalWorkId.value, __MusicalWorkId.set, None, 'A ddex:Composite containing details of a ddex:MusicalWorkId of the ddexC:MusicalWork.')

    
    # Element MusicalWorkReference uses Python identifier MusicalWorkReference
    __MusicalWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkReference'), 'MusicalWorkReference', '__httpddex_netxml20120214ddexC_MusicalWork_MusicalWorkReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2321, 9), )

    
    MusicalWorkReference = property(__MusicalWorkReference.value, __MusicalWorkReference.set, None, 'The ddex:Identifier (specific to the ddex:Message) of the ddexC:MusicalWork within the ddex:Release which contains it. This is a ddex:LocalMusicalWorkAnchor starting with the letter W.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20120214ddexC_MusicalWork_ReferenceTitle', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2331, 9), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A ddex:Composite containing details of a ddex:ReferenceTitle of the ddexC:MusicalWork.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20120214ddexC_MusicalWork_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2336, 9), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the ddexC:MusicalWork.')

    
    # Element MusicalWorkContributor uses Python identifier MusicalWorkContributor
    __MusicalWorkContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor'), 'MusicalWorkContributor', '__httpddex_netxml20120214ddexC_MusicalWork_MusicalWorkContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2341, 9), )

    
    MusicalWorkContributor = property(__MusicalWorkContributor.value, __MusicalWorkContributor.set, None, 'A ddex:Composite containing details a ddex:MusicalWorkContributor to the ddexC:MusicalWork.')

    
    # Element MusicalWorkType uses Python identifier MusicalWorkType
    __MusicalWorkType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkType'), 'MusicalWorkType', '__httpddex_netxml20120214ddexC_MusicalWork_MusicalWorkType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2347, 9), )

    
    MusicalWorkType = property(__MusicalWorkType.value, __MusicalWorkType.set, None, 'A ddex:Composite containing details of the ddex:Type of the ddexC:MusicalWork.')

    
    # Element RightShare uses Python identifier RightShare
    __RightShare = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShare'), 'RightShare', '__httpddex_netxml20120214ddexC_MusicalWork_RightShare', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2353, 9), )

    
    RightShare = property(__RightShare.value, __RightShare.set, None, 'A ddex:Composite containing details of a ddex:RightShare for the ddexC:MusicalWork.')

    
    # Element MusicalWorkDetailsByTerritory uses Python identifier MusicalWorkDetailsByTerritory
    __MusicalWorkDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkDetailsByTerritory'), 'MusicalWorkDetailsByTerritory', '__httpddex_netxml20120214ddexC_MusicalWork_MusicalWorkDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2358, 9), )

    
    MusicalWorkDetailsByTerritory = property(__MusicalWorkDetailsByTerritory.value, __MusicalWorkDetailsByTerritory.set, None, 'A ddex:Composite containing details of ddex:Descriptors and other attributes of the ddexC:MusicalWork which may vary according to ddex:Territory of release. ')

    
    # Attribute IsUpdated uses Python identifier IsUpdated
    __IsUpdated = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsUpdated'), 'IsUpdated', '__httpddex_netxml20120214ddexC_MusicalWork_IsUpdated', pyxb.binding.datatypes.boolean)
    __IsUpdated._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2365, 6)
    __IsUpdated._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2365, 6)
    
    IsUpdated = property(__IsUpdated.value, __IsUpdated.set, None, 'The ddex:Flag indicating whether the ddexC:MusicalWork ddex:Element was updated (=True) or not (=False). The ddex:Flag may only be used when the ddex:UpdateIndicator is set to ddex:UpdateMessage. When this ddex:Boolean ddex:Flag is set to true, the ddex:MessageRecipient is expected to replace any previously provided ddexC:MusicalWork data with the now provided data.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_MusicalWork_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2370, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2370, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:MusicalWork as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __MusicalWorkId.name() : __MusicalWorkId,
        __MusicalWorkReference.name() : __MusicalWorkReference,
        __ReferenceTitle.name() : __ReferenceTitle,
        __RightsAgreementId.name() : __RightsAgreementId,
        __MusicalWorkContributor.name() : __MusicalWorkContributor,
        __MusicalWorkType.name() : __MusicalWorkType,
        __RightShare.name() : __RightShare,
        __MusicalWorkDetailsByTerritory.name() : __MusicalWorkDetailsByTerritory
    })
    _AttributeMap.update({
        __IsUpdated.name() : __IsUpdated,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWork', MusicalWork)


# Complex type {http://ddex.net/xml/20120214/ddexC}MusicalWorkContributor with content type ELEMENT_ONLY
class MusicalWorkContributor (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details a ddex:MusicalWorkContributor."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkContributor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2376, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_MusicalWorkContributor_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2382, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_MusicalWorkContributor_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2388, 15), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the PartyName(s).')

    
    # Element MusicalWorkContributorRole uses Python identifier MusicalWorkContributorRole
    __MusicalWorkContributorRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributorRole'), 'MusicalWorkContributorRole', '__httpddex_netxml20120214ddexC_MusicalWorkContributor_MusicalWorkContributorRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2400, 9), )

    
    MusicalWorkContributorRole = property(__MusicalWorkContributorRole.value, __MusicalWorkContributorRole.set, None, "A ddex:Composite containing details of a role played by the ddex:Contributor in relation to the ddex:MusicalWork. Note: This can be used in a ddex:DdexMessage in relation to any ddex:Work, ddex:Performance or ddex:Fixation any of which may form the whole or part of the ddex:Resource itself. Example: if an 'AssociatedPerformer' is shown as a ddex:Contributor to a ddex:MusicalWork it refers to a performer of a ddex:Resource (e.g. a ddex:SoundRecording) expressing the ddex:MusicalWork.")

    
    # Element SocietyAffiliation uses Python identifier SocietyAffiliation
    __SocietyAffiliation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SocietyAffiliation'), 'SocietyAffiliation', '__httpddex_netxml20120214ddexC_MusicalWorkContributor_SocietyAffiliation', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2406, 9), )

    
    SocietyAffiliation = property(__SocietyAffiliation.value, __SocietyAffiliation.set, None, 'A ddex:Composite containing details of a society affiliation for the ddexC:MusicalWorkContributor.')

    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_MusicalWorkContributor_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2413, 6)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2413, 6)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ddexC:MusicalWorkContributor in a group of ddex:MusicalWorkContributors that have contributed to a ddex:MusicalWork. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName,
        __MusicalWorkContributorRole.name() : __MusicalWorkContributorRole,
        __SocietyAffiliation.name() : __SocietyAffiliation
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkContributor', MusicalWorkContributor)


# Complex type {http://ddex.net/xml/20120214/ddexC}MusicalWorkDetailsByTerritory with content type ELEMENT_ONLY
class MusicalWorkDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors and other attributes of a ddex:MusicalWork which may vary according to ddex:Territory of release. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2438, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_MusicalWorkDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2444, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:MusicalWork details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_MusicalWorkDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2449, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:MusicalWork details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element MusicalWorkContributor uses Python identifier MusicalWorkContributor
    __MusicalWorkContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor'), 'MusicalWorkContributor', '__httpddex_netxml20120214ddexC_MusicalWorkDetailsByTerritory_MusicalWorkContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2455, 9), )

    
    MusicalWorkContributor = property(__MusicalWorkContributor.value, __MusicalWorkContributor.set, None, 'A ddex:Composite containing details a ddex:MusicalWorkContributor to the ddex:MusicalWork.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_MusicalWorkDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2462, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2462, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:MusicalWorkDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __MusicalWorkContributor.name() : __MusicalWorkContributor
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkDetailsByTerritory', MusicalWorkDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}MusicalWorkId with content type ELEMENT_ONLY
class MusicalWorkId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:MusicalWorkId."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2468, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISWC uses Python identifier ISWC
    __ISWC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISWC'), 'ISWC', '__httpddex_netxml20120214ddexC_MusicalWorkId_ISWC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2473, 9), )

    
    ISWC = property(__ISWC.value, __ISWC.set, None, "The ddex:ISWC (International Standard Musical ddex:Work Code defined in ISO 15707) identifying the ddex:MusicalWork. An ddex:ISWC comprises three parts: the letter 'T', followed by nine digits and then one check digit.")

    
    # Element OpusNumber uses Python identifier OpusNumber
    __OpusNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OpusNumber'), 'OpusNumber', '__httpddex_netxml20120214ddexC_MusicalWorkId_OpusNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2478, 9), )

    
    OpusNumber = property(__OpusNumber.value, __OpusNumber.set, None, 'The ddexC:MusicalWorkId identifying the ddex:MusicalWork within the catalog of its ddex:Composer (typically of classical music) as an opus number.')

    
    # Element ComposerCatalogNumber uses Python identifier ComposerCatalogNumber
    __ComposerCatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ComposerCatalogNumber'), 'ComposerCatalogNumber', '__httpddex_netxml20120214ddexC_MusicalWorkId_ComposerCatalogNumber', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2483, 9), )

    
    ComposerCatalogNumber = property(__ComposerCatalogNumber.value, __ComposerCatalogNumber.set, None, "A ddexC:MusicalWorkId identifying a ddex:MusicalWork within the catalog of its ddex:Composer (typically of classical music) according to a standardized numbering (e.g. 'K' numbers for Koechel's catalog of Mozart).")

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_MusicalWorkId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2489, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:MusicalWork.')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_MusicalWorkId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2496, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2496, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ISWC.name() : __ISWC,
        __OpusNumber.name() : __OpusNumber,
        __ComposerCatalogNumber.name() : __ComposerCatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkId', MusicalWorkId)


# Complex type {http://ddex.net/xml/20120214/ddexC}Name with content type SIMPLE
class Name (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Name."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Name')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2521, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Name_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2527, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2527, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:Name as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Name', Name)


# Complex type {http://ddex.net/xml/20120214/ddexC}NumberOfSubscribers with content type ELEMENT_ONLY
class NumberOfSubscribers (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a ddex:NumberOfSubscribers (applicable only where a ddex:Subscription ddex:Service is employed)."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'NumberOfSubscribers')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2549, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Quantity uses Python identifier Quantity
    __Quantity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Quantity'), 'Quantity', '__httpddex_netxml20120214ddexC_NumberOfSubscribers_Quantity', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2554, 9), )

    
    Quantity = property(__Quantity.value, __Quantity.set, None, 'The number of ddex:Consumers using the ddex:DSP service specified for the ddex:UseType.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20120214ddexC_NumberOfSubscribers_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2559, 9), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20120214ddexC_NumberOfSubscribers_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2564, 9), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20120214ddexC_NumberOfSubscribers_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2570, 9), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20120214ddexC_NumberOfSubscribers_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2576, 9), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A ddex:Composite containing details of a ddex:Carrier.')

    _ElementMap.update({
        __Quantity.name() : __Quantity,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'NumberOfSubscribers', NumberOfSubscribers)


# Complex type {http://ddex.net/xml/20120214/ddexC}PartyDescriptor with content type ELEMENT_ONLY
class PartyDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Party. Parties are typically described through ddex:Names and/or ddex:Identifiers."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PartyDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2677, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_PartyDescriptor_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2682, 9), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_PartyDescriptor_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2688, 12), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the PartyName(s).')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'PartyDescriptor', PartyDescriptor)


# Complex type {http://ddex.net/xml/20120214/ddexC}PartyId with content type SIMPLE
class PartyId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:PartyId. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PartyId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2701, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_PartyId_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2707, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2707, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:PartyId if it belongs to a proprietary ddex:Party xs:ID scheme. If the ddexC:PartyId is a DPID, the ddex:Namespace ddex:Element must not be used. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute IsDPID uses Python identifier IsDPID
    __IsDPID = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsDPID'), 'IsDPID', '__httpddex_netxml20120214ddexC_PartyId_IsDPID', pyxb.binding.datatypes.boolean)
    __IsDPID._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2712, 12)
    __IsDPID._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2712, 12)
    
    IsDPID = property(__IsDPID.value, __IsDPID.set, None, 'The ddex:Flag indicating whether the ddexC:PartyId is a ddex:DPID (=True) or not (=False). This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute IsISNI uses Python identifier IsISNI
    __IsISNI = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsISNI'), 'IsISNI', '__httpddex_netxml20120214ddexC_PartyId_IsISNI', pyxb.binding.datatypes.boolean)
    __IsISNI._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2717, 12)
    __IsISNI._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2717, 12)
    
    IsISNI = property(__IsISNI.value, __IsISNI.set, None, 'The ddex:Flag indicating whether the ddexC:PartyId is an ddex:ISNI (=True) or not (=False). This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __IsDPID.name() : __IsDPID,
        __IsISNI.name() : __IsISNI
    })
Namespace.addCategoryObject('typeBinding', 'PartyId', PartyId)


# Complex type {http://ddex.net/xml/20120214/ddexC}PartyName with content type ELEMENT_ONLY
class PartyName (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:PartyName. ddex:Name details for a ddex:Party typically either contain a ddex:FullName or a ddex:KeyName."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PartyName')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2725, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element FullName uses Python identifier FullName
    __FullName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FullName'), 'FullName', '__httpddex_netxml20120214ddexC_PartyName_FullName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2730, 9), )

    
    FullName = property(__FullName.value, __FullName.set, None, 'A ddex:Composite containing the complete ddex:Name of the ddex:Party, in its normal form of presentation (e.g. John H. Smith, Acme Music Inc, A ddex:Composite containing the Beatles).')

    
    # Element FullNameAsciiTranscribed uses Python identifier FullNameAsciiTranscribed
    __FullNameAsciiTranscribed = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FullNameAsciiTranscribed'), 'FullNameAsciiTranscribed', '__httpddex_netxml20120214ddexC_PartyName_FullNameAsciiTranscribed', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2735, 9), )

    
    FullNameAsciiTranscribed = property(__FullNameAsciiTranscribed.value, __FullNameAsciiTranscribed.set, None, 'The ddex:FullName transcribed using 7-bit ddex:ASCII code.')

    
    # Element FullNameIndexed uses Python identifier FullNameIndexed
    __FullNameIndexed = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FullNameIndexed'), 'FullNameIndexed', '__httpddex_netxml20120214ddexC_PartyName_FullNameIndexed', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2740, 9), )

    
    FullNameIndexed = property(__FullNameIndexed.value, __FullNameIndexed.set, None, 'A ddex:Composite containing the complete ddex:Name of the ddex:Party in the form in which it normally appears in an alphabetic index, with the ddex:KeyName first (e.g. Smith, John H.; Beatles, A ddex:Composite containing the).')

    
    # Element NamesBeforeKeyName uses Python identifier NamesBeforeKeyName
    __NamesBeforeKeyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NamesBeforeKeyName'), 'NamesBeforeKeyName', '__httpddex_netxml20120214ddexC_PartyName_NamesBeforeKeyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2745, 9), )

    
    NamesBeforeKeyName = property(__NamesBeforeKeyName.value, __NamesBeforeKeyName.set, None, "A ddex:Composite containing the Name(s) preceding the ddex:KeyName in the ddex:FullName (and that is placed after it in a ddex:FullNameIndexed). Examples: 'George' in 'George Michael'; 'John Fitzgerald' in 'John Fitzgerald Kennedy'. Not all ddex:PartyNames have a ddex:NamesBeforeKeyName (e.g. Madonna, EMI Music Inc).")

    
    # Element KeyName uses Python identifier KeyName
    __KeyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'KeyName'), 'KeyName', '__httpddex_netxml20120214ddexC_PartyName_KeyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2750, 9), )

    
    KeyName = property(__KeyName.value, __KeyName.set, None, "A ddex:Composite containing the ddex:Part of a ddex:Name of the ddex:Party normally used to index an entry in an alphabetical list, such as 'Smith' (in John Smith) or 'Garcia Marquez' or 'Madonna' or 'Francis de Sales' (in Saint Francis de Sales). For persons, this normally corresponds to the 'family name' or names, which in Western name forms usually comes as a surname at the end of a ddex:FullName, and in Asian name forms often at the beginning of a ddex:FullName. ")

    
    # Element NamesAfterKeyName uses Python identifier NamesAfterKeyName
    __NamesAfterKeyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NamesAfterKeyName'), 'NamesAfterKeyName', '__httpddex_netxml20120214ddexC_PartyName_NamesAfterKeyName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2755, 9), )

    
    NamesAfterKeyName = property(__NamesAfterKeyName.value, __NamesAfterKeyName.set, None, "A ddex:Composite containing the Name(s) following the ddex:KeyName. Example:'Ibrahim' (in Anwar Ibrahim). This is common, e.g., in many Asian personal name forms where a ddex:FullName begins with the ddex:KeyName, which is followed by other names.")

    
    # Element AbbreviatedName uses Python identifier AbbreviatedName
    __AbbreviatedName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AbbreviatedName'), 'AbbreviatedName', '__httpddex_netxml20120214ddexC_PartyName_AbbreviatedName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2760, 9), )

    
    AbbreviatedName = property(__AbbreviatedName.value, __AbbreviatedName.set, None, 'A ddex:Composite containing a short version of the ddexC:PartyName (e.g. for use on devices with a small display).')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_PartyName_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2766, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2766, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:PartyName as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __FullName.name() : __FullName,
        __FullNameAsciiTranscribed.name() : __FullNameAsciiTranscribed,
        __FullNameIndexed.name() : __FullNameIndexed,
        __NamesBeforeKeyName.name() : __NamesBeforeKeyName,
        __KeyName.name() : __KeyName,
        __NamesAfterKeyName.name() : __NamesAfterKeyName,
        __AbbreviatedName.name() : __AbbreviatedName
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'PartyName', PartyName)


# Complex type {http://ddex.net/xml/20120214/ddexC}Period with content type ELEMENT_ONLY
class Period (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details about a ddex:Period of ddex:Time. ddex:Periods are typically described by at least a ddex:StartDate or ddex:EndDate."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Period')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2772, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element StartDate uses Python identifier StartDate
    __StartDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartDate'), 'StartDate', '__httpddex_netxml20120214ddexC_Period_StartDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2778, 12), )

    
    StartDate = property(__StartDate.value, __StartDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of an ddex:Event that marks the beginning of the ddexC:Period (in ISO 8601:2004 format: YYYY-MM-DD). The ddex:StartDate must be earlier than the ddex:EndDate if both are provided.')

    
    # Element EndDate uses Python identifier EndDate
    __EndDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndDate'), 'EndDate', '__httpddex_netxml20120214ddexC_Period_EndDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2783, 12), )

    
    EndDate = property(__EndDate.value, __EndDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of an ddex:Event that marks the end of the ddexC:Period (in ISO 8601:2004 format: YYYY-MM-DD). The ddex:EndDate must be later than the ddex:StartDate if both are provided.')

    
    # Element StartDateTime uses Python identifier StartDateTime
    __StartDateTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartDateTime'), 'StartDateTime', '__httpddex_netxml20120214ddexC_Period_StartDateTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2790, 12), )

    
    StartDateTime = property(__StartDateTime.value, __StartDateTime.set, None, 'A ddex:Composite containing details of the ddex:DateTime and ddex:Place of an ddex:Event that marks the beginning of the ddexC:Period (in ISO 8601:2004 format: YYYY-DD-MMThh:mm:ss). The StartDateTime must be earlier than the EndDateTime if both are provided.')

    
    # Element EndDateTime uses Python identifier EndDateTime
    __EndDateTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndDateTime'), 'EndDateTime', '__httpddex_netxml20120214ddexC_Period_EndDateTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2795, 12), )

    
    EndDateTime = property(__EndDateTime.value, __EndDateTime.set, None, 'A ddex:Composite containing details of the ddex:DateTime and ddex:Place of an ddex:Event that marks the end of the ddexC:Period (in ISO 8601:2004 format: YYYY-DD-MMThh:mm:ss). The EndDateTime must be later than the StartDateTime if both are provided.')

    _ElementMap.update({
        __StartDate.name() : __StartDate,
        __EndDate.name() : __EndDate,
        __StartDateTime.name() : __StartDateTime,
        __EndDateTime.name() : __EndDateTime
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'Period', Period)


# Complex type {http://ddex.net/xml/20120214/ddexC}PriceInformation with content type ELEMENT_ONLY
class PriceInformation (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Price."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PriceInformation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2831, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Description uses Python identifier Description
    __Description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Description'), 'Description', '__httpddex_netxml20120214ddexC_PriceInformation_Description', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2836, 9), )

    
    Description = property(__Description.value, __Description.set, None, 'A ddex:Composite containing a ddex:Description of the differences between multiple ddexC:PriceInformation ddex:Composites.')

    
    # Element PriceRangeType uses Python identifier PriceRangeType
    __PriceRangeType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PriceRangeType'), 'PriceRangeType', '__httpddex_netxml20120214ddexC_PriceInformation_PriceRangeType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2841, 9), )

    
    PriceRangeType = property(__PriceRangeType.value, __PriceRangeType.set, None, "A ddex:Composite containing a ddex:Type of ddex:Price according to its value range. Typical examples include 'budget' and 'front line'.")

    
    # Element PriceType uses Python identifier PriceType
    __PriceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PriceType'), 'PriceType', '__httpddex_netxml20120214ddexC_PriceInformation_PriceType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2846, 9), )

    
    PriceType = property(__PriceType.value, __PriceType.set, None, 'A ddex:Composite containing further details of the ddex:Price. Often used to refine the ddex:PriceRangeType.')

    
    # Element WholesalePricePerUnit uses Python identifier WholesalePricePerUnit
    __WholesalePricePerUnit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'WholesalePricePerUnit'), 'WholesalePricePerUnit', '__httpddex_netxml20120214ddexC_PriceInformation_WholesalePricePerUnit', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2851, 9), )

    
    WholesalePricePerUnit = property(__WholesalePricePerUnit.value, __WholesalePricePerUnit.set, None, 'A ddex:Composite containing details of a wholesale ddex:Price for a single unit of Usage. Note that this ddex:Price applies to all ddex:UseTypes referenced in a DealTerm ddex:Composite.')

    
    # Element BulkOrderWholesalePricePerUnit uses Python identifier BulkOrderWholesalePricePerUnit
    __BulkOrderWholesalePricePerUnit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'BulkOrderWholesalePricePerUnit'), 'BulkOrderWholesalePricePerUnit', '__httpddex_netxml20120214ddexC_PriceInformation_BulkOrderWholesalePricePerUnit', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2856, 9), )

    
    BulkOrderWholesalePricePerUnit = property(__BulkOrderWholesalePricePerUnit.value, __BulkOrderWholesalePricePerUnit.set, None, 'A ddex:Composite containing details of a wholesale ddex:Price for a single unit. Note that the size of a bulk order is defined in the contract between ddex:MessageSender and the ddex:MessageRecipient.')

    
    # Element SuggestedRetailPrice uses Python identifier SuggestedRetailPrice
    __SuggestedRetailPrice = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SuggestedRetailPrice'), 'SuggestedRetailPrice', '__httpddex_netxml20120214ddexC_PriceInformation_SuggestedRetailPrice', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2861, 9), )

    
    SuggestedRetailPrice = property(__SuggestedRetailPrice.value, __SuggestedRetailPrice.set, None, 'A ddex:Composite containing details of a suggested retail ddex:Price.')

    _ElementMap.update({
        __Description.name() : __Description,
        __PriceRangeType.name() : __PriceRangeType,
        __PriceType.name() : __PriceType,
        __WholesalePricePerUnit.name() : __WholesalePricePerUnit,
        __BulkOrderWholesalePricePerUnit.name() : __BulkOrderWholesalePricePerUnit,
        __SuggestedRetailPrice.name() : __SuggestedRetailPrice
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'PriceInformation', PriceInformation)


# Complex type {http://ddex.net/xml/20120214/ddexC}PromotionalCode with content type SIMPLE
class PromotionalCode (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:PromotionalCode."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PromotionalCode')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2915, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_PromotionalCode_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2921, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2921, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:PromotionalCode. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'PromotionalCode', PromotionalCode)


# Complex type {http://ddex.net/xml/20120214/ddexC}ProprietaryId with content type SIMPLE
class ProprietaryId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ProprietaryIdentifier."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ProprietaryId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2929, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ProprietaryId_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2935, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2935, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ProprietaryId. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'ProprietaryId', ProprietaryId)


# Complex type {http://ddex.net/xml/20120214/ddexC}Reason with content type SIMPLE
class Reason (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Reason."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Reason')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2981, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Reason_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2987, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2987, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:Reason as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Reason', Reason)


# Complex type {http://ddex.net/xml/20120214/ddexC}RecordCompanyMarketShareData with content type ELEMENT_ONLY
class RecordCompanyMarketShareData (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing information to support the calculation of a record company's market share of all ddex:Releases provided by a ddex:DSP to ddex:Consumers for a specified ddex:UseType."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RecordCompanyMarketShareData')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3014, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseType uses Python identifier ReleaseType
    __ReleaseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseType'), 'ReleaseType', '__httpddex_netxml20120214ddexC_RecordCompanyMarketShareData_ReleaseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3019, 9), )

    
    ReleaseType = property(__ReleaseType.value, __ReleaseType.set, None, 'A ddex:Composite containing details of the form in which a ddex:ReleaseCreator anticipates offering the ddex:Release to ddex:Consumers.')

    
    # Element UnitsSoldTotal uses Python identifier UnitsSoldTotal
    __UnitsSoldTotal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UnitsSoldTotal'), 'UnitsSoldTotal', '__httpddex_netxml20120214ddexC_RecordCompanyMarketShareData_UnitsSoldTotal', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3024, 9), )

    
    UnitsSoldTotal = property(__UnitsSoldTotal.value, __UnitsSoldTotal.set, None, 'The total number of ddex:Releases sold of the ddex:ReleaseType.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20120214ddexC_RecordCompanyMarketShareData_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3029, 9), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20120214ddexC_RecordCompanyMarketShareData_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3034, 9), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20120214ddexC_RecordCompanyMarketShareData_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3040, 9), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20120214ddexC_RecordCompanyMarketShareData_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3046, 9), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A ddex:Composite containing details of a ddex:Carrier.')

    _ElementMap.update({
        __ReleaseType.name() : __ReleaseType,
        __UnitsSoldTotal.name() : __UnitsSoldTotal,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'RecordCompanyMarketShareData', RecordCompanyMarketShareData)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReferenceTitle with content type ELEMENT_ONLY
class ReferenceTitle (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReferenceTitle."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReferenceTitle')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3072, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TitleText uses Python identifier TitleText
    __TitleText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TitleText'), 'TitleText', '__httpddex_netxml20120214ddexC_ReferenceTitle_TitleText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3077, 9), )

    
    TitleText = property(__TitleText.value, __TitleText.set, None, 'A ddex:Composite containing the text of the ddexC:ReferenceTitle.')

    
    # Element SubTitle uses Python identifier SubTitle
    __SubTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SubTitle'), 'SubTitle', '__httpddex_netxml20120214ddexC_ReferenceTitle_SubTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3082, 9), )

    
    SubTitle = property(__SubTitle.value, __SubTitle.set, None, 'A ddex:Composite containing details of a ddex:SubTitle of the ddexC:ReferenceTitle, including ddex:Titles of ddex:Versions used to differentiate different versions of the same ddex:Title, as required by the ddex:GRid and ddex:ISRC ddex:ReferenceDescriptiveMetadataSets (where the SubTitle is called ddex:Version ddex:Title).')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_ReferenceTitle_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3088, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3088, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:ReferenceTitle as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TitleText.name() : __TitleText,
        __SubTitle.name() : __SubTitle
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'ReferenceTitle', ReferenceTitle)


# Complex type {http://ddex.net/xml/20120214/ddexC}RelatedLicenseOrClaimId with content type ELEMENT_ONLY
class RelatedLicenseOrClaimId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a RelatedLicenseOrClaimId."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RelatedLicenseOrClaimId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3094, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element LicenseOrClaimId uses Python identifier LicenseOrClaimId
    __LicenseOrClaimId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimId'), 'LicenseOrClaimId', '__httpddex_netxml20120214ddexC_RelatedLicenseOrClaimId_LicenseOrClaimId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3099, 9), )

    
    LicenseOrClaimId = property(__LicenseOrClaimId.value, __LicenseOrClaimId.set, None, 'A ddex:Composite containing details of an ddex:Identifier of the ddex:License or ddex:Claim.')

    
    # Element LicenseOrClaimUpdateReason uses Python identifier LicenseOrClaimUpdateReason
    __LicenseOrClaimUpdateReason = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimUpdateReason'), 'LicenseOrClaimUpdateReason', '__httpddex_netxml20120214ddexC_RelatedLicenseOrClaimId_LicenseOrClaimUpdateReason', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3104, 9), )

    
    LicenseOrClaimUpdateReason = property(__LicenseOrClaimUpdateReason.value, __LicenseOrClaimUpdateReason.set, None, 'A ddex:Composite containing details of a reason for an updated mwl:LicenseOrClaim.')

    _ElementMap.update({
        __LicenseOrClaimId.name() : __LicenseOrClaimId,
        __LicenseOrClaimUpdateReason.name() : __LicenseOrClaimUpdateReason
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'RelatedLicenseOrClaimId', RelatedLicenseOrClaimId)


# Complex type {http://ddex.net/xml/20120214/ddexC}RelatedLicenseOrClaimRequestId with content type ELEMENT_ONLY
class RelatedLicenseOrClaimRequestId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a RelatedLicenseOrClaimRequestId."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RelatedLicenseOrClaimRequestId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3112, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element LicenseOrClaimRequestId uses Python identifier LicenseOrClaimRequestId
    __LicenseOrClaimRequestId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimRequestId'), 'LicenseOrClaimRequestId', '__httpddex_netxml20120214ddexC_RelatedLicenseOrClaimRequestId_LicenseOrClaimRequestId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3117, 9), )

    
    LicenseOrClaimRequestId = property(__LicenseOrClaimRequestId.value, __LicenseOrClaimRequestId.set, None, 'A ddex:Composite containing details of an ddex:Identifier of mwl:LicenseOrClaimRequest.')

    
    # Element LicenseOrClaimRequestUpdateReason uses Python identifier LicenseOrClaimRequestUpdateReason
    __LicenseOrClaimRequestUpdateReason = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimRequestUpdateReason'), 'LicenseOrClaimRequestUpdateReason', '__httpddex_netxml20120214ddexC_RelatedLicenseOrClaimRequestId_LicenseOrClaimRequestUpdateReason', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3122, 9), )

    
    LicenseOrClaimRequestUpdateReason = property(__LicenseOrClaimRequestUpdateReason.value, __LicenseOrClaimRequestUpdateReason.set, None, 'A ddex:Composite containing details of a reason for an updated mwl:LicenseOrClaimRequest.')

    _ElementMap.update({
        __LicenseOrClaimRequestId.name() : __LicenseOrClaimRequestId,
        __LicenseOrClaimRequestUpdateReason.name() : __LicenseOrClaimRequestUpdateReason
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'RelatedLicenseOrClaimRequestId', RelatedLicenseOrClaimRequestId)


# Complex type {http://ddex.net/xml/20120214/ddexC}RelatedRelease with content type ELEMENT_ONLY
class RelatedRelease (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Release (or a ddex:PhysicalProduct or a ddex:DigitalProduct derived from such a ddex:Release) which is related to a ddex:Resource, ddex:Release or ddex:Product."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RelatedRelease')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3130, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20120214ddexC_RelatedRelease_ReleaseId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3135, 9), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid shall always to be used. If the ddex:Release contains only one ddex:SoundRecording, the ddex:ISRC of the ddex:SoundRecording may be used instead. If the ddex:Release is an abstraction of a complete ddex:PhysicalProduct (such as a CD ddex:Album), the ddex:ICPN of the ddex:PhysicalProduct may be used instead. More than one of these identifiers may be provided.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20120214ddexC_RelatedRelease_ReferenceTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3140, 9), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A ddex:Composite containing details of the ddex:ReferenceTitle of the ddex:Release.')

    
    # Element ReleaseSummaryDetailsByTerritory uses Python identifier ReleaseSummaryDetailsByTerritory
    __ReleaseSummaryDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory'), 'ReleaseSummaryDetailsByTerritory', '__httpddex_netxml20120214ddexC_RelatedRelease_ReleaseSummaryDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3145, 9), )

    
    ReleaseSummaryDetailsByTerritory = property(__ReleaseSummaryDetailsByTerritory.value, __ReleaseSummaryDetailsByTerritory.set, None, 'A ddex:Composite containing summary details of ddex:Descriptors and other attributes of the ddex:Release which may vary according to ddex:Territory of ddex:Release. ddex:Territory of ddex:Release may be the world.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20120214ddexC_RelatedRelease_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3151, 9), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:Release.')

    
    # Element ReleaseRelationshipType uses Python identifier ReleaseRelationshipType
    __ReleaseRelationshipType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseRelationshipType'), 'ReleaseRelationshipType', '__httpddex_netxml20120214ddexC_RelatedRelease_ReleaseRelationshipType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3156, 9), )

    
    ReleaseRelationshipType = property(__ReleaseRelationshipType.value, __ReleaseRelationshipType.set, None, 'A ddex:Composite containing details of the ddex:Type of the relationship between the two ddex:Releases.')

    
    # Element ReleaseDate uses Python identifier ReleaseDate
    __ReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseDate'), 'ReleaseDate', '__httpddex_netxml20120214ddexC_RelatedRelease_ReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3161, 9), )

    
    ReleaseDate = property(__ReleaseDate.value, __ReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the related ddex:Release is made available for Usage.')

    
    # Element OriginalReleaseDate uses Python identifier OriginalReleaseDate
    __OriginalReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate'), 'OriginalReleaseDate', '__httpddex_netxml20120214ddexC_RelatedRelease_OriginalReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3166, 9), )

    
    OriginalReleaseDate = property(__OriginalReleaseDate.value, __OriginalReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Release was or will be first made available for Usage, whether for physical or electronic/online distribution (in ISO 8601:2004 format: YYYY-MM-DD).')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_RelatedRelease_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3172, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3172, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ReleatedRelease as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __ReleaseId.name() : __ReleaseId,
        __ReferenceTitle.name() : __ReferenceTitle,
        __ReleaseSummaryDetailsByTerritory.name() : __ReleaseSummaryDetailsByTerritory,
        __RightsAgreementId.name() : __RightsAgreementId,
        __ReleaseRelationshipType.name() : __ReleaseRelationshipType,
        __ReleaseDate.name() : __ReleaseDate,
        __OriginalReleaseDate.name() : __OriginalReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'RelatedRelease', RelatedRelease)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseCollectionReferenceList with content type ELEMENT_ONLY
class ReleaseCollectionReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a list of ddex:ReleaseCollectionReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseCollectionReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3211, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element NumberOfCollections uses Python identifier NumberOfCollections
    __NumberOfCollections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), 'NumberOfCollections', '__httpddex_netxml20120214ddexC_ReleaseCollectionReferenceList_NumberOfCollections', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3216, 9), )

    
    NumberOfCollections = property(__NumberOfCollections.value, __NumberOfCollections.set, None, 'The number of referenced ddexC:Collections (typically Chapters).')

    
    # Element ReleaseCollectionReference uses Python identifier ReleaseCollectionReference
    __ReleaseCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseCollectionReference'), 'ReleaseCollectionReference', '__httpddex_netxml20120214ddexC_ReleaseCollectionReferenceList_ReleaseCollectionReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3221, 9), )

    
    ReleaseCollectionReference = property(__ReleaseCollectionReference.value, __ReleaseCollectionReference.set, None, 'A ddex:Composite containing a ddex:ReleaseCollectionReference for a ddex:Collection (specific to this ddex:Message). The referenced ddex:Collection has to be of ddex:CollectionType ddex:Series, ddex:Season or ddex:Episode.')

    _ElementMap.update({
        __NumberOfCollections.name() : __NumberOfCollections,
        __ReleaseCollectionReference.name() : __ReleaseCollectionReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseCollectionReferenceList', ReleaseCollectionReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseDetailsByTerritory with content type ELEMENT_ONLY
class ReleaseDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors and other attributes of a ddex:Release which may vary according to ddex:Territory of release. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3229, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3235, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddexC:ReleaseSummaryDetailsByTerritory apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3240, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddexC:ReleaseSummaryDetailsByTerritory do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element DisplayArtistName uses Python identifier DisplayArtistName
    __DisplayArtistName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtistName'), 'DisplayArtistName', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_DisplayArtistName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3246, 9), )

    
    DisplayArtistName = property(__DisplayArtistName.value, __DisplayArtistName.set, None, 'A ddex:Composite containing the ddex:Name to be used by a ddex:DSP when presenting ddex:Artist details of the ddex:Release to a ddex:Consumer.')

    
    # Element LabelName uses Python identifier LabelName
    __LabelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LabelName'), 'LabelName', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_LabelName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3251, 9), )

    
    LabelName = property(__LabelName.value, __LabelName.set, None, 'A ddex:Composite containing the ddex:Name of the ddex:Label for the ddex:Release.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3256, 9), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:Release.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3261, 9), )

    
    Title = property(__Title.value, __Title.set, None, 'A ddex:Composite containing details of a ddex:Title of the ddex:Release.')

    
    # Element DisplayArtist uses Python identifier DisplayArtist
    __DisplayArtist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), 'DisplayArtist', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_DisplayArtist', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3266, 9), )

    
    DisplayArtist = property(__DisplayArtist.value, __DisplayArtist.set, None, 'A ddex:Composite containing details of the ddex:DisplayArtist for the ddex:Release. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.')

    
    # Element IsMultiArtistCompilation uses Python identifier IsMultiArtistCompilation
    __IsMultiArtistCompilation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsMultiArtistCompilation'), 'IsMultiArtistCompilation', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_IsMultiArtistCompilation', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3271, 9), )

    
    IsMultiArtistCompilation = property(__IsMultiArtistCompilation.value, __IsMultiArtistCompilation.set, None, 'The ddex:Flag indicating whether the ddex:Release is a multiartist compilation (=True) or not (=False).')

    
    # Element AdministratingRecordCompany uses Python identifier AdministratingRecordCompany
    __AdministratingRecordCompany = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany'), 'AdministratingRecordCompany', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_AdministratingRecordCompany', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3276, 9), )

    
    AdministratingRecordCompany = property(__AdministratingRecordCompany.value, __AdministratingRecordCompany.set, None, 'A ddex:Composite containing details of the ddex:AdministratingRecordCompany for the ddex:Release. ')

    
    # Element ReleaseType uses Python identifier ReleaseType
    __ReleaseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseType'), 'ReleaseType', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_ReleaseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3282, 9), )

    
    ReleaseType = property(__ReleaseType.value, __ReleaseType.set, None, 'A ddex:Composite containing details of the form in which a ddex:ReleaseCreator anticipates offering the ddex:Release to ddex:Consumers. This overrides the ddex:ReleaseType specified globally for the ddex:Release.')

    
    # Element RelatedRelease uses Python identifier RelatedRelease
    __RelatedRelease = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RelatedRelease'), 'RelatedRelease', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_RelatedRelease', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3287, 9), )

    
    RelatedRelease = property(__RelatedRelease.value, __RelatedRelease.set, None, 'A ddex:Composite containing details of a ddex:Release (or a ddex:PhysicalProduct or a ddex:DigitalProduct derived from such a ddex:Release) which is related to this ddex:Release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_ReleaseDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3294, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3294, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:ReleaseSummaryDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __DisplayArtistName.name() : __DisplayArtistName,
        __LabelName.name() : __LabelName,
        __RightsAgreementId.name() : __RightsAgreementId,
        __Title.name() : __Title,
        __DisplayArtist.name() : __DisplayArtist,
        __IsMultiArtistCompilation.name() : __IsMultiArtistCompilation,
        __AdministratingRecordCompany.name() : __AdministratingRecordCompany,
        __ReleaseType.name() : __ReleaseType,
        __RelatedRelease.name() : __RelatedRelease
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseDetailsByTerritory', ReleaseDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseId with content type ELEMENT_ONLY
class ReleaseId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReleaseId. If available, a ddex:GRid should always to be used. If the ddex:Release contains only one ddex:SoundRecording, the ddex:ISRC of the ddex:SoundRecording may be used instead. If the ddex:Release is an abstraction of a complete ddex:PhysicalProduct (such as a CD ddex:Album), the ddex:ICPN of the ddex:PhysicalProduct may be used instead."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3300, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element GRid uses Python identifier GRid
    __GRid = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'GRid'), 'GRid', '__httpddex_netxml20120214ddexC_ReleaseId_GRid', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3305, 9), )

    
    GRid = property(__GRid.value, __GRid.set, None, "The ddex:GRid identifying the ddex:Release. This is the preferred ddex:Element and is mandatory if a ddex:GRid is available. A ddex:GRid comprises four parts: the xs:string 'A1', followed by five alphanumeric characters, ten alphanumeric characters and and one alphanumeric character.")

    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20120214ddexC_ReleaseId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3310, 9), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) used as proxy for identification of the ddex:Release. Only applicable when the ddex:Release only contains one ddex:SoundRecording or one ddex:MusicalWorkVideo. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ')

    
    # Element ICPN uses Python identifier ICPN
    __ICPN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ICPN'), 'ICPN', '__httpddex_netxml20120214ddexC_ReleaseId_ICPN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3315, 9), )

    
    ICPN = property(__ICPN.value, __ICPN.set, None, 'A ddex:Composite containing details of the ddex:ICPN used as proxy for identification of the ddex:Release. Only applicable when the ddex:Release is an abstraction of a complete ddex:PhysicalProduct. An ddex:ICPN comprises 12 or 13 digits, depending whether it is an ddex:EAN (13) or a ddex:UPC (12).')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20120214ddexC_ReleaseId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3320, 9), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Release.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_ReleaseId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3325, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Release.')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_ReleaseId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3332, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3332, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __GRid.name() : __GRid,
        __ISRC.name() : __ISRC,
        __ICPN.name() : __ICPN,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseId', ReleaseId)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseResourceReferenceList with content type ELEMENT_ONLY
class ReleaseResourceReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a list of ddex:ReleaseResourceReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseResourceReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3371, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseResourceReference uses Python identifier ReleaseResourceReference
    __ReleaseResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseResourceReference'), 'ReleaseResourceReference', '__httpddex_netxml20120214ddexC_ReleaseResourceReferenceList_ReleaseResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3376, 9), )

    
    ReleaseResourceReference = property(__ReleaseResourceReference.value, __ReleaseResourceReference.set, None, 'A ddex:Composite containing a ddex:Reference for a ddex:Resource (specific to this ddex:Message). The ddex:LocalAnchorReference in this ddex:Composite is a xs:string starting with the letter A.')

    _ElementMap.update({
        __ReleaseResourceReference.name() : __ReleaseResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseResourceReferenceList', ReleaseResourceReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseSummary with content type ELEMENT_ONLY
class ReleaseSummary (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing summary details of a ddex:Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseSummary')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3384, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20120214ddexC_ReleaseSummary_ReleaseId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3389, 9), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid shall always to be used. If the ddex:Release contains only one ddex:SoundRecording, the ddex:ISRC of the ddex:SoundRecording may be used instead. If the ddex:Release is an abstraction of a complete ddex:PhysicalProduct (such as a CD ddex:Album), the ddex:ICPN of the ddex:PhysicalProduct may be used instead. More than one of these identifiers may be provided.')

    
    # Element ReferenceTitle uses Python identifier ReferenceTitle
    __ReferenceTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), 'ReferenceTitle', '__httpddex_netxml20120214ddexC_ReleaseSummary_ReferenceTitle', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3394, 9), )

    
    ReferenceTitle = property(__ReferenceTitle.value, __ReferenceTitle.set, None, 'A ddex:Composite containing details of the ddex:ReferenceTitle of the ddex:Release.')

    
    # Element ReleaseSummaryDetailsByTerritory uses Python identifier ReleaseSummaryDetailsByTerritory
    __ReleaseSummaryDetailsByTerritory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory'), 'ReleaseSummaryDetailsByTerritory', '__httpddex_netxml20120214ddexC_ReleaseSummary_ReleaseSummaryDetailsByTerritory', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3399, 9), )

    
    ReleaseSummaryDetailsByTerritory = property(__ReleaseSummaryDetailsByTerritory.value, __ReleaseSummaryDetailsByTerritory.set, None, 'A ddex:Composite containing summary details of ddex:Descriptors and other attributes of the ddex:Release which may vary according to ddex:Territory of ddex:Release. ddex:Territory of ddex:Release may be the world.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20120214ddexC_ReleaseSummary_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3405, 9), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:Release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_ReleaseSummary_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3411, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3411, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:ReleaseSummary as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __ReleaseId.name() : __ReleaseId,
        __ReferenceTitle.name() : __ReferenceTitle,
        __ReleaseSummaryDetailsByTerritory.name() : __ReleaseSummaryDetailsByTerritory,
        __RightsAgreementId.name() : __RightsAgreementId
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseSummary', ReleaseSummary)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseSummaryDetailsByTerritory with content type ELEMENT_ONLY
class ReleaseSummaryDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing summary details of ddex:Descriptors and other attributes of a ddex:Release which may vary according to ddex:Territory of ddex:Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseSummaryDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3417, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_ReleaseSummaryDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3423, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddexC:ReleaseSummaryDetailsByTerritory apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_ReleaseSummaryDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3428, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddexC:ReleaseSummaryDetailsByTerritory do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element DisplayArtistName uses Python identifier DisplayArtistName
    __DisplayArtistName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtistName'), 'DisplayArtistName', '__httpddex_netxml20120214ddexC_ReleaseSummaryDetailsByTerritory_DisplayArtistName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3434, 9), )

    
    DisplayArtistName = property(__DisplayArtistName.value, __DisplayArtistName.set, None, 'A ddex:Composite containing the ddex:Name to be used by a ddex:DSP when presenting ddex:Artist details of the ddex:Release to a ddex:Consumer.')

    
    # Element LabelName uses Python identifier LabelName
    __LabelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LabelName'), 'LabelName', '__httpddex_netxml20120214ddexC_ReleaseSummaryDetailsByTerritory_LabelName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3439, 9), )

    
    LabelName = property(__LabelName.value, __LabelName.set, None, 'A ddex:Composite containing the ddex:Name of the ddex:Label for the ddex:Release.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20120214ddexC_ReleaseSummaryDetailsByTerritory_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3444, 9), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:Release.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_ReleaseSummaryDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3450, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3450, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:ReleaseSummaryDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __DisplayArtistName.name() : __DisplayArtistName,
        __LabelName.name() : __LabelName,
        __RightsAgreementId.name() : __RightsAgreementId
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseSummaryDetailsByTerritory', ReleaseSummaryDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}RemittanceAdvice with content type SIMPLE
class RemittanceAdvice (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:RemittanceAdvice."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RemittanceAdvice')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3475, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_RemittanceAdvice_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3481, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3481, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:RemittanceAdvice as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'RemittanceAdvice', RemittanceAdvice)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceContainedResourceReference with content type ELEMENT_ONLY
class ResourceContainedResourceReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ResourceContainedResourceReference for the case where one ddex:Resource contains another one."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceContainedResourceReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3527, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ResourceContainedResourceReference uses Python identifier ResourceContainedResourceReference
    __ResourceContainedResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference'), 'ResourceContainedResourceReference', '__httpddex_netxml20120214ddexC_ResourceContainedResourceReference_ResourceContainedResourceReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3532, 9), )

    
    ResourceContainedResourceReference = property(__ResourceContainedResourceReference.value, __ResourceContainedResourceReference.set, None, 'A ddex:Reference for a ddex:Resource (specific to this ddex:Message). This is a ddex:LocalResourceAnchorReference starting with the letter A.')

    
    # Element DurationUsed uses Python identifier DurationUsed
    __DurationUsed = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DurationUsed'), 'DurationUsed', '__httpddex_netxml20120214ddexC_ResourceContainedResourceReference_DurationUsed', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3542, 9), )

    
    DurationUsed = property(__DurationUsed.value, __DurationUsed.set, None, 'The total ddex:Duration of the ddex:Resource that has been used in a specified context (this may be less than the total ddex:Duration of the ddex:Resource) (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element StartPoint uses Python identifier StartPoint
    __StartPoint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartPoint'), 'StartPoint', '__httpddex_netxml20120214ddexC_ResourceContainedResourceReference_StartPoint', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3547, 9), )

    
    StartPoint = property(__StartPoint.value, __StartPoint.set, None, 'The start point of the preview given in seconds from the start of the referenced ddex:Resource.')

    
    # Element Purpose uses Python identifier Purpose
    __Purpose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Purpose'), 'Purpose', '__httpddex_netxml20120214ddexC_ResourceContainedResourceReference_Purpose', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3552, 9), )

    
    Purpose = property(__Purpose.value, __Purpose.set, None, 'A ddex:Composite containing details of the ddex:Purpose of the usage.')

    _ElementMap.update({
        __ResourceContainedResourceReference.name() : __ResourceContainedResourceReference,
        __DurationUsed.name() : __DurationUsed,
        __StartPoint.name() : __StartPoint,
        __Purpose.name() : __Purpose
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceContainedResourceReference', ResourceContainedResourceReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceContainedResourceReferenceList with content type ELEMENT_ONLY
class ResourceContainedResourceReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of one or more ddex:ResourceContainedResourceReferences. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceContainedResourceReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3559, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ResourceContainedResourceReference uses Python identifier ResourceContainedResourceReference
    __ResourceContainedResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference'), 'ResourceContainedResourceReference', '__httpddex_netxml20120214ddexC_ResourceContainedResourceReferenceList_ResourceContainedResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3564, 9), )

    
    ResourceContainedResourceReference = property(__ResourceContainedResourceReference.value, __ResourceContainedResourceReference.set, None, 'A ddex:Composite containing details of a ddex:ResourceContainedResourceReference.')

    _ElementMap.update({
        __ResourceContainedResourceReference.name() : __ResourceContainedResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceContainedResourceReferenceList', ResourceContainedResourceReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceContributor with content type ELEMENT_ONLY
class ResourceContributor (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of the ddex:Name, ddex:Identifier and role(s) of a ddex:Contributor to a ddex:Resource."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceContributor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3572, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_ResourceContributor_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3578, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_ResourceContributor_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3584, 15), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the PartyName(s).')

    
    # Element ResourceContributorRole uses Python identifier ResourceContributorRole
    __ResourceContributorRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributorRole'), 'ResourceContributorRole', '__httpddex_netxml20120214ddexC_ResourceContributor_ResourceContributorRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3596, 9), )

    
    ResourceContributorRole = property(__ResourceContributorRole.value, __ResourceContributorRole.set, None, 'A ddex:Composite containing details of a role played by the ddex:Contributor.')

    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_ResourceContributor_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3603, 6)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3603, 6)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ddexC:ResourceContributor in a group of ResourceContributors that have contributed to a ddex:Resource. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName,
        __ResourceContributorRole.name() : __ResourceContributorRole
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'ResourceContributor', ResourceContributor)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceGroupResourceReferenceList with content type ELEMENT_ONLY
class ResourceGroupResourceReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a list of ddex:ResourceGroupResourceReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceGroupResourceReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3628, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ResourceGroupResourceReference uses Python identifier ResourceGroupResourceReference
    __ResourceGroupResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceGroupResourceReference'), 'ResourceGroupResourceReference', '__httpddex_netxml20120214ddexC_ResourceGroupResourceReferenceList_ResourceGroupResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3633, 9), )

    
    ResourceGroupResourceReference = property(__ResourceGroupResourceReference.value, __ResourceGroupResourceReference.set, None, 'A ddex:Reference for a ddex:Resource (specific to this ddex:Message). This is a ddex:LocalResourceAnchorReference starting with the letter A.')

    _ElementMap.update({
        __ResourceGroupResourceReference.name() : __ResourceGroupResourceReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceGroupResourceReferenceList', ResourceGroupResourceReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceId with content type ELEMENT_ONLY
class ResourceId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:ResourceIds."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3645, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20120214ddexC_ResourceId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3650, 9), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:Resource. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ')

    
    # Element ISMN uses Python identifier ISMN
    __ISMN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISMN'), 'ISMN', '__httpddex_netxml20120214ddexC_ResourceId_ISMN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3655, 9), )

    
    ISMN = property(__ISMN.value, __ISMN.set, None, "The ddex:ISMN (International Standard Music Number defined in ISO 10957) for the ddex:Resource. An ddex:ISMN is a thirteen-digit number. Pre-2008 ddex:ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ('M') with '979-0'.")

    
    # Element ISAN uses Python identifier ISAN
    __ISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISAN'), 'ISAN', '__httpddex_netxml20120214ddexC_ResourceId_ISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3660, 9), )

    
    ISAN = property(__ISAN.value, __ISAN.set, None, 'The ddex:ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the ddex:Resource. An ddex:ISAN comprises four blocks of four hexadecimal charaters followed by a check character.')

    
    # Element VISAN uses Python identifier VISAN
    __VISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VISAN'), 'VISAN', '__httpddex_netxml20120214ddexC_ResourceId_VISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3665, 9), )

    
    VISAN = property(__VISAN.value, __VISAN.set, None, 'The V-ISAN (Version ddex:Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the ddex:Resource. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.')

    
    # Element ISBN uses Python identifier ISBN
    __ISBN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISBN'), 'ISBN', '__httpddex_netxml20120214ddexC_ResourceId_ISBN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3670, 9), )

    
    ISBN = property(__ISBN.value, __ISBN.set, None, "The ddex:ISBN (International Standard Book Number defined in ISO 2108) for the ddex:Resource. An ddex:ISBN is a 13-digit number. Pre-2007, ddex:ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix '978' and re-calculating the check character.")

    
    # Element ISSN uses Python identifier ISSN
    __ISSN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISSN'), 'ISSN', '__httpddex_netxml20120214ddexC_ResourceId_ISSN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3675, 9), )

    
    ISSN = property(__ISSN.value, __ISSN.set, None, 'The ddex:ISSN (International Standard Serial Number defined in ISO 3297) for the ddex:Resource. An ddex:ISSN comprises two groups of four digits, separated by a hyphen and a control digit.')

    
    # Element SICI uses Python identifier SICI
    __SICI = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SICI'), 'SICI', '__httpddex_netxml20120214ddexC_ResourceId_SICI', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3680, 9), )

    
    SICI = property(__SICI.value, __SICI.set, None, 'The ddex:SICI (Serial Item and Contribution ddex:Identifier defined in ANSI/NISO Z39.56-199)  for the ddex:Resource.')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20120214ddexC_ResourceId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3685, 9), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Resource.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_ResourceId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3690, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Resource.')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_ResourceId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3697, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3697, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ISRC.name() : __ISRC,
        __ISMN.name() : __ISMN,
        __ISAN.name() : __ISAN,
        __VISAN.name() : __VISAN,
        __ISBN.name() : __ISBN,
        __ISSN.name() : __ISSN,
        __SICI.name() : __SICI,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'ResourceId', ResourceId)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceMusicalWorkReference with content type ELEMENT_ONLY
class ResourceMusicalWorkReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a ddex:ResourceMusicalWorkReference."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceMusicalWorkReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3703, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_ResourceMusicalWorkReference_SequenceNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3708, 9), )

    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ddex:MusicalWork in a group of ddex:MusicalWorks within a ddex:Medley, ddex:SoundRecording or other ddex:Resource.')

    
    # Element DurationUsed uses Python identifier DurationUsed
    __DurationUsed = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DurationUsed'), 'DurationUsed', '__httpddex_netxml20120214ddexC_ResourceMusicalWorkReference_DurationUsed', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3713, 9), )

    
    DurationUsed = property(__DurationUsed.value, __DurationUsed.set, None, 'The total ddex:Duration of the ddex:MusicalWork that has been used in a specified context (this may be less than the total ddex:Duration of the ddex:MusicalWork) (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element IsFragment uses Python identifier IsFragment
    __IsFragment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IsFragment'), 'IsFragment', '__httpddex_netxml20120214ddexC_ResourceMusicalWorkReference_IsFragment', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3718, 9), )

    
    IsFragment = property(__IsFragment.value, __IsFragment.set, None, 'The ddex:Flag indicating whether the ddex:MusicalWork is a ddex:Fragment (=True) or not (=False).')

    
    # Element ResourceMusicalWorkReference uses Python identifier ResourceMusicalWorkReference
    __ResourceMusicalWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference'), 'ResourceMusicalWorkReference', '__httpddex_netxml20120214ddexC_ResourceMusicalWorkReference_ResourceMusicalWorkReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3723, 9), )

    
    ResourceMusicalWorkReference = property(__ResourceMusicalWorkReference.value, __ResourceMusicalWorkReference.set, None, 'A ddex:Reference for a ddex:MusicalWork (specific to this ddex:Message). This is a ddex:LocalMusicalWorkAnchorReference starting with the letter W.')

    _ElementMap.update({
        __SequenceNumber.name() : __SequenceNumber,
        __DurationUsed.name() : __DurationUsed,
        __IsFragment.name() : __IsFragment,
        __ResourceMusicalWorkReference.name() : __ResourceMusicalWorkReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceMusicalWorkReference', ResourceMusicalWorkReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceMusicalWorkReferenceList with content type ELEMENT_ONLY
class ResourceMusicalWorkReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a list of ddex:ResourceMusicalWorkReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceMusicalWorkReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3735, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ResourceMusicalWorkReference uses Python identifier ResourceMusicalWorkReference
    __ResourceMusicalWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference'), 'ResourceMusicalWorkReference', '__httpddex_netxml20120214ddexC_ResourceMusicalWorkReferenceList_ResourceMusicalWorkReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3740, 9), )

    
    ResourceMusicalWorkReference = property(__ResourceMusicalWorkReference.value, __ResourceMusicalWorkReference.set, None, 'A ddex:Composite containing a ddex:ResourceMusicalWorkReference for a ddex:MusicalWork (specific to this ddex:Message).')

    _ElementMap.update({
        __ResourceMusicalWorkReference.name() : __ResourceMusicalWorkReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'ResourceMusicalWorkReferenceList', ResourceMusicalWorkReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}RightShare with content type ELEMENT_ONLY
class RightShare (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:RightShare."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightShare')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3786, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element RightShareId uses Python identifier RightShareId
    __RightShareId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareId'), 'RightShareId', '__httpddex_netxml20120214ddexC_RightShare_RightShareId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3791, 9), )

    
    RightShareId = property(__RightShareId.value, __RightShareId.set, None, 'A ddex:Composite containing details of ddex:Identifiers for the ddexC:RightShare.')

    
    # Element RightShareReference uses Python identifier RightShareReference
    __RightShareReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareReference'), 'RightShareReference', '__httpddex_netxml20120214ddexC_RightShare_RightShareReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3796, 9), )

    
    RightShareReference = property(__RightShareReference.value, __RightShareReference.set, None, 'The ddex:Identifier (specific to the ddex:Message) of the ddexC:RightShare within the ddex:Release which contains it. This is a ddex:LocalRightShareAnchor starting with the letter S.')

    
    # Element RightShareCreationReferenceList uses Python identifier RightShareCreationReferenceList
    __RightShareCreationReferenceList = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareCreationReferenceList'), 'RightShareCreationReferenceList', '__httpddex_netxml20120214ddexC_RightShare_RightShareCreationReferenceList', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3806, 9), )

    
    RightShareCreationReferenceList = property(__RightShareCreationReferenceList.value, __RightShareCreationReferenceList.set, None, 'A ddex:Composite containing details of one or more ddex:Creations contained in the ddexC:RightShare.')

    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_RightShare_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3813, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddexC:RightShare applies (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_RightShare_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3818, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddexC:RightShare does not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element RightsType uses Python identifier RightsType
    __RightsType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsType'), 'RightsType', '__httpddex_netxml20120214ddexC_RightShare_RightsType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3824, 9), )

    
    RightsType = property(__RightsType.value, __RightsType.set, None, 'A ddex:Type of ddex:Right covered by the ddexC:RightShare. One of the ddex:Elements RightsType and ddex:UseType must be present. The RightsType is defined according to the jurisdiction of the ddex:Territory indicated in the iso3166a2:TerritoryCode ddex:XmlAttribute.')

    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20120214ddexC_RightShare_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3829, 9), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer. One of the ddex:Elements RightsType and ddex:UseType must be present.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20120214ddexC_RightShare_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3834, 9), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20120214ddexC_RightShare_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3840, 9), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20120214ddexC_RightShare_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3846, 9), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A ddex:Composite containing details of a ddex:Carrier.')

    
    # Element CommercialModelType uses Python identifier CommercialModelType
    __CommercialModelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CommercialModelType'), 'CommercialModelType', '__httpddex_netxml20120214ddexC_RightShare_CommercialModelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3851, 9), )

    
    CommercialModelType = property(__CommercialModelType.value, __CommercialModelType.set, None, 'A ddex:Composite containing details of the fundamental business model which applies (e.g. ddex:SubscriptionModel and ddex:PayAsYouGoModel). The ddex:CommercialModelType indicates how the ddex:Consumer pays for the ddex:Service or ddex:Release.')

    
    # Element MusicalWorkRightsClaimType uses Python identifier MusicalWorkRightsClaimType
    __MusicalWorkRightsClaimType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWorkRightsClaimType'), 'MusicalWorkRightsClaimType', '__httpddex_netxml20120214ddexC_RightShare_MusicalWorkRightsClaimType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3857, 9), )

    
    MusicalWorkRightsClaimType = property(__MusicalWorkRightsClaimType.value, __MusicalWorkRightsClaimType.set, None, 'A ddex:Type of the ddex:RightsClaim related to a ddex:MusicalWork.')

    
    # Element RightsController uses Python identifier RightsController
    __RightsController = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsController'), 'RightsController', '__httpddex_netxml20120214ddexC_RightShare_RightsController', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3863, 9), )

    
    RightsController = property(__RightsController.value, __RightsController.set, None, 'A ddex:Composite containing details of a ddex:RightsController of Rights in a ddex:Creation.')

    
    # Element ValidityPeriod uses Python identifier ValidityPeriod
    __ValidityPeriod = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ValidityPeriod'), 'ValidityPeriod', '__httpddex_netxml20120214ddexC_RightShare_ValidityPeriod', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3869, 9), )

    
    ValidityPeriod = property(__ValidityPeriod.value, __ValidityPeriod.set, None, 'A ddex:Composite containing details about the ddex:Period of ddex:Time for which the ddexC:RightShare is valid.')

    
    # Element PercentageUnknown uses Python identifier PercentageUnknown
    __PercentageUnknown = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PercentageUnknown'), 'PercentageUnknown', '__httpddex_netxml20120214ddexC_RightShare_PercentageUnknown', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3875, 12), )

    
    PercentageUnknown = property(__PercentageUnknown.value, __PercentageUnknown.set, None, 'The ddex:Flag indicating whether the ddex:RightSharePercentage is unknown (=True) or not (=False).')

    
    # Element PercentageRate uses Python identifier PercentageRate
    __PercentageRate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PercentageRate'), 'PercentageRate', '__httpddex_netxml20120214ddexC_RightShare_PercentageRate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3880, 12), )

    
    PercentageRate = property(__PercentageRate.value, __PercentageRate.set, None, "The share of the licensed Rights owned by the ddex:RightsController. ddexC:RightShare information is given as a xs:decimal value (e.g. '0.125' represents 12.5%) or as a fraction (e.g. '1/8' represents 12.5%).")

    
    # Element TariffReference uses Python identifier TariffReference
    __TariffReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TariffReference'), 'TariffReference', '__httpddex_netxml20120214ddexC_RightShare_TariffReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3886, 9), )

    
    TariffReference = property(__TariffReference.value, __TariffReference.set, None, 'A ddex:Composite containing details of a ddex:Reference to a ddex:TextDocument containing details of a ddex:Tariff (in the form of an ddex:Identifier, ddex:Name or ddex:Description) that is to be applied to the ddexC:RightShare.')

    
    # Element LicenseStatus uses Python identifier LicenseStatus
    __LicenseStatus = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LicenseStatus'), 'LicenseStatus', '__httpddex_netxml20120214ddexC_RightShare_LicenseStatus', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3891, 9), )

    
    LicenseStatus = property(__LicenseStatus.value, __LicenseStatus.set, None, 'The legal status of a ddex:License for the ddexC:RightShare.')

    
    # Element HasFirstLicenseRefusal uses Python identifier HasFirstLicenseRefusal
    __HasFirstLicenseRefusal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HasFirstLicenseRefusal'), 'HasFirstLicenseRefusal', '__httpddex_netxml20120214ddexC_RightShare_HasFirstLicenseRefusal', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3896, 9), )

    
    HasFirstLicenseRefusal = property(__HasFirstLicenseRefusal.value, __HasFirstLicenseRefusal.set, None, 'The ddex:Flag indicating whether a ddex:RightsController retains the right of refusal regarding the granting of the first licence for creating a ddex:SoundRecording of a Musical ddex:Work (=True) or not (=False).')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_RightShare_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3902, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3902, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:RightShare as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __RightShareId.name() : __RightShareId,
        __RightShareReference.name() : __RightShareReference,
        __RightShareCreationReferenceList.name() : __RightShareCreationReferenceList,
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __RightsType.name() : __RightsType,
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType,
        __CommercialModelType.name() : __CommercialModelType,
        __MusicalWorkRightsClaimType.name() : __MusicalWorkRightsClaimType,
        __RightsController.name() : __RightsController,
        __ValidityPeriod.name() : __ValidityPeriod,
        __PercentageUnknown.name() : __PercentageUnknown,
        __PercentageRate.name() : __PercentageRate,
        __TariffReference.name() : __TariffReference,
        __LicenseStatus.name() : __LicenseStatus,
        __HasFirstLicenseRefusal.name() : __HasFirstLicenseRefusal
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'RightShare', RightShare)


# Complex type {http://ddex.net/xml/20120214/ddexC}RightShareCreationReferenceList with content type ELEMENT_ONLY
class RightShareCreationReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a list of RightShareCreationReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightShareCreationReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3908, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element RightShareWorkReference uses Python identifier RightShareWorkReference
    __RightShareWorkReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareWorkReference'), 'RightShareWorkReference', '__httpddex_netxml20120214ddexC_RightShareCreationReferenceList_RightShareWorkReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3913, 9), )

    
    RightShareWorkReference = property(__RightShareWorkReference.value, __RightShareWorkReference.set, None, 'A ddex:Reference for a ddex:Work (specific to this ddex:Message) that is part of the ddex:RightShare. This is a ddex:LocalMusicalWorkAnchorReference starting with the letter W.')

    
    # Element RightShareResourceReference uses Python identifier RightShareResourceReference
    __RightShareResourceReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareResourceReference'), 'RightShareResourceReference', '__httpddex_netxml20120214ddexC_RightShareCreationReferenceList_RightShareResourceReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3923, 9), )

    
    RightShareResourceReference = property(__RightShareResourceReference.value, __RightShareResourceReference.set, None, 'A ddex:Reference for a ddex:Resource (specific to this ddex:Message) that is part of the ddex:RightShare. This is a ddex:LocalResourceAnchorReference starting with the letter A. The ddex:RightShare covers the ddex:Works used in the Resource(s).')

    
    # Element RightShareReleaseReference uses Python identifier RightShareReleaseReference
    __RightShareReleaseReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareReleaseReference'), 'RightShareReleaseReference', '__httpddex_netxml20120214ddexC_RightShareCreationReferenceList_RightShareReleaseReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3933, 9), )

    
    RightShareReleaseReference = property(__RightShareReleaseReference.value, __RightShareReleaseReference.set, None, 'A ddex:Reference for a ddex:Release (specific to this ddex:Message) that is part of the ddex:RightShare. This is a ddex:LocalReleaseAnchorReference starting with the letter R. The ddex:RightShare covers the ddex:Works used in the Release(s).')

    _ElementMap.update({
        __RightShareWorkReference.name() : __RightShareWorkReference,
        __RightShareResourceReference.name() : __RightShareResourceReference,
        __RightShareReleaseReference.name() : __RightShareReleaseReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'RightShareCreationReferenceList', RightShareCreationReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}RightsAgreementId with content type ELEMENT_ONLY
class RightsAgreementId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightsAgreementId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3945, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MWLI uses Python identifier MWLI
    __MWLI = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MWLI'), 'MWLI', '__httpddex_netxml20120214ddexC_RightsAgreementId_MWLI', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3950, 9), )

    
    MWLI = property(__MWLI.value, __MWLI.set, None, "A ddex:MusicalWork ddex:License ddex:Identifier identifying a ddex:License. If the ddex:Composite is meant to describe a ddex:Claim, ddex:RightShare or contract, then the ddex:License relates to that ddex:Claim, ddex:RightShare or contract. A ddex:MWLI comprises four parts: one of the xs:strings 'M1' or 'M2' or 'M3' or 'M4', followed by five alphanumeric characters, ten alphanumeric characters and one alphanumeric check character.")

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_RightsAgreementId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3955, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:License, ddex:Claim, ddex:RightShare or contract.')

    _ElementMap.update({
        __MWLI.name() : __MWLI,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'RightsAgreementId', RightsAgreementId)


# Complex type {http://ddex.net/xml/20120214/ddexC}RightsController with content type ELEMENT_ONLY
class RightsController (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:RightsController. ddex:RightsControllers are typicallydescribed by ddex:Name, ddex:Identifier and role(s)."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightsController')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3963, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_RightsController_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3969, 12), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_RightsController_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3975, 15), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the PartyName(s).')

    
    # Element RightsControllerRole uses Python identifier RightsControllerRole
    __RightsControllerRole = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsControllerRole'), 'RightsControllerRole', '__httpddex_netxml20120214ddexC_RightsController_RightsControllerRole', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3987, 9), )

    
    RightsControllerRole = property(__RightsControllerRole.value, __RightsControllerRole.set, None, 'A role that describes the ddex:Party involved in the administration of ddex:Rights.')

    
    # Element RightShareUnknown uses Python identifier RightShareUnknown
    __RightShareUnknown = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightShareUnknown'), 'RightShareUnknown', '__httpddex_netxml20120214ddexC_RightsController_RightShareUnknown', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3994, 12), )

    
    RightShareUnknown = property(__RightShareUnknown.value, __RightShareUnknown.set, None, 'The ddex:Flag indicating whether the ddex:RightSharePercentage is unknown (=True) or not (=False).')

    
    # Element RightSharePercentage uses Python identifier RightSharePercentage
    __RightSharePercentage = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightSharePercentage'), 'RightSharePercentage', '__httpddex_netxml20120214ddexC_RightsController_RightSharePercentage', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3999, 12), )

    
    RightSharePercentage = property(__RightSharePercentage.value, __RightSharePercentage.set, None, "The share of the licensed Rights owned by the ddexC:RightsController. ddex:RightShare information is given as a xs:decimal value (e.g. '0.125' represents 12.5%). If no information is given, 100% is assumed.")

    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_RightsController_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4006, 6)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4006, 6)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ddexC:RightsController in a group of ddex:RightsControllers. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName,
        __RightsControllerRole.name() : __RightsControllerRole,
        __RightShareUnknown.name() : __RightShareUnknown,
        __RightSharePercentage.name() : __RightSharePercentage
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'RightsController', RightsController)


# Complex type {http://ddex.net/xml/20120214/ddexC}RoyaltyCode with content type SIMPLE
class RoyaltyCode (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:RoyaltyCode."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RoyaltyCode')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4050, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_RoyaltyCode_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4056, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4056, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:RoyaltyRateType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'RoyaltyCode', RoyaltyCode)


# Complex type {http://ddex.net/xml/20120214/ddexC}SalesReportingProxyReleaseId with content type ELEMENT_ONLY
class SalesReportingProxyReleaseId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SalesReportingProxyReleaseId."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SalesReportingProxyReleaseId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4064, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20120214ddexC_SalesReportingProxyReleaseId_ReleaseId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4069, 9), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid should always be used.')

    
    # Element Reason uses Python identifier Reason
    __Reason = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Reason'), 'Reason', '__httpddex_netxml20120214ddexC_SalesReportingProxyReleaseId_Reason', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4074, 9), )

    
    Reason = property(__Reason.value, __Reason.set, None, 'A ddex:Composite containing the textual ddex:Description of the reason for the ddex:Identifier being used as a proxy.')

    
    # Element ReasonType uses Python identifier ReasonType
    __ReasonType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReasonType'), 'ReasonType', '__httpddex_netxml20120214ddexC_SalesReportingProxyReleaseId_ReasonType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4079, 9), )

    
    ReasonType = property(__ReasonType.value, __ReasonType.set, None, 'A ddex:Composite containing details of a ReasonType.')

    _ElementMap.update({
        __ReleaseId.name() : __ReleaseId,
        __Reason.name() : __Reason,
        __ReasonType.name() : __ReasonType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SalesReportingProxyReleaseId', SalesReportingProxyReleaseId)


# Complex type {http://ddex.net/xml/20120214/ddexC}SheetMusicDetailsByTerritory with content type ELEMENT_ONLY
class SheetMusicDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors, Dates and other attributes of a ddex:SheetMusic which may vary according to ddex:Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SheetMusicDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4124, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_SheetMusicDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4130, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:SheetMusic details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_SheetMusicDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4135, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:SheetMusic details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20120214ddexC_SheetMusicDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4141, 9), )

    
    Title = property(__Title.value, __Title.set, None, 'A ddex:Composite containing details of a ddex:Title of the ddex:SheetMusic.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20120214ddexC_SheetMusicDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4146, 9), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A ddex:Composite containing details of a ddex:Contributor to the ddex:SheetMusic.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20120214ddexC_SheetMusicDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4152, 9), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:SheetMusic.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20120214ddexC_SheetMusicDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4158, 9), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A ddex:Composite containing details of the ddex:CLine for the ddex:SheetMusic.')

    
    # Element CourtesyLine uses Python identifier CourtesyLine
    __CourtesyLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), 'CourtesyLine', '__httpddex_netxml20120214ddexC_SheetMusicDetailsByTerritory_CourtesyLine', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4163, 9), )

    
    CourtesyLine = property(__CourtesyLine.value, __CourtesyLine.set, None, 'A ddex:Composite containing an ddex:Annotation which acknowledges record companies and/or other Parties giving permission for ddex:Artists or others featured in the ddex:SheetMusic.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20120214ddexC_SheetMusicDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4168, 9), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SheetMusic was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_SheetMusicDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4174, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4174, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:SheetMusicDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __Title.name() : __Title,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __CLine.name() : __CLine,
        __CourtesyLine.name() : __CourtesyLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SheetMusicDetailsByTerritory', SheetMusicDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}SheetMusicId with content type ELEMENT_ONLY
class SheetMusicId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Identifiers of a ddex:SheetMusic."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SheetMusicId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4180, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISMN uses Python identifier ISMN
    __ISMN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISMN'), 'ISMN', '__httpddex_netxml20120214ddexC_SheetMusicId_ISMN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4185, 9), )

    
    ISMN = property(__ISMN.value, __ISMN.set, None, "The ddex:ISMN (International Standard Music Number defined in ISO 10957) for the ddex:SheetMusic. An ddex:ISMN is a thirteen-digit number. Pre-2008 ddex:ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ('M') with '979-0'.")

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_SheetMusicId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4190, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:SheetMusic.')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_SheetMusicId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4197, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4197, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ISMN.name() : __ISMN,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'SheetMusicId', SheetMusicId)


# Complex type {http://ddex.net/xml/20120214/ddexC}SocietyAffiliation with content type ELEMENT_ONLY
class SocietyAffiliation (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a society affiliation."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SocietyAffiliation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4222, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_SocietyAffiliation_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4228, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the affiliation details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_SocietyAffiliation_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4233, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the affiliation details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element MusicRightsSociety uses Python identifier MusicRightsSociety
    __MusicRightsSociety = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicRightsSociety'), 'MusicRightsSociety', '__httpddex_netxml20120214ddexC_SocietyAffiliation_MusicRightsSociety', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4239, 9), )

    
    MusicRightsSociety = property(__MusicRightsSociety.value, __MusicRightsSociety.set, None, 'A ddex:Composite containing details of a ddex:MusicRightsSociety.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __MusicRightsSociety.name() : __MusicRightsSociety
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SocietyAffiliation', SocietyAffiliation)


# Complex type {http://ddex.net/xml/20120214/ddexC}SoftwareDetailsByTerritory with content type ELEMENT_ONLY
class SoftwareDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors, Dates and other attributes of a ddex:Software application which may vary according to ddex:Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoftwareDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4246, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_SoftwareDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4252, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:Software details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_SoftwareDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4257, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:Software details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20120214ddexC_SoftwareDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4263, 9), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A ddex:Composite containing details of a ddex:Contributor to the ddex:Software.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20120214ddexC_SoftwareDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4269, 9), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:Software.')

    
    # Element PLine uses Python identifier PLine
    __PLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLine'), 'PLine', '__httpddex_netxml20120214ddexC_SoftwareDetailsByTerritory_PLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4275, 9), )

    
    PLine = property(__PLine.value, __PLine.set, None, 'A ddex:Composite containing details of the ddex:PLine for the ddex:Software.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20120214ddexC_SoftwareDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4280, 9), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A ddex:Composite containing details of the ddex:CLine for the ddex:Software.')

    
    # Element CourtesyLine uses Python identifier CourtesyLine
    __CourtesyLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), 'CourtesyLine', '__httpddex_netxml20120214ddexC_SoftwareDetailsByTerritory_CourtesyLine', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4285, 9), )

    
    CourtesyLine = property(__CourtesyLine.value, __CourtesyLine.set, None, 'A ddex:Composite containing an ddex:Annotation which acknowledges record companies and/or other Parties giving permission for ddex:Artists or others featured in the ddex:Software.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20120214ddexC_SoftwareDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4290, 9), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Software was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_SoftwareDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4296, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4296, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:SoftwareDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __PLine.name() : __PLine,
        __CLine.name() : __CLine,
        __CourtesyLine.name() : __CourtesyLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SoftwareDetailsByTerritory', SoftwareDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}SoftwareId with content type ELEMENT_ONLY
class SoftwareId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Identifiers of a ddex:Software."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoftwareId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4302, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_SoftwareId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4307, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Software.')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_SoftwareId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4313, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4313, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'SoftwareId', SoftwareId)


# Complex type {http://ddex.net/xml/20120214/ddexC}SoundRecordingCollectionReference with content type ELEMENT_ONLY
class SoundRecordingCollectionReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SoundRecordingCollectionReference."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingCollectionReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4362, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_SoundRecordingCollectionReference_SequenceNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4367, 9), )

    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ddex:Collection in a group of ddex:Collections within a ddex:Medley, ddex:SoundRecording or other ddex:Collection.')

    
    # Element SoundRecordingCollectionReference uses Python identifier SoundRecordingCollectionReference
    __SoundRecordingCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference'), 'SoundRecordingCollectionReference', '__httpddex_netxml20120214ddexC_SoundRecordingCollectionReference_SoundRecordingCollectionReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4372, 9), )

    
    SoundRecordingCollectionReference = property(__SoundRecordingCollectionReference.value, __SoundRecordingCollectionReference.set, None, 'A ddex:Reference for a ddex:Collection (specific to this ddex:Message). This is a ddex:LocalCollectionAnchorReference starting with the letter X. The referenced ddex:Collection has to be of ddex:CollectionType ddex:Series, ddex:Season or ddex:Episode.')

    
    # Element StartTime uses Python identifier StartTime
    __StartTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'StartTime'), 'StartTime', '__httpddex_netxml20120214ddexC_SoundRecordingCollectionReference_StartTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4382, 9), )

    
    StartTime = property(__StartTime.value, __StartTime.set, None, 'The start time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element Duration uses Python identifier Duration
    __Duration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Duration'), 'Duration', '__httpddex_netxml20120214ddexC_SoundRecordingCollectionReference_Duration', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4387, 9), )

    
    Duration = property(__Duration.value, __Duration.set, None, 'The ddex:Duration of the use of the ddex:Creation that is referenced in the ddex:CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element EndTime uses Python identifier EndTime
    __EndTime = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EndTime'), 'EndTime', '__httpddex_netxml20120214ddexC_SoundRecordingCollectionReference_EndTime', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4392, 9), )

    
    EndTime = property(__EndTime.value, __EndTime.set, None, 'The end time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).')

    
    # Element ReleaseResourceType uses Python identifier ReleaseResourceType
    __ReleaseResourceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType'), 'ReleaseResourceType', '__httpddex_netxml20120214ddexC_SoundRecordingCollectionReference_ReleaseResourceType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4397, 9), )

    
    ReleaseResourceType = property(__ReleaseResourceType.value, __ReleaseResourceType.set, None, 'A ddex:Type of ddex:Collection in the context of a ddex:Video. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __SequenceNumber.name() : __SequenceNumber,
        __SoundRecordingCollectionReference.name() : __SoundRecordingCollectionReference,
        __StartTime.name() : __StartTime,
        __Duration.name() : __Duration,
        __EndTime.name() : __EndTime,
        __ReleaseResourceType.name() : __ReleaseResourceType
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingCollectionReference', SoundRecordingCollectionReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}SoundRecordingCollectionReferenceList with content type ELEMENT_ONLY
class SoundRecordingCollectionReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a list of ddex:SoundRecordingCollectionReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingCollectionReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4404, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element NumberOfCollections uses Python identifier NumberOfCollections
    __NumberOfCollections = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), 'NumberOfCollections', '__httpddex_netxml20120214ddexC_SoundRecordingCollectionReferenceList_NumberOfCollections', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4409, 9), )

    
    NumberOfCollections = property(__NumberOfCollections.value, __NumberOfCollections.set, None, 'The number of referenced ddexC:Collections (typically Chapters).')

    
    # Element SoundRecordingCollectionReference uses Python identifier SoundRecordingCollectionReference
    __SoundRecordingCollectionReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference'), 'SoundRecordingCollectionReference', '__httpddex_netxml20120214ddexC_SoundRecordingCollectionReferenceList_SoundRecordingCollectionReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4414, 9), )

    
    SoundRecordingCollectionReference = property(__SoundRecordingCollectionReference.value, __SoundRecordingCollectionReference.set, None, 'A ddex:Composite containing a ddex:SoundRecordingCollectionReference for a ddex:Collection (specific to this ddex:Message).')

    _ElementMap.update({
        __NumberOfCollections.name() : __NumberOfCollections,
        __SoundRecordingCollectionReference.name() : __SoundRecordingCollectionReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingCollectionReferenceList', SoundRecordingCollectionReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}SoundRecordingDetailsByTerritory with content type ELEMENT_ONLY
class SoundRecordingDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors and other attributes of a ddex:SoundRecording which may vary according to ddex:Territory of release. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4422, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4428, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:SoundRecording details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4433, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:SoundRecording details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4439, 9), )

    
    Title = property(__Title.value, __Title.set, None, 'A ddex:Composite containing details of a ddex:Title of the ddex:SoundRecording.')

    
    # Element DisplayArtist uses Python identifier DisplayArtist
    __DisplayArtist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), 'DisplayArtist', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_DisplayArtist', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4444, 9), )

    
    DisplayArtist = property(__DisplayArtist.value, __DisplayArtist.set, None, 'A ddex:Composite containing details of the ddex:DisplayArtist for the ddex:SoundRecording. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4449, 9), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A ddex:Composite containing details of a ddex:Contributor to the ddex:SoundRecording.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4455, 9), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:SoundRecording.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4461, 9), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:SoundRecording.')

    
    # Element LabelName uses Python identifier LabelName
    __LabelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LabelName'), 'LabelName', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_LabelName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4466, 9), )

    
    LabelName = property(__LabelName.value, __LabelName.set, None, 'A ddex:Composite containing the ddex:Name of the ddex:Label under which the ddex:Release is to be marketed.')

    
    # Element RightsController uses Python identifier RightsController
    __RightsController = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsController'), 'RightsController', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_RightsController', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4471, 9), )

    
    RightsController = property(__RightsController.value, __RightsController.set, None, 'A ddex:Composite containing details of ddex:RightsController of Rights in the ddex:SoundRecording.')

    
    # Element RemasteredDate uses Python identifier RemasteredDate
    __RemasteredDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), 'RemasteredDate', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_RemasteredDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4477, 9), )

    
    RemasteredDate = property(__RemasteredDate.value, __RemasteredDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SoundRecording was re-mastered (usually digitally).')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4482, 9), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SoundRecording was originally published, whether for physical or electronic/online distribution.')

    
    # Element PLine uses Python identifier PLine
    __PLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLine'), 'PLine', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_PLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4487, 9), )

    
    PLine = property(__PLine.value, __PLine.set, None, 'A ddex:Composite containing details of the ddex:PLine for the ddex:SoundRecording.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_SoundRecordingDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4493, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4493, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:SoundRecordingDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __Title.name() : __Title,
        __DisplayArtist.name() : __DisplayArtist,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __RightsAgreementId.name() : __RightsAgreementId,
        __LabelName.name() : __LabelName,
        __RightsController.name() : __RightsController,
        __RemasteredDate.name() : __RemasteredDate,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate,
        __PLine.name() : __PLine
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingDetailsByTerritory', SoundRecordingDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}SoundRecordingId with content type ELEMENT_ONLY
class SoundRecordingId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:SoundRecordingIds."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4499, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20120214ddexC_SoundRecordingId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4504, 9), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:SoundRecording. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20120214ddexC_SoundRecordingId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4509, 9), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:SoundRecording.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_SoundRecordingId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4514, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:SoundRecording (usually one per society involved in the messaging).')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_SoundRecordingId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4521, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4521, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ISRC.name() : __ISRC,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingId', SoundRecordingId)


# Complex type {http://ddex.net/xml/20120214/ddexC}StoreLocationDescriptor with content type SIMPLE
class StoreLocationDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:StoreLocationDescriptor."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'StoreLocationDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4546, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_StoreLocationDescriptor_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4552, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4552, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:StoreLocationDescriptor as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'StoreLocationDescriptor', StoreLocationDescriptor)


# Complex type {http://ddex.net/xml/20120214/ddexC}SubTitle with content type SIMPLE
class SubTitle (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SubTitle, including ddex:Titles of ddex:Versions used to differentiate different versions of the same ddex:Title, as required by the ddex:GRid and ddex:ISRC ddex:ReferenceDescriptiveMetadataSets."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SubTitle')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4560, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_SubTitle_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4566, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4566, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:SubTitle as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'SubTitle', SubTitle)


# Complex type {http://ddex.net/xml/20120214/ddexC}Synopsis with content type SIMPLE
class Synopsis (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Synopsis."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Synopsis')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4593, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Synopsis_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4599, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4599, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:Synopsis as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'Synopsis', Synopsis)


# Complex type {http://ddex.net/xml/20120214/ddexC}TariffReference with content type SIMPLE
class TariffReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Reference to a ddex:TextDocument containing details of a ddex:Tariff."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TariffReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4607, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_TariffReference_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4613, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4613, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:TariffReference (and the ddex:TariffSubReference if applicable) as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute TariffSubReference uses Python identifier TariffSubReference
    __TariffSubReference = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'TariffSubReference'), 'TariffSubReference', '__httpddex_netxml20120214ddexC_TariffReference_TariffSubReference', pyxb.binding.datatypes.string)
    __TariffSubReference._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4618, 12)
    __TariffSubReference._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4618, 12)
    
    TariffSubReference = property(__TariffSubReference.value, __TariffSubReference.set, None, 'The ddex:Reference to a ddex:TextDocument containing more specific details of a ddex:Tariff. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode,
        __TariffSubReference.name() : __TariffSubReference
    })
Namespace.addCategoryObject('typeBinding', 'TariffReference', TariffReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}TaxRate with content type ELEMENT_ONLY
class TaxRate (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:TaxRate."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TaxRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4640, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Rate uses Python identifier Rate
    __Rate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Rate'), 'Rate', '__httpddex_netxml20120214ddexC_TaxRate_Rate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4645, 9), )

    
    Rate = property(__Rate.value, __Rate.set, None, 'The ddexC:TaxRate as a percentage.')

    
    # Element TaxType uses Python identifier TaxType
    __TaxType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TaxType'), 'TaxType', '__httpddex_netxml20120214ddexC_TaxRate_TaxType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4650, 9), )

    
    TaxType = property(__TaxType.value, __TaxType.set, None, 'A ddex:Composite containing details of the ddex:Type of ddex:Tax.')

    
    # Element TaxScope uses Python identifier TaxScope
    __TaxScope = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TaxScope'), 'TaxScope', '__httpddex_netxml20120214ddexC_TaxRate_TaxScope', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4655, 9), )

    
    TaxScope = property(__TaxScope.value, __TaxScope.set, None, 'A ddex:Composite containing details of the ddex:Type of ddex:Tax according to its scope.')

    _ElementMap.update({
        __Rate.name() : __Rate,
        __TaxType.name() : __TaxType,
        __TaxScope.name() : __TaxScope
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'TaxRate', TaxRate)


# Complex type {http://ddex.net/xml/20120214/ddexC}TechnicalInstantiation with content type ELEMENT_ONLY
class TechnicalInstantiation (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing technical details of a ddex:Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TechnicalInstantiation')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4700, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element DrmEnforcementType uses Python identifier DrmEnforcementType
    __DrmEnforcementType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DrmEnforcementType'), 'DrmEnforcementType', '__httpddex_netxml20120214ddexC_TechnicalInstantiation_DrmEnforcementType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4705, 9), )

    
    DrmEnforcementType = property(__DrmEnforcementType.value, __DrmEnforcementType.set, None, 'A ddex:Type of DRM enforcement.')

    
    # Element VideoDefinitionType uses Python identifier VideoDefinitionType
    __VideoDefinitionType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VideoDefinitionType'), 'VideoDefinitionType', '__httpddex_netxml20120214ddexC_TechnicalInstantiation_VideoDefinitionType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4710, 9), )

    
    VideoDefinitionType = property(__VideoDefinitionType.value, __VideoDefinitionType.set, None, 'A ddex:Type of resolution (or definition) in which a ddex:Video is provided.')

    
    # Element CodingType uses Python identifier CodingType
    __CodingType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CodingType'), 'CodingType', '__httpddex_netxml20120214ddexC_TechnicalInstantiation_CodingType', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4715, 9), )

    
    CodingType = property(__CodingType.value, __CodingType.set, None, 'A ddex:Type of coding used to encode a ddex:Resource.')

    
    # Element BitRate uses Python identifier BitRate
    __BitRate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'BitRate'), 'BitRate', '__httpddex_netxml20120214ddexC_TechnicalInstantiation_BitRate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4720, 9), )

    
    BitRate = property(__BitRate.value, __BitRate.set, None, 'A ddex:Composite containing the ddex:BitRate for the audio data and a ddex:UnitOfMeasure (the default is ddex:kbps).')

    _ElementMap.update({
        __DrmEnforcementType.name() : __DrmEnforcementType,
        __VideoDefinitionType.name() : __VideoDefinitionType,
        __CodingType.name() : __CodingType,
        __BitRate.name() : __BitRate
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'TechnicalInstantiation', TechnicalInstantiation)


# Complex type {http://ddex.net/xml/20120214/ddexC}TextDetailsByTerritory with content type ELEMENT_ONLY
class TextDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors, Dates and other attributes of a ddex:Text which may vary according to ddex:Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TextDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4751, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_TextDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4757, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:Text details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_TextDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4762, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:Text details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20120214ddexC_TextDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4768, 9), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A ddex:Composite containing details of a ddex:Contributor to the ddex:Text.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20120214ddexC_TextDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4774, 9), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:Text.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20120214ddexC_TextDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4780, 9), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A ddex:Composite containing details of the ddex:CLine for the ddex:Text.')

    
    # Element CourtesyLine uses Python identifier CourtesyLine
    __CourtesyLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), 'CourtesyLine', '__httpddex_netxml20120214ddexC_TextDetailsByTerritory_CourtesyLine', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4785, 9), )

    
    CourtesyLine = property(__CourtesyLine.value, __CourtesyLine.set, None, 'A ddex:Composite containing an ddex:Annotation which acknowledges record companies and/or other Parties giving permission for ddex:Artists or others featured in the ddex:Text.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20120214ddexC_TextDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4790, 9), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Text was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_TextDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4796, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4796, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:TextDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __CLine.name() : __CLine,
        __CourtesyLine.name() : __CourtesyLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'TextDetailsByTerritory', TextDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}TextId with content type ELEMENT_ONLY
class TextId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Identifiers of a ddex:Text."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TextId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4802, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISBN uses Python identifier ISBN
    __ISBN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISBN'), 'ISBN', '__httpddex_netxml20120214ddexC_TextId_ISBN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4807, 9), )

    
    ISBN = property(__ISBN.value, __ISBN.set, None, "The ddex:ISBN (International Standard Book Number defined in ISO 2108) for the ddex:Text. An ddex:ISBN is a 13-digit number. Pre-2007, ddex:ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix '978' and re-calculating the check character.")

    
    # Element ISSN uses Python identifier ISSN
    __ISSN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISSN'), 'ISSN', '__httpddex_netxml20120214ddexC_TextId_ISSN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4812, 9), )

    
    ISSN = property(__ISSN.value, __ISSN.set, None, 'The ddex:ISSN (International Standard Serial Number defined in ISO 3297) identifying the ddex:Text. An ddex:ISSN comprises two groups of four digits, separated by a hyphen and a control digit.')

    
    # Element SICI uses Python identifier SICI
    __SICI = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SICI'), 'SICI', '__httpddex_netxml20120214ddexC_TextId_SICI', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4817, 9), )

    
    SICI = property(__SICI.value, __SICI.set, None, 'The ddex:SICI (Serial Item and Contribution ddex:Identifier defined in ANSI/NISO Z39.56-199)  for the ddex:Text.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_TextId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4822, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Text (usually one per society involved in the messaging).')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_TextId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4829, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4829, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ISBN.name() : __ISBN,
        __ISSN.name() : __ISSN,
        __SICI.name() : __SICI,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'TextId', TextId)


# Complex type {http://ddex.net/xml/20120214/ddexC}TitleText with content type SIMPLE
class TitleText (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:TitleText."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TitleText')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4881, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_TitleText_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4887, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4887, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:TitleText as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'TitleText', TitleText)


# Complex type {http://ddex.net/xml/20120214/ddexC}TotalRoyaltyAmount with content type ELEMENT_ONLY
class TotalRoyaltyAmount (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a total ddex:RoyaltyAmount."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TotalRoyaltyAmount')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4895, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ReleaseType uses Python identifier ReleaseType
    __ReleaseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseType'), 'ReleaseType', '__httpddex_netxml20120214ddexC_TotalRoyaltyAmount_ReleaseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4900, 9), )

    
    ReleaseType = property(__ReleaseType.value, __ReleaseType.set, None, 'A ddex:Composite containing details of the ddex:ReleaseType for which the ddex:RoyaltyAmount is calculated.')

    
    # Element RightsType uses Python identifier RightsType
    __RightsType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsType'), 'RightsType', '__httpddex_netxml20120214ddexC_TotalRoyaltyAmount_RightsType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4905, 9), )

    
    RightsType = property(__RightsType.value, __RightsType.set, None, 'A ddex:Composite containing details of the RightsType for which the ddex:RoyaltyAmount is calculated.')

    
    # Element RoyaltyAmount uses Python identifier RoyaltyAmount
    __RoyaltyAmount = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RoyaltyAmount'), 'RoyaltyAmount', '__httpddex_netxml20120214ddexC_TotalRoyaltyAmount_RoyaltyAmount', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4910, 9), )

    
    RoyaltyAmount = property(__RoyaltyAmount.value, __RoyaltyAmount.set, None, 'A ddex:Composite containing details of the ddex:RoyaltyAmount due.')

    _ElementMap.update({
        __ReleaseType.name() : __ReleaseType,
        __RightsType.name() : __RightsType,
        __RoyaltyAmount.name() : __RoyaltyAmount
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'TotalRoyaltyAmount', TotalRoyaltyAmount)


# Complex type {http://ddex.net/xml/20120214/ddexC}TypedSubTitle with content type SIMPLE
class TypedSubTitle (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SubTitle, including ddex:Titles of ddex:Versions used to differentiate different versions of the same ddex:Title, as required by the ddex:GRid and ddex:ISRC ddex:ReferenceDescriptiveMetadataSets."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TypedSubTitle')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4917, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_TypedSubTitle_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4923, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4923, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddexC:SubTitle as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute SubTitleType uses Python identifier SubTitleType
    __SubTitleType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SubTitleType'), 'SubTitleType', '__httpddex_netxml20120214ddexC_TypedSubTitle_SubTitleType', pyxb.binding.datatypes.string)
    __SubTitleType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4928, 12)
    __SubTitleType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4928, 12)
    
    SubTitleType = property(__SubTitleType.value, __SubTitleType.set, None, 'A ddex:Type of the ddexC:SubTitle which defines its origin or the function it fulfils. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode,
        __SubTitleType.name() : __SubTitleType
    })
Namespace.addCategoryObject('typeBinding', 'TypedSubTitle', TypedSubTitle)


# Complex type {http://ddex.net/xml/20120214/ddexC}Usage with content type ELEMENT_ONLY
class Usage (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing ddex:Types and number of Usages of a ddex:Release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Usage')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4936, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element UseType uses Python identifier UseType
    __UseType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UseType'), 'UseType', '__httpddex_netxml20120214ddexC_Usage_UseType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4941, 9), )

    
    UseType = property(__UseType.value, __UseType.set, None, 'A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.')

    
    # Element UserInterfaceType uses Python identifier UserInterfaceType
    __UserInterfaceType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), 'UserInterfaceType', '__httpddex_netxml20120214ddexC_Usage_UserInterfaceType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4946, 9), )

    
    UserInterfaceType = property(__UserInterfaceType.value, __UserInterfaceType.set, None, 'A ddex:Composite containing details of a physical interface by which a ddex:Consumer is intended to use a ddex:Service or ddex:Release.')

    
    # Element DistributionChannelType uses Python identifier DistributionChannelType
    __DistributionChannelType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), 'DistributionChannelType', '__httpddex_netxml20120214ddexC_Usage_DistributionChannelType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4952, 9), )

    
    DistributionChannelType = property(__DistributionChannelType.value, __DistributionChannelType.set, None, 'A ddex:Composite containing details of a distribution channel intended to be used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.')

    
    # Element CarrierType uses Python identifier CarrierType
    __CarrierType = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CarrierType'), 'CarrierType', '__httpddex_netxml20120214ddexC_Usage_CarrierType', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4958, 9), )

    
    CarrierType = property(__CarrierType.value, __CarrierType.set, None, 'A ddex:Composite containing details of a ddex:Carrier.')

    
    # Element TechnicalInstantiation uses Python identifier TechnicalInstantiation
    __TechnicalInstantiation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TechnicalInstantiation'), 'TechnicalInstantiation', '__httpddex_netxml20120214ddexC_Usage_TechnicalInstantiation', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4963, 9), )

    
    TechnicalInstantiation = property(__TechnicalInstantiation.value, __TechnicalInstantiation.set, None, 'A ddex:Composite containing technical details of the ddex:Release.')

    
    # Element NumberOfUsages uses Python identifier NumberOfUsages
    __NumberOfUsages = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'NumberOfUsages'), 'NumberOfUsages', '__httpddex_netxml20120214ddexC_Usage_NumberOfUsages', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4968, 9), )

    
    NumberOfUsages = property(__NumberOfUsages.value, __NumberOfUsages.set, None, 'The number of times a ddex:Release can be used under the terms of the ddex:Deal.')

    _ElementMap.update({
        __UseType.name() : __UseType,
        __UserInterfaceType.name() : __UserInterfaceType,
        __DistributionChannelType.name() : __DistributionChannelType,
        __CarrierType.name() : __CarrierType,
        __TechnicalInstantiation.name() : __TechnicalInstantiation,
        __NumberOfUsages.name() : __NumberOfUsages
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'Usage', Usage)


# Complex type {http://ddex.net/xml/20120214/ddexC}UserDefinedResourceDetailsByTerritory with content type ELEMENT_ONLY
class UserDefinedResourceDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors, Dates and other attributes of a ddex:UserDefinedResource application which may vary according to ddex:Territory of release."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserDefinedResourceDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4994, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_UserDefinedResourceDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5000, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:UserDefinedResource details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_UserDefinedResourceDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5005, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:UserDefinedResource details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20120214ddexC_UserDefinedResourceDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5011, 9), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A ddex:Composite containing details of a ddex:Contributor to the ddex:UserDefinedResource.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20120214ddexC_UserDefinedResourceDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5017, 9), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:UserDefinedResource.')

    
    # Element UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_UserDefinedResourceDetailsByTerritory_UserDefinedValue', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5023, 9), )

    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:Composite containing details of a ddex:UserDefinedValue.')

    
    # Element PLine uses Python identifier PLine
    __PLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLine'), 'PLine', '__httpddex_netxml20120214ddexC_UserDefinedResourceDetailsByTerritory_PLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5029, 9), )

    
    PLine = property(__PLine.value, __PLine.set, None, 'A ddex:Composite containing details of the ddex:PLine for the ddex:UserDefinedResource.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20120214ddexC_UserDefinedResourceDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5034, 9), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A ddex:Composite containing details of the ddex:CLine for the ddex:UserDefinedResource.')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20120214ddexC_UserDefinedResourceDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5039, 9), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:UserDefinedResource was originally published, whether for physical or electronic/online distribution.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_UserDefinedResourceDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5045, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5045, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:UserDefinedResourceDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __UserDefinedValue.name() : __UserDefinedValue,
        __PLine.name() : __PLine,
        __CLine.name() : __CLine,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'UserDefinedResourceDetailsByTerritory', UserDefinedResourceDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}UserDefinedResourceId with content type ELEMENT_ONLY
class UserDefinedResourceId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Identifiers of a ddex:UserDefinedResource."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserDefinedResourceId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5051, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_UserDefinedResourceId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5056, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:UserDefinedResource.')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_UserDefinedResourceId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5062, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5062, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'UserDefinedResourceId', UserDefinedResourceId)


# Complex type {http://ddex.net/xml/20120214/ddexC}UserDefinedResourceType with content type SIMPLE
class UserDefinedResourceType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:UserDefinedResourceType."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserDefinedResourceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5068, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_UserDefinedResourceType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5074, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5074, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:UserDefinedResourceType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'UserDefinedResourceType', UserDefinedResourceType)


# Complex type {http://ddex.net/xml/20120214/ddexC}UserDefinedValue with content type SIMPLE
class UserDefinedValue (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:UserDefinedValue."""
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserDefinedValue')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5082, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_UserDefinedValue_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5088, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5088, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:UserDefinedValue. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Description uses Python identifier Description
    __Description = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Description'), 'Description', '__httpddex_netxml20120214ddexC_UserDefinedValue_Description', pyxb.binding.datatypes.string)
    __Description._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5093, 12)
    __Description._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5093, 12)
    
    Description = property(__Description.value, __Description.set, None, 'A textual ddex:Description of the ddex:Type or function of the ddexC:UserDefinedValue. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_UserDefinedValue_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5098, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5098, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddex:Description as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __Description.name() : __Description,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'UserDefinedValue', UserDefinedValue)


# Complex type {http://ddex.net/xml/20120214/ddexC}VideoCueSheetReference with content type ELEMENT_ONLY
class VideoCueSheetReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a ddex:VideoCueSheetReference."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoCueSheetReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5149, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element VideoCueSheetReference uses Python identifier VideoCueSheetReference
    __VideoCueSheetReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VideoCueSheetReference'), 'VideoCueSheetReference', '__httpddex_netxml20120214ddexC_VideoCueSheetReference_VideoCueSheetReference', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5154, 9), )

    
    VideoCueSheetReference = property(__VideoCueSheetReference.value, __VideoCueSheetReference.set, None, 'A ddex:Reference for a ddex:CueSheet (specific to this ddex:Message). This is a ddex:LocalCueSheetAnchorReference starting with the letter Q.')

    _ElementMap.update({
        __VideoCueSheetReference.name() : __VideoCueSheetReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'VideoCueSheetReference', VideoCueSheetReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}VideoCueSheetReferenceList with content type ELEMENT_ONLY
class VideoCueSheetReferenceList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a list of ddex:VideoCueSheetReferences."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoCueSheetReferenceList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5166, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element VideoCueSheetReference uses Python identifier VideoCueSheetReference
    __VideoCueSheetReference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VideoCueSheetReference'), 'VideoCueSheetReference', '__httpddex_netxml20120214ddexC_VideoCueSheetReferenceList_VideoCueSheetReference', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5171, 9), )

    
    VideoCueSheetReference = property(__VideoCueSheetReference.value, __VideoCueSheetReference.set, None, 'A ddex:Reference for a ddex:CueSheet (specific to this ddex:Message). This is a ddex:LocalCueSheetAnchorReference starting with the letter Q.')

    _ElementMap.update({
        __VideoCueSheetReference.name() : __VideoCueSheetReference
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'VideoCueSheetReferenceList', VideoCueSheetReferenceList)


# Complex type {http://ddex.net/xml/20120214/ddexC}VideoDetailsByTerritory with content type ELEMENT_ONLY
class VideoDetailsByTerritory (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Descriptors and other attributes of a ddex:Video which may vary according to ddex:Territory of release. """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoDetailsByTerritory')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5183, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_TerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5189, 12), )

    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddex:SoundRecording details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ')

    
    # Element ExcludedTerritoryCode uses Python identifier ExcludedTerritoryCode
    __ExcludedTerritoryCode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), 'ExcludedTerritoryCode', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_ExcludedTerritoryCode', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5194, 12), )

    
    ExcludedTerritoryCode = property(__ExcludedTerritoryCode.value, __ExcludedTerritoryCode.set, None, 'A ddex:Territory to which the ddex:SoundRecording details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.')

    
    # Element Title uses Python identifier Title
    __Title = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Title'), 'Title', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_Title', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5200, 9), )

    
    Title = property(__Title.value, __Title.set, None, 'A ddex:Composite containing details of a ddex:Title of the ddex:SoundRecording.')

    
    # Element DisplayArtist uses Python identifier DisplayArtist
    __DisplayArtist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), 'DisplayArtist', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_DisplayArtist', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5205, 9), )

    
    DisplayArtist = property(__DisplayArtist.value, __DisplayArtist.set, None, 'A ddex:Composite containing details of the ddex:DisplayArtist for the ddex:SoundRecording. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.')

    
    # Element ResourceContributor uses Python identifier ResourceContributor
    __ResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), 'ResourceContributor', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_ResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5210, 9), )

    
    ResourceContributor = property(__ResourceContributor.value, __ResourceContributor.set, None, 'A ddex:Composite containing details of a ddex:Contributor to the ddex:SoundRecording.')

    
    # Element IndirectResourceContributor uses Python identifier IndirectResourceContributor
    __IndirectResourceContributor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), 'IndirectResourceContributor', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_IndirectResourceContributor', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5216, 9), )

    
    IndirectResourceContributor = property(__IndirectResourceContributor.value, __IndirectResourceContributor.set, None, 'A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:SoundRecording.')

    
    # Element RightsAgreementId uses Python identifier RightsAgreementId
    __RightsAgreementId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), 'RightsAgreementId', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_RightsAgreementId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5222, 9), )

    
    RightsAgreementId = property(__RightsAgreementId.value, __RightsAgreementId.set, None, 'A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:SoundRecording.')

    
    # Element LabelName uses Python identifier LabelName
    __LabelName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LabelName'), 'LabelName', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_LabelName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5227, 9), )

    
    LabelName = property(__LabelName.value, __LabelName.set, None, 'A ddex:Composite containing the ddex:Name of the ddex:Label under which the ddex:Release is to be marketed.')

    
    # Element RightsController uses Python identifier RightsController
    __RightsController = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RightsController'), 'RightsController', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_RightsController', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5232, 9), )

    
    RightsController = property(__RightsController.value, __RightsController.set, None, 'A ddex:Composite containing details of ddex:RightsController of Rights in the ddex:SoundRecording.')

    
    # Element RemasteredDate uses Python identifier RemasteredDate
    __RemasteredDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), 'RemasteredDate', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_RemasteredDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5238, 9), )

    
    RemasteredDate = property(__RemasteredDate.value, __RemasteredDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SoundRecording was re-mastered (usually digitally).')

    
    # Element OriginalResourceReleaseDate uses Python identifier OriginalResourceReleaseDate
    __OriginalResourceReleaseDate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), 'OriginalResourceReleaseDate', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_OriginalResourceReleaseDate', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5243, 9), )

    
    OriginalResourceReleaseDate = property(__OriginalResourceReleaseDate.value, __OriginalResourceReleaseDate.set, None, 'A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SoundRecording was originally published, whether for physical or electronic/online distribution.')

    
    # Element PLine uses Python identifier PLine
    __PLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLine'), 'PLine', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_PLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5248, 9), )

    
    PLine = property(__PLine.value, __PLine.set, None, 'A ddex:Composite containing details of the ddex:PLine for the ddex:SoundRecording.')

    
    # Element CLine uses Python identifier CLine
    __CLine = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CLine'), 'CLine', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_CLine', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5253, 9), )

    
    CLine = property(__CLine.value, __CLine.set, None, 'A ddex:Composite containing details of the ddex:CLine for the ddex:Video.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_VideoDetailsByTerritory_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5259, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5259, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:SoundRecordingDetailsByTerritory as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __ExcludedTerritoryCode.name() : __ExcludedTerritoryCode,
        __Title.name() : __Title,
        __DisplayArtist.name() : __DisplayArtist,
        __ResourceContributor.name() : __ResourceContributor,
        __IndirectResourceContributor.name() : __IndirectResourceContributor,
        __RightsAgreementId.name() : __RightsAgreementId,
        __LabelName.name() : __LabelName,
        __RightsController.name() : __RightsController,
        __RemasteredDate.name() : __RemasteredDate,
        __OriginalResourceReleaseDate.name() : __OriginalResourceReleaseDate,
        __PLine.name() : __PLine,
        __CLine.name() : __CLine
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'VideoDetailsByTerritory', VideoDetailsByTerritory)


# Complex type {http://ddex.net/xml/20120214/ddexC}VideoId with content type ELEMENT_ONLY
class VideoId (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of ddex:Identifiers of a ddex:Video."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoId')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5265, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ISRC uses Python identifier ISRC
    __ISRC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISRC'), 'ISRC', '__httpddex_netxml20120214ddexC_VideoId_ISRC', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5270, 9), )

    
    ISRC = property(__ISRC.value, __ISRC.set, None, 'The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:Video. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ')

    
    # Element ISAN uses Python identifier ISAN
    __ISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ISAN'), 'ISAN', '__httpddex_netxml20120214ddexC_VideoId_ISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5275, 9), )

    
    ISAN = property(__ISAN.value, __ISAN.set, None, 'The ddex:ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the ddex:Video. An ddex:ISAN comprises four blocks of four hexadecimal charaters followed by a check character.')

    
    # Element VISAN uses Python identifier VISAN
    __VISAN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VISAN'), 'VISAN', '__httpddex_netxml20120214ddexC_VideoId_VISAN', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5280, 9), )

    
    VISAN = property(__VISAN.value, __VISAN.set, None, 'The V-ISAN (Version ddex:Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the ddex:Video. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.')

    
    # Element CatalogNumber uses Python identifier CatalogNumber
    __CatalogNumber = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), 'CatalogNumber', '__httpddex_netxml20120214ddexC_VideoId_CatalogNumber', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5285, 9), )

    
    CatalogNumber = property(__CatalogNumber.value, __CatalogNumber.set, None, 'A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Video.')

    
    # Element ProprietaryId uses Python identifier ProprietaryId
    __ProprietaryId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), 'ProprietaryId', '__httpddex_netxml20120214ddexC_VideoId_ProprietaryId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5290, 9), )

    
    ProprietaryId = property(__ProprietaryId.value, __ProprietaryId.set, None, 'A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Video (usually one per society involved in the messaging).')

    
    # Attribute IsReplaced uses Python identifier IsReplaced
    __IsReplaced = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsReplaced'), 'IsReplaced', '__httpddex_netxml20120214ddexC_VideoId_IsReplaced', pyxb.binding.datatypes.boolean)
    __IsReplaced._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5297, 6)
    __IsReplaced._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5297, 6)
    
    IsReplaced = property(__IsReplaced.value, __IsReplaced.set, None, 'The ddex:Flag indicating whether this ddex:Identifier is old and has been replaced by a new one (=True) or not (=False). The ddex:Flag may only be set to True when the new ddex:Identifier is also provided. If the ddex:Flag is not set, this ddex:Identifier is deemed to be the current one.')

    _ElementMap.update({
        __ISRC.name() : __ISRC,
        __ISAN.name() : __ISAN,
        __VISAN.name() : __VISAN,
        __CatalogNumber.name() : __CatalogNumber,
        __ProprietaryId.name() : __ProprietaryId
    })
    _AttributeMap.update({
        __IsReplaced.name() : __IsReplaced
    })
Namespace.addCategoryObject('typeBinding', 'VideoId', VideoId)


# Complex type {http://ddex.net/xml/20120214/ddexC}WebPage with content type ELEMENT_ONLY
class WebPage (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:WebPage."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'WebPage')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5322, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_WebPage_PartyId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5327, 9), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for a ddex:Party owning the ddexC:WebPage. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element ReleaseId uses Python identifier ReleaseId
    __ReleaseId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ReleaseId'), 'ReleaseId', '__httpddex_netxml20120214ddexC_WebPage_ReleaseId', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5332, 9), )

    
    ReleaseId = property(__ReleaseId.value, __ReleaseId.set, None, 'A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid should always be used.')

    
    # Element PageName uses Python identifier PageName
    __PageName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PageName'), 'PageName', '__httpddex_netxml20120214ddexC_WebPage_PageName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5337, 9), )

    
    PageName = property(__PageName.value, __PageName.set, None, 'A ddex:Composite containing the ddex:Name of the ddex:WebPage.')

    
    # Element URL uses Python identifier URL
    __URL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'URL'), 'URL', '__httpddex_netxml20120214ddexC_WebPage_URL', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5342, 9), )

    
    URL = property(__URL.value, __URL.set, None, 'A ddex:URL of the ddex:WebPage.')

    
    # Element UserName uses Python identifier UserName
    __UserName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'UserName'), 'UserName', '__httpddex_netxml20120214ddexC_WebPage_UserName', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5347, 9), )

    
    UserName = property(__UserName.value, __UserName.set, None, 'An ddex:Identifier of a computer user who is granted maintenance access to the ddex:WebPage.')

    
    # Element Password uses Python identifier Password
    __Password = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Password'), 'Password', '__httpddex_netxml20120214ddexC_WebPage_Password', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5352, 9), )

    
    Password = property(__Password.value, __Password.set, None, 'A ddex:Password needed to grant a user maintenance access to the ddex:WebPage in combination with the ddex:UserName.')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __ReleaseId.name() : __ReleaseId,
        __PageName.name() : __PageName,
        __URL.name() : __URL,
        __UserName.name() : __UserName,
        __Password.name() : __Password
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', 'WebPage', WebPage)


# Complex type {http://ddex.net/xml/20120214/ddexC}WorkList with content type ELEMENT_ONLY
class WorkList (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of one or more ddex:Works."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'WorkList')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5359, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element MusicalWork uses Python identifier MusicalWork
    __MusicalWork = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MusicalWork'), 'MusicalWork', '__httpddex_netxml20120214ddexC_WorkList_MusicalWork', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5364, 9), )

    
    MusicalWork = property(__MusicalWork.value, __MusicalWork.set, None, 'A ddex:Composite containing details of a ddex:MusicalWork contained in a ddex:Resource.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_WorkList_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5370, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5370, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:WorkList as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        __MusicalWork.name() : __MusicalWork
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'WorkList', WorkList)


# Complex type {http://ddex.net/xml/20120214/ddexC}AdministratingRecordCompany with content type ELEMENT_ONLY
class AdministratingRecordCompany (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:AdministratingRecordCompany."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AdministratingRecordCompany')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 32, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element PartyId uses Python identifier PartyId
    __PartyId = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyId'), 'PartyId', '__httpddex_netxml20120214ddexC_AdministratingRecordCompany_PartyId', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 37, 9), )

    
    PartyId = property(__PartyId.value, __PartyId.set, None, 'A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.')

    
    # Element PartyName uses Python identifier PartyName
    __PartyName = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PartyName'), 'PartyName', '__httpddex_netxml20120214ddexC_AdministratingRecordCompany_PartyName', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 43, 12), )

    
    PartyName = property(__PartyName.value, __PartyName.set, None, 'A ddex:Composite containing details of the PartyName(s).')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_AdministratingRecordCompany_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 55, 6)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 55, 6)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the Role if it belongs to a proprietary scheme. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_AdministratingRecordCompany_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 60, 6)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 60, 6)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:Role. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Role uses Python identifier Role
    __Role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Role'), 'Role', '__httpddex_netxml20120214ddexC_AdministratingRecordCompany_Role', _ImportedBinding__ddex.AdministratingRecordCompanyRole, required=True)
    __Role._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 65, 6)
    __Role._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 65, 6)
    
    Role = property(__Role.value, __Role.set, None, 'The role played by the ddex:Party responsible for administering Rights in a ddex:Resource or a ddex:Release.')

    _ElementMap.update({
        __PartyId.name() : __PartyId,
        __PartyName.name() : __PartyName
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue,
        __Role.name() : __Role
    })
Namespace.addCategoryObject('typeBinding', 'AdministratingRecordCompany', AdministratingRecordCompany)


# Complex type {http://ddex.net/xml/20120214/ddexC}AppliedRoyaltyRate with content type SIMPLE
class AppliedRoyaltyRate (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an applied ddex:RoyaltyRate."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AppliedRoyaltyRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 136, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute ValueType uses Python identifier ValueType
    __ValueType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ValueType'), 'ValueType', '__httpddex_netxml20120214ddexC_AppliedRoyaltyRate_ValueType', _ImportedBinding__ddex.ValueType, required=True)
    __ValueType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 142, 12)
    __ValueType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 142, 12)
    
    ValueType = property(__ValueType.value, __ValueType.set, None, 'The ddex:Type of the numeric value specified for the ddex:RoyaltyRate. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute RoyaltyRateType uses Python identifier RoyaltyRateType
    __RoyaltyRateType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'RoyaltyRateType'), 'RoyaltyRateType', '__httpddex_netxml20120214ddexC_AppliedRoyaltyRate_RoyaltyRateType', _ImportedBinding__ddex.RoyaltyRateType, required=True)
    __RoyaltyRateType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 147, 12)
    __RoyaltyRateType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 147, 12)
    
    RoyaltyRateType = property(__RoyaltyRateType.value, __RoyaltyRateType.set, None, 'A ddex:Type of ddex:RoyaltyRate upon which the per unit royalty is calculated. ')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_AppliedRoyaltyRate_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 152, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 152, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:RoyaltyRateType if it is ddex:UserDefined. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_AppliedRoyaltyRate_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 157, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 157, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:RoyaltyRateType if it is ddex:UserDefined. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __ValueType.name() : __ValueType,
        __RoyaltyRateType.name() : __RoyaltyRateType,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'AppliedRoyaltyRate', AppliedRoyaltyRate)


# Complex type {http://ddex.net/xml/20120214/ddexC}ArtistRole with content type SIMPLE
class ArtistRole (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:ArtistRole. Note: This can be used in a ddex:DdexMessage in relation to any ddex:Performance or ddex:Fixation either of which may form the whole or part of the ddex:Resource itself. Example: if an 'AssociatedPerformer' is shown as a ddex:Contributor to a ddex:MusicalWork it refers to a ddex:Performer of a ddex:Resource (e.g. a ddex:SoundRecording) expressing the ddex:MusicalWork."""
    _TypeDefinition = _ImportedBinding__ddex.ArtistRole
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ArtistRole')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 201, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ArtistRole
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ArtistRole_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 207, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 207, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ArtistRole. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ArtistRole_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 212, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 212, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ArtistRole. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ArtistRole', ArtistRole)


# Complex type {http://ddex.net/xml/20120214/ddexC}AudioCodecType with content type SIMPLE
class AudioCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:AudioCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.AudioCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'AudioCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 220, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.AudioCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20120214ddexC_AudioCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 226, 12)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 226, 12)
    
    Version = property(__Version.value, __Version.set, None, 'The ddex:Identifier of the ddex:Version of the ddexC:AudioCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_AudioCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 231, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 231, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:AudioCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_AudioCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 236, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 236, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:AudioCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'AudioCodecType', AudioCodecType)


# Complex type {http://ddex.net/xml/20120214/ddexC}BitRate with content type SIMPLE
class BitRate (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a ddex:BitRate and a ddex:UnitOfMeasure."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'BitRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 261, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute UnitOfMeasure uses Python identifier UnitOfMeasure
    __UnitOfMeasure = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UnitOfMeasure'), 'UnitOfMeasure', '__httpddex_netxml20120214ddexC_BitRate_UnitOfMeasure', _ImportedBinding__ddex.UnitOfBitRate)
    __UnitOfMeasure._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 267, 12)
    __UnitOfMeasure._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 267, 12)
    
    UnitOfMeasure = property(__UnitOfMeasure.value, __UnitOfMeasure.set, None, 'The ddex:UnitOfMeasure of the ddexC:BitRate. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __UnitOfMeasure.name() : __UnitOfMeasure
    })
Namespace.addCategoryObject('typeBinding', 'BitRate', BitRate)


# Complex type {http://ddex.net/xml/20120214/ddexC}CalculationType with content type SIMPLE
class CalculationType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CalculationType."""
    _TypeDefinition = _ImportedBinding__ddex.CalculationType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CalculationType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 302, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CalculationType
    
    # Attribute SequenceNumber uses Python identifier SequenceNumber
    __SequenceNumber = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), 'SequenceNumber', '__httpddex_netxml20120214ddexC_CalculationType_SequenceNumber', pyxb.binding.datatypes.integer)
    __SequenceNumber._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 308, 12)
    __SequenceNumber._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 308, 12)
    
    SequenceNumber = property(__SequenceNumber.value, __SequenceNumber.set, None, 'The number indicating the order of the ddexC:CalculationType in a group of ddex:CalculationTypes. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __SequenceNumber.name() : __SequenceNumber
    })
Namespace.addCategoryObject('typeBinding', 'CalculationType', CalculationType)


# Complex type {http://ddex.net/xml/20120214/ddexC}CarrierType with content type SIMPLE
class CarrierType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CarrierType."""
    _TypeDefinition = _ImportedBinding__ddex.CarrierType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CarrierType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 316, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CarrierType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CarrierType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 322, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 322, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:CarrierType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CarrierType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 327, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 327, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:CarrierType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CarrierType', CarrierType)


# Complex type {http://ddex.net/xml/20120214/ddexC}CdProtectionType with content type SIMPLE
class CdProtectionType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CdProtectionType."""
    _TypeDefinition = _ImportedBinding__ddex.CdProtectionType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CdProtectionType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 349, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CdProtectionType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CdProtectionType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 355, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 355, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:CdProtectionType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CdProtectionType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 360, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 360, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:CdProtectionType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CdProtectionType', CdProtectionType)


# Complex type {http://ddex.net/xml/20120214/ddexC}CollectionType with content type SIMPLE
class CollectionType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CollectionType. ddex:Collections referenced from ddex:Video ddex:Resources are of ddex:CollectionType ddex:VideoChapter . ddex:Collections referenced from a ddex:Release composite are of ddex:CollectionType ddex:Series, ddex:Season or ddex:Episode."""
    _TypeDefinition = _ImportedBinding__ddex.CollectionType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CollectionType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 668, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CollectionType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CollectionType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 674, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 674, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:CollectionType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CollectionType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 679, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 679, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:CollectionType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CollectionType', CollectionType)


# Complex type {http://ddex.net/xml/20120214/ddexC}CommercialModelType with content type SIMPLE
class CommercialModelType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CommercialModelType."""
    _TypeDefinition = _ImportedBinding__ddex.CommercialModelType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CommercialModelType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 701, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CommercialModelType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CommercialModelType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 707, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 707, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:CommercialModelType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CommercialModelType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 712, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 712, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:CommercialModelType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CommercialModelType', CommercialModelType)


# Complex type {http://ddex.net/xml/20120214/ddexC}ContainerFormat with content type SIMPLE
class ContainerFormat (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ContainerFormat."""
    _TypeDefinition = _ImportedBinding__ddex.ContainerFormat
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ContainerFormat')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 734, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ContainerFormat
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ContainerFormat_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 740, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 740, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:ContainerFormat. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ContainerFormat_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 745, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 745, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:ContainerFormat. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ContainerFormat', ContainerFormat)


# Complex type {http://ddex.net/xml/20120214/ddexC}CueOrigin with content type SIMPLE
class CueOrigin (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CueOrigin."""
    _TypeDefinition = _ImportedBinding__ddex.CueOrigin
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueOrigin')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 955, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CueOrigin
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CueOrigin_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 961, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 961, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:CueOrigin. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CueOrigin_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 966, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 966, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:CueOrigin. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueOrigin', CueOrigin)


# Complex type {http://ddex.net/xml/20120214/ddexC}CueSheetType with content type SIMPLE
class CueSheetType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CueSheetType."""
    _TypeDefinition = _ImportedBinding__ddex.CueSheetType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueSheetType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1019, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CueSheetType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CueSheetType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1025, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1025, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:CueSheetType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CueSheetType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1030, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1030, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:CueSheetType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueSheetType', CueSheetType)


# Complex type {http://ddex.net/xml/20120214/ddexC}CueThemeType with content type SIMPLE
class CueThemeType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ThemeType for a ddex:Creation referenced in a ddex:Cue."""
    _TypeDefinition = _ImportedBinding__ddex.ThemeType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueThemeType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1038, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ThemeType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CueThemeType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1044, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1044, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:ThemeType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CueThemeType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1049, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1049, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:ThemeType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueThemeType', CueThemeType)


# Complex type {http://ddex.net/xml/20120214/ddexC}CueUseType with content type SIMPLE
class CueUseType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:CueUseType."""
    _TypeDefinition = _ImportedBinding__ddex.CueUseType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueUseType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1057, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.CueUseType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CueUseType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1063, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1063, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:CueUseType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CueUseType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1068, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1068, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:CueUseType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueUseType', CueUseType)


# Complex type {http://ddex.net/xml/20120214/ddexC}CueVisualPerceptionType with content type SIMPLE
class CueVisualPerceptionType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:VisualPerceptionType for a ddex:Creation referenced in a ddex:Cue."""
    _TypeDefinition = _ImportedBinding__ddex.VisualPerceptionType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueVisualPerceptionType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1076, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.VisualPerceptionType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CueVisualPerceptionType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1082, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1082, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:VisualPerceptionType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CueVisualPerceptionType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1087, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1087, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:VisualPerceptionType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueVisualPerceptionType', CueVisualPerceptionType)


# Complex type {http://ddex.net/xml/20120214/ddexC}CueVocalType with content type SIMPLE
class CueVocalType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:VocalType for a ddex:Creation referenced in a ddex:Cue."""
    _TypeDefinition = _ImportedBinding__ddex.VocalType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'CueVocalType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1095, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.VocalType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_CueVocalType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1101, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1101, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:VocalType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_CueVocalType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1106, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1106, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:VocalType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'CueVocalType', CueVocalType)


# Complex type {http://ddex.net/xml/20120214/ddexC}DeductionRate with content type SIMPLE
class DeductionRate (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:DeductionRate."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DeductionRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1174, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute DeductionRateType uses Python identifier DeductionRateType
    __DeductionRateType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'DeductionRateType'), 'DeductionRateType', '__httpddex_netxml20120214ddexC_DeductionRate_DeductionRateType', _ImportedBinding__ddex.DeductionRateType, required=True)
    __DeductionRateType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1180, 12)
    __DeductionRateType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1180, 12)
    
    DeductionRateType = property(__DeductionRateType.value, __DeductionRateType.set, None, 'A ddex:Type of ddexC:DeductionRate. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute DeductionDescription uses Python identifier DeductionDescription
    __DeductionDescription = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'DeductionDescription'), 'DeductionDescription', '__httpddex_netxml20120214ddexC_DeductionRate_DeductionDescription', pyxb.binding.datatypes.string)
    __DeductionDescription._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1185, 12)
    __DeductionDescription._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1185, 12)
    
    DeductionDescription = property(__DeductionDescription.value, __DeductionDescription.set, None, 'A ddex:Description of the ddex:Deduction to be applied to an ddex:Amount to determine the actual ddex:Amount paid. This is a text string with no prescribed allowed values.This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_DeductionRate_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1190, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1190, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddex:DeductionDescription as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __DeductionRateType.name() : __DeductionRateType,
        __DeductionDescription.name() : __DeductionDescription,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'DeductionRate', DeductionRate)


# Complex type {http://ddex.net/xml/20120214/ddexC}DistributionChannelType with content type SIMPLE
class DistributionChannelType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:DistributionChannelType."""
    _TypeDefinition = _ImportedBinding__ddex.DistributionChannelType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DistributionChannelType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1226, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.DistributionChannelType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_DistributionChannelType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1232, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1232, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:DistributionChannelType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_DistributionChannelType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1237, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1237, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:DistributionChannelType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'DistributionChannelType', DistributionChannelType)


# Complex type {http://ddex.net/xml/20120214/ddexC}DrmPlatformType with content type SIMPLE
class DrmPlatformType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:DrmPlatformType."""
    _TypeDefinition = _ImportedBinding__ddex.DrmPlatformType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'DrmPlatformType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1245, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.DrmPlatformType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20120214ddexC_DrmPlatformType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1251, 12)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1251, 12)
    
    Version = property(__Version.value, __Version.set, None, 'The ddex:Identifier of the ddex:Version of the ddexC:DrmPlatformType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_DrmPlatformType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1256, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1256, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:DrmPlatformType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_DrmPlatformType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1261, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1261, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:DrmPlatformType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'DrmPlatformType', DrmPlatformType)


# Complex type {http://ddex.net/xml/20120214/ddexC}Extent with content type SIMPLE
class Extent (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing an ddex:Extent and a ddex:UnitOfMeasure."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Extent')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1430, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute UnitOfMeasure uses Python identifier UnitOfMeasure
    __UnitOfMeasure = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UnitOfMeasure'), 'UnitOfMeasure', '__httpddex_netxml20120214ddexC_Extent_UnitOfMeasure', _ImportedBinding__ddex.UnitOfExtent)
    __UnitOfMeasure._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1436, 12)
    __UnitOfMeasure._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1436, 12)
    
    UnitOfMeasure = property(__UnitOfMeasure.value, __UnitOfMeasure.set, None, 'The ddex:UnitOfMeasure of the ddexC:Extent. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __UnitOfMeasure.name() : __UnitOfMeasure
    })
Namespace.addCategoryObject('typeBinding', 'Extent', Extent)


# Complex type {http://ddex.net/xml/20120214/ddexC}ExternallyLinkedResourceType with content type SIMPLE
class ExternallyLinkedResourceType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:ExternallyLinkedResourceType."""
    _TypeDefinition = _ImportedBinding__ddex.ExternallyLinkedResourceType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ExternallyLinkedResourceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1491, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ExternallyLinkedResourceType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ExternallyLinkedResourceType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1497, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1497, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ExternallyLinkedResourceType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ExternallyLinkedResourceType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1502, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1502, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ExternallyLinkedResourceType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ExternallyLinkedResourceType', ExternallyLinkedResourceType)


# Complex type {http://ddex.net/xml/20120214/ddexC}FingerprintAlgorithmType with content type SIMPLE
class FingerprintAlgorithmType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:FingerprintAlgorithmType."""
    _TypeDefinition = _ImportedBinding__ddex.FingerprintAlgorithmType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'FingerprintAlgorithmType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1568, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.FingerprintAlgorithmType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_FingerprintAlgorithmType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1574, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1574, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:FingerprintAlgorithmType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_FingerprintAlgorithmType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1579, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1579, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:FingerprintAlgorithmType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'FingerprintAlgorithmType', FingerprintAlgorithmType)


# Complex type {http://ddex.net/xml/20120214/ddexC}FrameRate with content type SIMPLE
class FrameRate (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a ddex:FrameRate and a ddex:UnitOfMeasure."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'FrameRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1587, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute UnitOfMeasure uses Python identifier UnitOfMeasure
    __UnitOfMeasure = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UnitOfMeasure'), 'UnitOfMeasure', '__httpddex_netxml20120214ddexC_FrameRate_UnitOfMeasure', _ImportedBinding__ddex.UnitOfFrameRate)
    __UnitOfMeasure._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1593, 12)
    __UnitOfMeasure._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1593, 12)
    
    UnitOfMeasure = property(__UnitOfMeasure.value, __UnitOfMeasure.set, None, 'The ddex:UnitOfMeasure of the ddexC:FrameRate. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __UnitOfMeasure.name() : __UnitOfMeasure
    })
Namespace.addCategoryObject('typeBinding', 'FrameRate', FrameRate)


# Complex type {http://ddex.net/xml/20120214/ddexC}GoverningAgreementType with content type SIMPLE
class GoverningAgreementType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:GoverningAgreementType."""
    _TypeDefinition = _ImportedBinding__ddex.GoverningAgreementType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'GoverningAgreementType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1645, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.GoverningAgreementType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_GoverningAgreementType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1651, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1651, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:GoverningAgreementType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_GoverningAgreementType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1656, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1656, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:GoverningAgreementType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'GoverningAgreementType', GoverningAgreementType)


# Complex type {http://ddex.net/xml/20120214/ddexC}HashSumAlgorithmType with content type SIMPLE
class HashSumAlgorithmType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:HashSumAlgorithmType."""
    _TypeDefinition = _ImportedBinding__ddex.HashSumAlgorithmType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'HashSumAlgorithmType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1700, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.HashSumAlgorithmType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_HashSumAlgorithmType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1706, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1706, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:HashSumAlgorithmType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_HashSumAlgorithmType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1711, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1711, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:HashSumAlgorithmType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'HashSumAlgorithmType', HashSumAlgorithmType)


# Complex type {http://ddex.net/xml/20120214/ddexC}ImageCodecType with content type SIMPLE
class ImageCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:ImageCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.ImageCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ImageCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1776, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ImageCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20120214ddexC_ImageCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1782, 12)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1782, 12)
    
    Version = property(__Version.value, __Version.set, None, 'The ddex:Identifier of the ddex:Version of the ddexC:ImageCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ImageCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1787, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1787, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ImageCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ImageCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1792, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1792, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ImageCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ImageCodecType', ImageCodecType)


# Complex type {http://ddex.net/xml/20120214/ddexC}ImageType with content type SIMPLE
class ImageType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:ImageType."""
    _TypeDefinition = _ImportedBinding__ddex.ImageType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ImageType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1873, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ImageType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ImageType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1879, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1879, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ImageType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ImageType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1884, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1884, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ImageType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ImageType', ImageType)


# Complex type {http://ddex.net/xml/20120214/ddexC}LicenseOrClaimRefusalReason with content type SIMPLE
class LicenseOrClaimRefusalReason (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:LicenseOrClaimRefusalReason."""
    _TypeDefinition = _ImportedBinding__ddex.LicenseOrClaimRefusalReason
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'LicenseOrClaimRefusalReason')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1962, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LicenseOrClaimRefusalReason
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_LicenseOrClaimRefusalReason_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1968, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1968, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:LicenseOrClaimRefusalReason. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_LicenseOrClaimRefusalReason_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1973, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1973, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:LicenseOrClaimRefusalReason. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'LicenseOrClaimRefusalReason', LicenseOrClaimRefusalReason)


# Complex type {http://ddex.net/xml/20120214/ddexC}LicenseOrClaimRequestUpdateReason with content type SIMPLE
class LicenseOrClaimRequestUpdateReason (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:LicenseOrClaimRequestUpdateReason."""
    _TypeDefinition = _ImportedBinding__ddex.LicenseOrClaimRequestUpdateReason
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'LicenseOrClaimRequestUpdateReason')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1981, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LicenseOrClaimRequestUpdateReason
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_LicenseOrClaimRequestUpdateReason_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1987, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1987, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:LicenseOrClaimRequestUpdateReason. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_LicenseOrClaimRequestUpdateReason_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1992, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1992, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:LicenseOrClaimRequestUpdateReason. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'LicenseOrClaimRequestUpdateReason', LicenseOrClaimRequestUpdateReason)


# Complex type {http://ddex.net/xml/20120214/ddexC}LicenseOrClaimUpdateReason with content type SIMPLE
class LicenseOrClaimUpdateReason (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:LicenseOrClaimUpdateReason."""
    _TypeDefinition = _ImportedBinding__ddex.LicenseOrClaimUpdateReason
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'LicenseOrClaimUpdateReason')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2000, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LicenseOrClaimUpdateReason
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_LicenseOrClaimUpdateReason_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2006, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2006, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:LicenseOrClaimUpdateReason. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_LicenseOrClaimUpdateReason_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2011, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2011, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:LicenseOrClaimUpdateReason. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'LicenseOrClaimUpdateReason', LicenseOrClaimUpdateReason)


# Complex type {http://ddex.net/xml/20120214/ddexC}LinkedReleaseResourceReference with content type SIMPLE
class LinkedReleaseResourceReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:LinkedReleaseResourceReference for a ddex:Resource which is linked to a ddex:ContentItem."""
    _TypeDefinition = _ImportedBinding__ddex.LocalResourceAnchorReference
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'LinkedReleaseResourceReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2019, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LocalResourceAnchorReference
    
    # Attribute LinkDescription uses Python identifier LinkDescription
    __LinkDescription = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LinkDescription'), 'LinkDescription', '__httpddex_netxml20120214ddexC_LinkedReleaseResourceReference_LinkDescription', pyxb.binding.datatypes.string)
    __LinkDescription._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2025, 12)
    __LinkDescription._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2025, 12)
    
    LinkDescription = property(__LinkDescription.value, __LinkDescription.set, None, 'A ddex:Composite containing a  ddex:Description of the link for the ddex:ReleaseResourceReference.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_LinkedReleaseResourceReference_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2030, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2030, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:LinkDescription as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __LinkDescription.name() : __LinkDescription,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'LinkedReleaseResourceReference', LinkedReleaseResourceReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}MessageActionType with content type SIMPLE
class MessageActionType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:MessageActionType."""
    _TypeDefinition = _ImportedBinding__ddex.MessageActionType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MessageActionType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2038, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.MessageActionType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_MessageActionType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2044, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2044, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:MessageActionType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_MessageActionType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2049, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2049, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:MessageActionType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'MessageActionType', MessageActionType)


# Complex type {http://ddex.net/xml/20120214/ddexC}MidiType with content type SIMPLE
class MidiType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:MidiType."""
    _TypeDefinition = _ImportedBinding__ddex.MidiType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MidiType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2292, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.MidiType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_MidiType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2298, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2298, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:MidiType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_MidiType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2303, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2303, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:MidiType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'MidiType', MidiType)


# Complex type {http://ddex.net/xml/20120214/ddexC}MusicalWorkContributorRole with content type SIMPLE
class MusicalWorkContributorRole (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:MusicalWorkContributorRole. Note: This can be used in a ddex:DdexMessage in relation to any ddex:Work, ddex:Performance or ddex:Fixation any of which may form the whole or part of the ddex:Resource itself. Example: if an 'AssociatedPerformer' is shown as a ddex:Contributor to a ddex:MusicalWork it refers to a performer of a ddex:Resource (e.g. a ddex:SoundRecording) expressing the ddex:MusicalWork."""
    _TypeDefinition = _ImportedBinding__ddex.MusicalWorkContributorRole
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkContributorRole')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2419, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.MusicalWorkContributorRole
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_MusicalWorkContributorRole_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2425, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2425, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:MusicalWorkContributorRole. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_MusicalWorkContributorRole_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2430, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2430, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:MusicalWorkContributorRole. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkContributorRole', MusicalWorkContributorRole)


# Complex type {http://ddex.net/xml/20120214/ddexC}MusicalWorkType with content type SIMPLE
class MusicalWorkType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:MusicalWorkType."""
    _TypeDefinition = _ImportedBinding__ddex.MusicalWorkType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'MusicalWorkType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2502, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.MusicalWorkType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_MusicalWorkType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2508, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2508, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:MusicalWorkType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_MusicalWorkType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2513, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2513, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:MusicalWorkType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'MusicalWorkType', MusicalWorkType)


# Complex type {http://ddex.net/xml/20120214/ddexC}NumberOfDataMismatchItems with content type SIMPLE
class NumberOfDataMismatchItems (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a ddex:NumberOfDataMismatchItems."""
    _TypeDefinition = pyxb.binding.datatypes.integer
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'NumberOfDataMismatchItems')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2535, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.integer
    
    # Attribute DataMismatchStatus uses Python identifier DataMismatchStatus
    __DataMismatchStatus = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'DataMismatchStatus'), 'DataMismatchStatus', '__httpddex_netxml20120214ddexC_NumberOfDataMismatchItems_DataMismatchStatus', _ImportedBinding__ddex.DataMismatchStatus)
    __DataMismatchStatus._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2541, 12)
    __DataMismatchStatus._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2541, 12)
    
    DataMismatchStatus = property(__DataMismatchStatus.value, __DataMismatchStatus.set, None, 'A status of the DataMismatch(es). This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __DataMismatchStatus.name() : __DataMismatchStatus
    })
Namespace.addCategoryObject('typeBinding', 'NumberOfDataMismatchItems', NumberOfDataMismatchItems)


# Complex type {http://ddex.net/xml/20120214/ddexC}OperatingSystemType with content type SIMPLE
class OperatingSystemType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of an ddex:OperatingSystemType."""
    _TypeDefinition = _ImportedBinding__ddex.OperatingSystemType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'OperatingSystemType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2583, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.OperatingSystemType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20120214ddexC_OperatingSystemType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2589, 12)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2589, 12)
    
    Version = property(__Version.value, __Version.set, None, 'The ddex:Identifier of the ddex:Version of the ddexC:OperatingSystemType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_OperatingSystemType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2594, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2594, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:OperatingSystemType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_OperatingSystemType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2599, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2599, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:OperatingSystemType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'OperatingSystemType', OperatingSystemType)


# Complex type {http://ddex.net/xml/20120214/ddexC}OrderType with content type SIMPLE
class OrderType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:OrderType."""
    _TypeDefinition = _ImportedBinding__ddex.OrderType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'OrderType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2607, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.OrderType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_OrderType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2613, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2613, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:OrderType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_OrderType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2618, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2618, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:OrderType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'OrderType', OrderType)


# Complex type {http://ddex.net/xml/20120214/ddexC}PLine with content type ELEMENT_ONLY
class PLine (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:PLine."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PLine')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2626, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element Year uses Python identifier Year
    __Year = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Year'), 'Year', '__httpddex_netxml20120214ddexC_PLine_Year', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2631, 9), )

    
    Year = property(__Year.value, __Year.set, None, 'The ddex:Year of the ddexC:PLine.')

    
    # Element PLineCompany uses Python identifier PLineCompany
    __PLineCompany = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLineCompany'), 'PLineCompany', '__httpddex_netxml20120214ddexC_PLine_PLineCompany', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2636, 9), )

    
    PLineCompany = property(__PLineCompany.value, __PLineCompany.set, None, 'The ddex:Name of the company releasing the ddex:Creation. This may be an owner or a licensee of the ddex:Creation.')

    
    # Element PLineText uses Python identifier PLineText
    __PLineText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLineText'), 'PLineText', '__httpddex_netxml20120214ddexC_PLine_PLineText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2641, 9), )

    
    PLineText = property(__PLineText.value, __PLineText.set, None, 'The text of the ddexC:PLine. (Note: DDEX expects to deprecate the use of the PLineText element in a subsequent version of this standard. It will be deprecated once users of the standard are able to provide PLine information in a structured form.)')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_PLine_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2647, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2647, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script of the ddex:PLineText as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant]. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute PLineType uses Python identifier PLineType
    __PLineType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'PLineType'), 'PLineType', '__httpddex_netxml20120214ddexC_PLine_PLineType', _ImportedBinding__ddex.PLineType)
    __PLineType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2652, 6)
    __PLineType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2652, 6)
    
    PLineType = property(__PLineType.value, __PLineType.set, None, 'A ddex:Type of ddex:PLine. This is represented in an XML schema as an XML ddex:Attribute. If this ddex:Attribute is not provided, it is assumed that the ddex:PLine is a ddex:OriginalPLine.')

    _ElementMap.update({
        __Year.name() : __Year,
        __PLineCompany.name() : __PLineCompany,
        __PLineText.name() : __PLineText
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode,
        __PLineType.name() : __PLineType
    })
Namespace.addCategoryObject('typeBinding', 'PLine', PLine)


# Complex type {http://ddex.net/xml/20120214/ddexC}ParentalWarningType with content type SIMPLE
class ParentalWarningType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ParentalWarningType."""
    _TypeDefinition = _ImportedBinding__ddex.ParentalWarningType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ParentalWarningType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2658, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ParentalWarningType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ParentalWarningType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2664, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2664, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ParentalWarningType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ParentalWarningType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2669, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2669, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ParentalWarningType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ParentalWarningType', ParentalWarningType)


# Complex type {http://ddex.net/xml/20120214/ddexC}PriceRangeType with content type SIMPLE
class PriceRangeType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:PriceRangeType."""
    _TypeDefinition = _ImportedBinding__ddex.PriceRangeType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PriceRangeType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2868, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.PriceRangeType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_PriceRangeType_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2874, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2874, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:PriceRangeType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'PriceRangeType', PriceRangeType)


# Complex type {http://ddex.net/xml/20120214/ddexC}PriceType with content type SIMPLE
class PriceType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:PriceType."""
    _TypeDefinition = _ImportedBinding__ddex.PriceType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PriceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2882, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.PriceType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_PriceType_Namespace', pyxb.binding.datatypes.string, required=True)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2888, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2888, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:PriceType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace
    })
Namespace.addCategoryObject('typeBinding', 'PriceType', PriceType)


# Complex type {http://ddex.net/xml/20120214/ddexC}ProductType with content type SIMPLE
class ProductType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ProductType."""
    _TypeDefinition = _ImportedBinding__ddex.ProductType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ProductType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2896, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ProductType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ProductType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2902, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2902, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:ProductType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ProductType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2907, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2907, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:ProductType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ProductType', ProductType)


# Complex type {http://ddex.net/xml/20120214/ddexC}Purpose with content type SIMPLE
class Purpose (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Purpose."""
    _TypeDefinition = _ImportedBinding__ddex.Purpose
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Purpose')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2943, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.Purpose
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_Purpose_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2949, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2949, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:Purpose. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_Purpose_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2954, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2954, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:Purpose. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'Purpose', Purpose)


# Complex type {http://ddex.net/xml/20120214/ddexC}RatingAgency with content type SIMPLE
class RatingAgency (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:RatingAgency."""
    _TypeDefinition = _ImportedBinding__ddex.RatingAgency
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RatingAgency')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2962, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.RatingAgency
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_RatingAgency_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2968, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2968, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:RatingAgency. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_RatingAgency_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2973, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2973, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:RatingAgency. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'RatingAgency', RatingAgency)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReasonType with content type SIMPLE
class ReasonType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReasonType."""
    _TypeDefinition = _ImportedBinding__ddex.ReasonType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReasonType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2995, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReasonType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ReasonType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3001, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3001, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:ReasonType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ReasonType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3006, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3006, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:ReasonType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReasonType', ReasonType)


# Complex type {http://ddex.net/xml/20120214/ddexC}RedeliveryReasonType with content type SIMPLE
class RedeliveryReasonType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:RedeliveryReasonType."""
    _TypeDefinition = _ImportedBinding__ddex.RedeliveryReasonType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RedeliveryReasonType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3053, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.RedeliveryReasonType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_RedeliveryReasonType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3059, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3059, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:RedeliveryReasonType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_RedeliveryReasonType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3064, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3064, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:RedeliveryReasonType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'RedeliveryReasonType', RedeliveryReasonType)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseAvailabilityStatus with content type SIMPLE
class ReleaseAvailabilityStatus (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReleaseAvailabilityStatus."""
    _TypeDefinition = _ImportedBinding__ddex.ReleaseAvailabilityStatus
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseAvailabilityStatus')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3178, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReleaseAvailabilityStatus
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ReleaseAvailabilityStatus_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3184, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3184, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:ReleaseAvailabilityStatus. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ReleaseAvailabilityStatus_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3189, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3189, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:ReleaseAvailabilityStatus. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseAvailabilityStatus', ReleaseAvailabilityStatus)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseCollectionReference with content type SIMPLE
class ReleaseCollectionReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReleaseCollectionReference."""
    _TypeDefinition = _ImportedBinding__ddex.LocalCollectionAnchorReference
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseCollectionReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3197, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LocalCollectionAnchorReference
    
    # Attribute ReleaseResourceType uses Python identifier ReleaseResourceType
    __ReleaseResourceType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType'), 'ReleaseResourceType', '__httpddex_netxml20120214ddexC_ReleaseCollectionReference_ReleaseResourceType', _ImportedBinding__ddex.ReleaseResourceType)
    __ReleaseResourceType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3203, 12)
    __ReleaseResourceType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3203, 12)
    
    ReleaseResourceType = property(__ReleaseResourceType.value, __ReleaseResourceType.set, None, 'A ddex:Type of ddex:Collection in the context of a ddex:Release. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __ReleaseResourceType.name() : __ReleaseResourceType
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseCollectionReference', ReleaseCollectionReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseRelationshipType with content type SIMPLE
class ReleaseRelationshipType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReleaseRelationshipType, e.g. between an ddex:AudioClipRelease and a ddex:VideoClipRelease."""
    _TypeDefinition = _ImportedBinding__ddex.ReleaseRelationshipType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseRelationshipType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3338, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReleaseRelationshipType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ReleaseRelationshipType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3344, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3344, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ReleaseRelationshipType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ReleaseRelationshipType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3349, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3349, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ReleaseRelationshipType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseRelationshipType', ReleaseRelationshipType)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseResourceReference with content type SIMPLE
class ReleaseResourceReference (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReleaseResourceReference."""
    _TypeDefinition = _ImportedBinding__ddex.LocalResourceAnchorReference
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseResourceReference')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3357, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.LocalResourceAnchorReference
    
    # Attribute ReleaseResourceType uses Python identifier ReleaseResourceType
    __ReleaseResourceType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType'), 'ReleaseResourceType', '__httpddex_netxml20120214ddexC_ReleaseResourceReference_ReleaseResourceType', _ImportedBinding__ddex.ReleaseResourceType)
    __ReleaseResourceType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3363, 12)
    __ReleaseResourceType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3363, 12)
    
    ReleaseResourceType = property(__ReleaseResourceType.value, __ReleaseResourceType.set, None, 'A ddex:Type of ddex:Resource in the context of a ddex:Release. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __ReleaseResourceType.name() : __ReleaseResourceType
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseResourceReference', ReleaseResourceReference)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReleaseType with content type SIMPLE
class ReleaseType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReleaseType."""
    _TypeDefinition = _ImportedBinding__ddex.ReleaseType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReleaseType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3456, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReleaseType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ReleaseType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3462, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3462, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ReleaseType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ReleaseType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3467, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3467, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ReleaseType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReleaseType', ReleaseType)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReportFormat with content type SIMPLE
class ReportFormat (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReportFormat."""
    _TypeDefinition = _ImportedBinding__ddex.ReportFormat
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReportFormat')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3489, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReportFormat
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ReportFormat_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3495, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3495, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:ReportFormat. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ReportFormat_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3500, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3500, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:ReportFormat. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReportFormat', ReportFormat)


# Complex type {http://ddex.net/xml/20120214/ddexC}ReportType with content type SIMPLE
class ReportType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ReportType."""
    _TypeDefinition = _ImportedBinding__ddex.ReportType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ReportType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3508, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ReportType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ReportType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3514, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3514, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:ReportType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ReportType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3519, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3519, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:ReportType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ReportType', ReportType)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceContributorRole with content type SIMPLE
class ResourceContributorRole (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ResourceContributorRole. Note: This can be used in a ddex:DdexMessage in relation to any ddex:Work, ddex:Performance or ddex:Fixation any of which may form the whole or part of the ddex:Resource itself."""
    _TypeDefinition = _ImportedBinding__ddex.ResourceContributorRole
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceContributorRole')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3609, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ResourceContributorRole
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ResourceContributorRole_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3615, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3615, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ResourceContributorRole. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ResourceContributorRole_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3620, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3620, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ResourceContributorRole. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ResourceContributorRole', ResourceContributorRole)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceOmissionReason with content type SIMPLE
class ResourceOmissionReason (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ResourceOmissionReason."""
    _TypeDefinition = _ImportedBinding__ddex.ResourceOmissionReason
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceOmissionReason')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3748, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ResourceOmissionReason
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ResourceOmissionReason_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3754, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3754, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ResourceOmissionReason. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ResourceOmissionReason_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3759, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3759, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ResourceOmissionReason. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ResourceOmissionReason', ResourceOmissionReason)


# Complex type {http://ddex.net/xml/20120214/ddexC}ResourceType with content type SIMPLE
class ResourceType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:ResourceType. For example a ddex:SoundRecording of a ddex:Performance of a ddex:MusicalWork or an ddex:Image of an ddex:Artist."""
    _TypeDefinition = _ImportedBinding__ddex.ResourceType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'ResourceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3767, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.ResourceType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_ResourceType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3773, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3773, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:ResourceType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_ResourceType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3778, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3778, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:ResourceType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'ResourceType', ResourceType)


# Complex type {http://ddex.net/xml/20120214/ddexC}SamplingRate with content type SIMPLE
class SamplingRate (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing a ddex:SamplingRate and a ddex:UnitOfMeasure."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SamplingRate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4086, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute UnitOfMeasure uses Python identifier UnitOfMeasure
    __UnitOfMeasure = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UnitOfMeasure'), 'UnitOfMeasure', '__httpddex_netxml20120214ddexC_SamplingRate_UnitOfMeasure', _ImportedBinding__ddex.UnitOfFrequency)
    __UnitOfMeasure._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4092, 12)
    __UnitOfMeasure._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4092, 12)
    
    UnitOfMeasure = property(__UnitOfMeasure.value, __UnitOfMeasure.set, None, 'The ddex:UnitOfMeasure of the ddexC:SamplingRate. This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __UnitOfMeasure.name() : __UnitOfMeasure
    })
Namespace.addCategoryObject('typeBinding', 'SamplingRate', SamplingRate)


# Complex type {http://ddex.net/xml/20120214/ddexC}SheetMusicCodecType with content type SIMPLE
class SheetMusicCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SheetMusicCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.SheetMusicCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SheetMusicCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4100, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SheetMusicCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20120214ddexC_SheetMusicCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4106, 12)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4106, 12)
    
    Version = property(__Version.value, __Version.set, None, 'The ddex:Identifier of the ddex:Version of the ddexC:SheetMusicCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_SheetMusicCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4111, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4111, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:SheetMusicCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_SheetMusicCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4116, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4116, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:SheetMusicCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SheetMusicCodecType', SheetMusicCodecType)


# Complex type {http://ddex.net/xml/20120214/ddexC}SheetMusicType with content type SIMPLE
class SheetMusicType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SheetMusicType."""
    _TypeDefinition = _ImportedBinding__ddex.SheetMusicType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SheetMusicType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4203, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SheetMusicType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_SheetMusicType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4209, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4209, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:SheetMusicType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_SheetMusicType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4214, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4214, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:SheetMusicType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SheetMusicType', SheetMusicType)


# Complex type {http://ddex.net/xml/20120214/ddexC}SoftwareType with content type SIMPLE
class SoftwareType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SoftwareType."""
    _TypeDefinition = _ImportedBinding__ddex.SoftwareType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoftwareType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4319, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SoftwareType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_SoftwareType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4325, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4325, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:SoftwareType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_SoftwareType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4330, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4330, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:SoftwareType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SoftwareType', SoftwareType)


# Complex type {http://ddex.net/xml/20120214/ddexC}SoundProcessorType with content type SIMPLE
class SoundProcessorType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SoundProcessorType."""
    _TypeDefinition = _ImportedBinding__ddex.SoundProcessorType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundProcessorType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4338, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SoundProcessorType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20120214ddexC_SoundProcessorType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4344, 12)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4344, 12)
    
    Version = property(__Version.value, __Version.set, None, 'The ddex:Identifier of the ddex:Version of the ddexC:SoundProcessorType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_SoundProcessorType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4349, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4349, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:SoundProcessorType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_SoundProcessorType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4354, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4354, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:SoundProcessorType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SoundProcessorType', SoundProcessorType)


# Complex type {http://ddex.net/xml/20120214/ddexC}SoundRecordingType with content type SIMPLE
class SoundRecordingType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SoundRecordingType."""
    _TypeDefinition = _ImportedBinding__ddex.SoundRecordingType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SoundRecordingType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4527, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SoundRecordingType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_SoundRecordingType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4533, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4533, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:SoundRecordingType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_SoundRecordingType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4538, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4538, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:SoundRecordingType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SoundRecordingType', SoundRecordingType)


# Complex type {http://ddex.net/xml/20120214/ddexC}SupplyChainStatus with content type SIMPLE
class SupplyChainStatus (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:SupplyChainStatus."""
    _TypeDefinition = _ImportedBinding__ddex.SupplyChainStatus
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'SupplyChainStatus')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4574, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.SupplyChainStatus
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_SupplyChainStatus_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4580, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4580, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:SupplyChainStatus. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_SupplyChainStatus_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4585, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4585, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:SupplyChainStatus. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'SupplyChainStatus', SupplyChainStatus)


# Complex type {http://ddex.net/xml/20120214/ddexC}TaxScope with content type SIMPLE
class TaxScope (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:TaxScope."""
    _TypeDefinition = _ImportedBinding__ddex.TaxScope
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TaxScope')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4662, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.TaxScope
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_TaxScope_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4668, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4668, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:TaxScope. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_TaxScope_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4673, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4673, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:TaxScope. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'TaxScope', TaxScope)


# Complex type {http://ddex.net/xml/20120214/ddexC}TaxType with content type SIMPLE
class TaxType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:TaxType."""
    _TypeDefinition = _ImportedBinding__ddex.TaxType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TaxType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4681, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.TaxType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_TaxType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4687, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4687, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:TaxType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_TaxType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4692, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4692, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:TaxType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'TaxType', TaxType)


# Complex type {http://ddex.net/xml/20120214/ddexC}TextCodecType with content type SIMPLE
class TextCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:TextCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.TextCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TextCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4727, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.TextCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20120214ddexC_TextCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4733, 12)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4733, 12)
    
    Version = property(__Version.value, __Version.set, None, 'The ddex:Identifier of the ddex:Version of the ddexC:TextCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_TextCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4738, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4738, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:TextCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_TextCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4743, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4743, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:TextCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'TextCodecType', TextCodecType)


# Complex type {http://ddex.net/xml/20120214/ddexC}TextType with content type SIMPLE
class TextType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:TextType."""
    _TypeDefinition = _ImportedBinding__ddex.TextType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'TextType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4835, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.TextType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_TextType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4841, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4841, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:TextType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_TextType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4846, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4846, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:TextType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'TextType', TextType)


# Complex type {http://ddex.net/xml/20120214/ddexC}Title with content type ELEMENT_ONLY
class Title (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Title."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Title')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4854, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element TitleText uses Python identifier TitleText
    __TitleText = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TitleText'), 'TitleText', '__httpddex_netxml20120214ddexC_Title_TitleText', False, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4859, 9), )

    
    TitleText = property(__TitleText.value, __TitleText.set, None, 'A ddex:Composite containing the text of the ddexC:Title.')

    
    # Element SubTitle uses Python identifier SubTitle
    __SubTitle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SubTitle'), 'SubTitle', '__httpddex_netxml20120214ddexC_Title_SubTitle', True, pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4864, 9), )

    
    SubTitle = property(__SubTitle.value, __SubTitle.set, None, 'A ddex:Composite containing details of a ddex:SubTitle of the ddexC:Title, including ddex:Titles of ddex:Versions used to differentiate different versions of the same ddex:Title, as required by the ddex:GRid and ddex:ISRC ddex:ReferenceDescriptiveMetadataSets.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_Title_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4870, 6)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4870, 6)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:Elements of the ddexC:Title as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute TitleType uses Python identifier TitleType
    __TitleType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'TitleType'), 'TitleType', '__httpddex_netxml20120214ddexC_Title_TitleType', _ImportedBinding__ddex.TitleType)
    __TitleType._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4875, 6)
    __TitleType._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4875, 6)
    
    TitleType = property(__TitleType.value, __TitleType.set, None, "A ddex:Type of the ddexC:Title which defines its origin or the function it fulfils in relation to a ddex:Creation. Note: A ddexC:Title may fulfil more than one role. Example: 'Help' may be both the ddex:OriginalTitle and the ddex:DisplayTitle for the well-known Beatles song. This is represented in an XML schema as an XML ddex:Attribute.")

    _ElementMap.update({
        __TitleText.name() : __TitleText,
        __SubTitle.name() : __SubTitle
    })
    _AttributeMap.update({
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode,
        __TitleType.name() : __TitleType
    })
Namespace.addCategoryObject('typeBinding', 'Title', Title)


# Complex type {http://ddex.net/xml/20120214/ddexC}UseType with content type SIMPLE
class UseType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:UseType."""
    _TypeDefinition = _ImportedBinding__ddex.UseType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UseType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4975, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.UseType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_UseType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4981, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4981, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:UseType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_UseType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4986, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4986, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:UseType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'UseType', UseType)


# Complex type {http://ddex.net/xml/20120214/ddexC}UserInterfaceType with content type SIMPLE
class UserInterfaceType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:UserInterfaceType."""
    _TypeDefinition = _ImportedBinding__ddex.UserInterfaceType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'UserInterfaceType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5106, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.UserInterfaceType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_UserInterfaceType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5112, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5112, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:UserInterfaceType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_UserInterfaceType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5117, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5117, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:UserInterfaceType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'UserInterfaceType', UserInterfaceType)


# Complex type {http://ddex.net/xml/20120214/ddexC}VideoCodecType with content type SIMPLE
class VideoCodecType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:VideoCodecType."""
    _TypeDefinition = _ImportedBinding__ddex.VideoCodecType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoCodecType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5125, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.VideoCodecType
    
    # Attribute Version uses Python identifier Version
    __Version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Version'), 'Version', '__httpddex_netxml20120214ddexC_VideoCodecType_Version', pyxb.binding.datatypes.string)
    __Version._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5131, 12)
    __Version._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5131, 12)
    
    Version = property(__Version.value, __Version.set, None, 'The ddex:Identifier of the ddex:Version of the ddexC:VideoCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_VideoCodecType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5136, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5136, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:VideoCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_VideoCodecType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5141, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5141, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:VideoCodecType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Version.name() : __Version,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'VideoCodecType', VideoCodecType)


# Complex type {http://ddex.net/xml/20120214/ddexC}VideoType with content type SIMPLE
class VideoType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:VideoType."""
    _TypeDefinition = _ImportedBinding__ddex.VideoType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'VideoType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5303, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.VideoType
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_VideoType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5309, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5309, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:VideoType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_VideoType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5314, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5314, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:VideoType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'VideoType', VideoType)


# Complex type {http://ddex.net/xml/20120214/ddexC}WsMessageStatus with content type SIMPLE
class WsMessageStatus (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:WsMessageStatus."""
    _TypeDefinition = _ImportedBinding__ddex.WsMessageStatus
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'WsMessageStatus')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5376, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.WsMessageStatus
    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_WsMessageStatus_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5382, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5382, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddex:WsMessageStatus. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_WsMessageStatus_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5387, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5387, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddex:WsMessageStatus. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'WsMessageStatus', WsMessageStatus)


# Complex type {http://ddex.net/xml/20120214/ddexC}EventDate with content type SIMPLE
class EventDate (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of the Date and ddex:Place of an ddex:Event."""
    _TypeDefinition = pyxb.binding.datatypes.date
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'EventDate')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1352, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.date
    
    # Attribute IsApproximate uses Python identifier IsApproximate
    __IsApproximate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsApproximate'), 'IsApproximate', '__httpddex_netxml20120214ddexC_EventDate_IsApproximate', pyxb.binding.datatypes.boolean)
    __IsApproximate._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1358, 12)
    __IsApproximate._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1358, 12)
    
    IsApproximate = property(__IsApproximate.value, __IsApproximate.set, None, 'The ddex:Flag indicating whether the reported Date is approximate (=True) or exact (=False). This is represented in an XML schema as an XML ddex:Attribute. ')

    
    # Attribute IsBefore uses Python identifier IsBefore
    __IsBefore = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsBefore'), 'IsBefore', '__httpddex_netxml20120214ddexC_EventDate_IsBefore', pyxb.binding.datatypes.boolean)
    __IsBefore._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1363, 12)
    __IsBefore._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1363, 12)
    
    IsBefore = property(__IsBefore.value, __IsBefore.set, None, 'The ddex:Flag indicating whether the ddex:Event being described occurred sometime before the reported Date (=True) or not (=False). This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute IsAfter uses Python identifier IsAfter
    __IsAfter = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsAfter'), 'IsAfter', '__httpddex_netxml20120214ddexC_EventDate_IsAfter', pyxb.binding.datatypes.boolean)
    __IsAfter._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1368, 12)
    __IsAfter._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1368, 12)
    
    IsAfter = property(__IsAfter.value, __IsAfter.set, None, 'The ddex:Flag indicating whether the ddex:Event being described occurred sometime after the reported Date (=True) or not (=False). This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_EventDate_TerritoryCode', TerritoryCode)
    __TerritoryCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1373, 12)
    __TerritoryCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1373, 12)
    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'The ddex:Territory in which the ddex:Event occurred (represented by an ISO 3166-1 iso3166a2:TerritoryCode). This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute LocationDescription uses Python identifier LocationDescription
    __LocationDescription = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LocationDescription'), 'LocationDescription', '__httpddex_netxml20120214ddexC_EventDate_LocationDescription', pyxb.binding.datatypes.string)
    __LocationDescription._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1378, 12)
    __LocationDescription._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1378, 12)
    
    LocationDescription = property(__LocationDescription.value, __LocationDescription.set, None, 'A ddex:Description of the location in which the ddex:Event occurred. It offers the opportunity to describe a place more precisely than using the iso3166a2:TerritoryCode. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_EventDate_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1383, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1383, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:LocationDescription as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __IsApproximate.name() : __IsApproximate,
        __IsBefore.name() : __IsBefore,
        __IsAfter.name() : __IsAfter,
        __TerritoryCode.name() : __TerritoryCode,
        __LocationDescription.name() : __LocationDescription,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'EventDate', EventDate)


# Complex type {http://ddex.net/xml/20120214/ddexC}EventDateTime with content type SIMPLE
class EventDateTime (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of the ddex:DateTime and ddex:Place of an ddex:Event."""
    _TypeDefinition = pyxb.binding.datatypes.dateTime
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'EventDateTime')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1391, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.dateTime
    
    # Attribute IsApproximate uses Python identifier IsApproximate
    __IsApproximate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsApproximate'), 'IsApproximate', '__httpddex_netxml20120214ddexC_EventDateTime_IsApproximate', pyxb.binding.datatypes.boolean)
    __IsApproximate._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1397, 12)
    __IsApproximate._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1397, 12)
    
    IsApproximate = property(__IsApproximate.value, __IsApproximate.set, None, 'The ddex:Flag indicating whether the reported ddex:DateTime is approximate (=True) or exact (=False). This is represented in an XML schema as an XML ddex:Attribute. ')

    
    # Attribute IsBefore uses Python identifier IsBefore
    __IsBefore = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsBefore'), 'IsBefore', '__httpddex_netxml20120214ddexC_EventDateTime_IsBefore', pyxb.binding.datatypes.boolean)
    __IsBefore._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1402, 12)
    __IsBefore._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1402, 12)
    
    IsBefore = property(__IsBefore.value, __IsBefore.set, None, 'The ddex:Flag indicating whether the ddex:Event being described occurred sometime before the reported ddex:DateTime (=True) or not (=False). This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute IsAfter uses Python identifier IsAfter
    __IsAfter = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'IsAfter'), 'IsAfter', '__httpddex_netxml20120214ddexC_EventDateTime_IsAfter', pyxb.binding.datatypes.boolean)
    __IsAfter._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1407, 12)
    __IsAfter._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1407, 12)
    
    IsAfter = property(__IsAfter.value, __IsAfter.set, None, 'The ddex:Flag indicating whether the ddex:Event being described occurred sometime after the reported ddex:DateTime (=True) or not (=False). This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_EventDateTime_TerritoryCode', TerritoryCode)
    __TerritoryCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1412, 12)
    __TerritoryCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1412, 12)
    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'The ddex:Territory in which the ddex:Event occurred (represented by an ISO 3166-1 iso3166a2:TerritoryCode). This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute LocationDescription uses Python identifier LocationDescription
    __LocationDescription = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LocationDescription'), 'LocationDescription', '__httpddex_netxml20120214ddexC_EventDateTime_LocationDescription', pyxb.binding.datatypes.string)
    __LocationDescription._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1417, 12)
    __LocationDescription._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1417, 12)
    
    LocationDescription = property(__LocationDescription.value, __LocationDescription.set, None, 'A ddex:Description of the location in which the ddex:Event occurred. It offers the opportunity to describe a place more precisely than using the iso3166a2:TerritoryCode. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute LanguageAndScriptCode uses Python identifier LanguageAndScriptCode
    __LanguageAndScriptCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LanguageAndScriptCode'), 'LanguageAndScriptCode', '__httpddex_netxml20120214ddexC_EventDateTime_LanguageAndScriptCode', pyxb.binding.datatypes.string)
    __LanguageAndScriptCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1422, 12)
    __LanguageAndScriptCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1422, 12)
    
    LanguageAndScriptCode = property(__LanguageAndScriptCode.value, __LanguageAndScriptCode.set, None, 'The ddex:Language and script for the ddex:LocationDescription as defined in IETF RfC 4646. The default is the same as indicated for the containing composite. ddex:Language and Script are provided as lang[-scipt][-region][-variant].  This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __IsApproximate.name() : __IsApproximate,
        __IsBefore.name() : __IsBefore,
        __IsAfter.name() : __IsAfter,
        __TerritoryCode.name() : __TerritoryCode,
        __LocationDescription.name() : __LocationDescription,
        __LanguageAndScriptCode.name() : __LanguageAndScriptCode
    })
Namespace.addCategoryObject('typeBinding', 'EventDateTime', EventDateTime)


# Complex type {http://ddex.net/xml/20120214/ddexC}GuaranteedAmount with content type SIMPLE
class GuaranteedAmount (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:GuaranteedAmount."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'GuaranteedAmount')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1664, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20120214ddexC_GuaranteedAmount_CurrencyCode', CurrencyCode, required=True)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1670, 12)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1670, 12)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The ddex:Currency of the ddexC:GuaranteedAmount (represented by an ISO 4217 iso4217a:CurrencyCode). This is represented in an XML schema as an XML ddex:Attribute. ')

    
    # Attribute ReferenceUnit uses Python identifier ReferenceUnit
    __ReferenceUnit = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ReferenceUnit'), 'ReferenceUnit', '__httpddex_netxml20120214ddexC_GuaranteedAmount_ReferenceUnit', _ImportedBinding__ddex.ReferenceUnit, required=True)
    __ReferenceUnit._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1675, 12)
    __ReferenceUnit._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1675, 12)
    
    ReferenceUnit = property(__ReferenceUnit.value, __ReferenceUnit.set, None, 'A unit to which the ddexC:GuaranteedAmount refers (per ddex:Use or for the whole ddex:License).')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode,
        __ReferenceUnit.name() : __ReferenceUnit
    })
Namespace.addCategoryObject('typeBinding', 'GuaranteedAmount', GuaranteedAmount)


# Complex type {http://ddex.net/xml/20120214/ddexC}Price with content type SIMPLE
class Price (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Price."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Price')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2803, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20120214ddexC_Price_CurrencyCode', CurrencyCode, required=True)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2809, 12)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2809, 12)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The ddex:Currency of the ddexC:Price (represented by an ISO 4217 iso4217a:CurrencyCode). This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode
    })
Namespace.addCategoryObject('typeBinding', 'Price', Price)


# Complex type {http://ddex.net/xml/20120214/ddexC}PriceConsumerPaidExcSalesTax with content type SIMPLE
class PriceConsumerPaidExcSalesTax (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:PriceConsumerPaidExcSalesTax."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'PriceConsumerPaidExcSalesTax')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2817, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20120214ddexC_PriceConsumerPaidExcSalesTax_CurrencyCode', CurrencyCode)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2823, 12)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2823, 12)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The ddex:Currency of the ddex:Price (represented by an ISO 4217 iso4217a:CurrencyCode). This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode
    })
Namespace.addCategoryObject('typeBinding', 'PriceConsumerPaidExcSalesTax', PriceConsumerPaidExcSalesTax)


# Complex type {http://ddex.net/xml/20120214/ddexC}RightsType with content type SIMPLE
class RightsType (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a RightsType."""
    _TypeDefinition = _ImportedBinding__ddex.RightsCoverage
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RightsType')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4012, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is _ImportedBinding__ddex.RightsCoverage
    
    # Attribute TerritoryCode uses Python identifier TerritoryCode
    __TerritoryCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), 'TerritoryCode', '__httpddex_netxml20120214ddexC_RightsType_TerritoryCode', TerritoryCode, required=True)
    __TerritoryCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4018, 12)
    __TerritoryCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4018, 12)
    
    TerritoryCode = property(__TerritoryCode.value, __TerritoryCode.set, None, 'A ddex:Territory to which the ddexC:RightsType applies (represented by an ISO 3166-1 iso3166a2:TerritoryCode). The ddexC:RightsType is defined according to the jurisdiction of this ddex:Territory.')

    
    # Attribute Namespace uses Python identifier Namespace_
    __Namespace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Namespace'), 'Namespace_', '__httpddex_netxml20120214ddexC_RightsType_Namespace', pyxb.binding.datatypes.string)
    __Namespace._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4023, 12)
    __Namespace._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4023, 12)
    
    Namespace_ = property(__Namespace.value, __Namespace.set, None, 'The ddex:Namespace of the ddexC:RightsType. This is represented in an XML schema as an XML ddex:Attribute.')

    
    # Attribute UserDefinedValue uses Python identifier UserDefinedValue
    __UserDefinedValue = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), 'UserDefinedValue', '__httpddex_netxml20120214ddexC_RightsType_UserDefinedValue', pyxb.binding.datatypes.string)
    __UserDefinedValue._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4028, 12)
    __UserDefinedValue._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4028, 12)
    
    UserDefinedValue = property(__UserDefinedValue.value, __UserDefinedValue.set, None, 'A ddex:UserDefined value of the ddexC:RightsType. This is represented in an XML schema as an XML ddex:Attribute.')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __TerritoryCode.name() : __TerritoryCode,
        __Namespace.name() : __Namespace,
        __UserDefinedValue.name() : __UserDefinedValue
    })
Namespace.addCategoryObject('typeBinding', 'RightsType', RightsType)


# Complex type {http://ddex.net/xml/20120214/ddexC}RoyaltyAmount with content type SIMPLE
class RoyaltyAmount (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:RoyaltyAmount."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'RoyaltyAmount')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4036, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20120214ddexC_RoyaltyAmount_CurrencyCode', CurrencyCode, required=True)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4042, 12)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4042, 12)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The ddex:Currency of the ddexC:RoyaltyAmount (represented by an ISO 4217 iso4217a:CurrencyCode). This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode
    })
Namespace.addCategoryObject('typeBinding', 'RoyaltyAmount', RoyaltyAmount)


# Complex type {http://ddex.net/xml/20120214/ddexC}Tax with content type SIMPLE
class Tax (pyxb.binding.basis.complexTypeDefinition):
    """A ddex:Composite containing details of a ddex:Tax."""
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'Tax')
    _XSDLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4626, 3)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute CurrencyCode uses Python identifier CurrencyCode
    __CurrencyCode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'CurrencyCode'), 'CurrencyCode', '__httpddex_netxml20120214ddexC_Tax_CurrencyCode', CurrencyCode, required=True)
    __CurrencyCode._DeclarationLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4632, 12)
    __CurrencyCode._UseLocation = pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4632, 12)
    
    CurrencyCode = property(__CurrencyCode.value, __CurrencyCode.set, None, 'The ddex:Currency of the ddexC:Tax (represented by an ISO 4217 iso4217a:CurrencyCode). This is represented in an XML schema as an XML ddex:Attribute. ')

    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __CurrencyCode.name() : __CurrencyCode
    })
Namespace.addCategoryObject('typeBinding', 'Tax', Tax)




AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Amount'), pyxb.binding.datatypes.decimal, scope=AmountByUseAndDistributionChannelType, documentation='The ddex:Amount specified for the ddex:UseType and the ddex:DistributionChannelType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 76, 9)))

AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=AmountByUseAndDistributionChannelType, documentation='A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 81, 9)))

AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=AmountByUseAndDistributionChannelType, documentation='A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 86, 9)))

AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=AmountByUseAndDistributionChannelType, documentation='A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 92, 9)))

AmountByUseAndDistributionChannelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=AmountByUseAndDistributionChannelType, documentation='A ddex:Composite containing details of a ddex:Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 98, 9)))

def _BuildAutomaton ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton
    del _BuildAutomaton
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 86, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 92, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 98, 9))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'Amount')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 76, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 81, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 86, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 92, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(AmountByUseAndDistributionChannelType._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 98, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AmountByUseAndDistributionChannelType._Automaton = _BuildAutomaton()




AmountPerCollection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Amount'), pyxb.binding.datatypes.decimal, scope=AmountPerCollection, documentation='The ddex:Amount specified for the ddex:CollectionType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 110, 9)))

AmountPerCollection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionType'), CollectionType, scope=AmountPerCollection, documentation='A ddex:Composite containing details of the ddex:Type of the ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 115, 9)))

def _BuildAutomaton_ ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_
    del _BuildAutomaton_
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AmountPerCollection._UseForTag(pyxb.namespace.ExpandedName(None, 'Amount')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 110, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AmountPerCollection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 115, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AmountPerCollection._Automaton = _BuildAutomaton_()




Artist._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=Artist, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 171, 12)))

Artist._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=Artist, documentation='A ddex:Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 177, 15)))

Artist._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ArtistRole'), ArtistRole, scope=Artist, documentation='A ddex:Composite containing details of a role played by the ddexC:Artist in relation to other ddex:Artists.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 189, 9)))

def _BuildAutomaton_2 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_2
    del _BuildAutomaton_2
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 182, 15))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 189, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Artist._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 171, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Artist._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 177, 15))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Artist._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 182, 15))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Artist._UseForTag(pyxb.namespace.ExpandedName(None, 'ArtistRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 189, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Artist._Automaton = _BuildAutomaton_2()




AvRating._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RatingText'), pyxb.binding.datatypes.string, scope=AvRating, documentation='The text of the ddexC:AvRating.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 249, 9)))

AvRating._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RatingAgency'), RatingAgency, scope=AvRating, documentation='A Composite containing details of an Organization that issues the ddexC:AvRating.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 254, 9)))

def _BuildAutomaton_3 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_3
    del _BuildAutomaton_3
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AvRating._UseForTag(pyxb.namespace.ExpandedName(None, 'RatingText')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 249, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AvRating._UseForTag(pyxb.namespace.ExpandedName(None, 'RatingAgency')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 254, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AvRating._Automaton = _BuildAutomaton_3()




CLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Year'), pyxb.binding.datatypes.gYear, scope=CLine, documentation='The ddex:Year of the ddexC:CLine.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 280, 9)))

CLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLineCompany'), pyxb.binding.datatypes.string, scope=CLine, documentation='The ddex:Name of the company releasing the ddex:Creation. This may be an owner or a licensee of the ddex:Creation.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 285, 9)))

CLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLineText'), pyxb.binding.datatypes.string, scope=CLine, documentation='The text of the ddexC:CLine. (Note: DDEX expects to deprecate the use of the CLineText element in a subsequent version of this standard. It will be deprecated once users of the standard are able to provide CLine information in a structured form.)', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 290, 9)))

def _BuildAutomaton_4 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_4
    del _BuildAutomaton_4
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 280, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 285, 9))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CLine._UseForTag(pyxb.namespace.ExpandedName(None, 'Year')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 280, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CLine._UseForTag(pyxb.namespace.ExpandedName(None, 'CLineCompany')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 285, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CLine._UseForTag(pyxb.namespace.ExpandedName(None, 'CLineText')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 290, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CLine._Automaton = _BuildAutomaton_4()




Character._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=Character, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 374, 12)))

Character._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=Character, documentation='A ddex:Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 380, 15)))

Character._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=Character, documentation='A ddex:Composite containing details of the ddex:Name, ddex:Identifier and role(s) of a ddex:Contributor.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 392, 9)))

def _BuildAutomaton_5 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_5
    del _BuildAutomaton_5
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 385, 15))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 392, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Character._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 374, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Character._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 380, 15))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Character._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 385, 15))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Character._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 392, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Character._Automaton = _BuildAutomaton_5()




Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionId'), CollectionId, scope=Collection, documentation='A ddex:Composite containing details of an ddex:Identifier of the ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 409, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionType'), CollectionType, scope=Collection, documentation='A ddex:Composite containing details of the ddex:Type of the ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 414, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionReference'), STD_ANON, scope=Collection, documentation='The ddex:Identifier (specific to the ddex:Message) of the ddex:Collection within the ddex:Release which contains it. This is a ddex:LocalCollectionAnchor starting with the letter X.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 420, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=Collection, documentation='A ddex:Composite containing details of a ddex:Title of the ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 430, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Contributor'), ResourceContributor, scope=Collection, documentation='A ddex:Composite containing details a ddex:Contributor to the ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 435, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReferenceList'), CollectionCollectionReferenceList, scope=Collection, documentation='A ddex:Composite containing a list of ddex:CollectionCollectionReferences for a ddex:Collection (specific to this ddex:Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 441, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsComplete'), pyxb.binding.datatypes.boolean, scope=Collection, documentation='The ddex:Flag indicating whether the ddex:Collection is complete (=True) or not (=False). Only one of the Elements ddex:IsComplete here and in the ddexC:CollectionDetailsByTerritory is valid for a given ddexC:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 447, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DurationOfMusicalContent'), pyxb.binding.datatypes.duration, scope=Collection, documentation='The ddex:Duration of the musical content (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 452, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CreationDate'), EventDate, scope=Collection, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Collection was created.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 457, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate'), EventDate, scope=Collection, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Collection was or will be first made available for Usage, whether for physical or electronic/online distribution (in ISO 8601:2004 format: YYYY-MM-DD).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 462, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalLanguage'), _ImportedBinding__iso639a2.LanguageCode, scope=Collection, documentation='The orignal ddex:Language of the ddex:Collection (represented by an ISO 639-2 iso639a2:LanguageCode).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 467, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionDetailsByTerritory'), CollectionDetailsByTerritory, scope=Collection, documentation='A ddex:Composite containing details of ddex:Descriptors and other attributes of the ddex:Collection which may vary according to ddex:Territory of release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 472, 9)))

Collection._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionResourceReferenceList'), CollectionResourceReferenceList, scope=Collection, documentation='A ddex:Composite containing a list of ddex:CollectionResourceReferences for a ddex:Resource (specific to this ddex:Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 478, 9)))

def _BuildAutomaton_6 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_6
    del _BuildAutomaton_6
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 414, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 430, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 435, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 441, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 452, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 457, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 462, 9))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 467, 9))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 472, 9))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 478, 9))
    counters.add(cc_9)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 409, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 414, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 420, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 430, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'Contributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 435, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 441, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'IsComplete')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 447, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'DurationOfMusicalContent')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 452, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CreationDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 457, 9))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 462, 9))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalLanguage')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 467, 9))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 472, 9))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(Collection._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionResourceReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 478, 9))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, True) ]))
    st_12._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Collection._Automaton = _BuildAutomaton_6()




CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), pyxb.binding.datatypes.integer, scope=CollectionCollectionReference, documentation='The number indicating the order of the ddex:Collection in a group of ddex:Collections within a ddex:Medley, ddex:SoundRecording or other ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 496, 9)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference'), STD_ANON_, scope=CollectionCollectionReference, documentation='A ddex:Reference for a ddex:Collection (specific to this ddex:Message). This is a ddex:LocalCollectionAnchorReference starting with the letter X. The referenced ddex:Collection has to be of ddex:CollectionType ddex:Series, ddex:Season or ddex:Episode.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 501, 9)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartTime'), pyxb.binding.datatypes.duration, scope=CollectionCollectionReference, documentation='The start time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 511, 9)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=CollectionCollectionReference, documentation='The ddex:Duration of the use of the ddex:Creation that is referenced in the ddex:CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 516, 9)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndTime'), pyxb.binding.datatypes.duration, scope=CollectionCollectionReference, documentation='The end time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 521, 9)))

CollectionCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'InclusionDate'), pyxb.binding.datatypes.dateTime, scope=CollectionCollectionReference, documentation='A Date on which the ddex:Collection or ddex:Resource was included in the parent ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 526, 9)))

def _BuildAutomaton_7 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_7
    del _BuildAutomaton_7
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 496, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 511, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 516, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 521, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 526, 9))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'SequenceNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 496, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 501, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'StartTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 511, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 516, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'EndTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 521, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'InclusionDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 526, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CollectionCollectionReference._Automaton = _BuildAutomaton_7()




CollectionCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), pyxb.binding.datatypes.integer, scope=CollectionCollectionReferenceList, documentation='The number of referenced ddexC:Collections (typically Chapters).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 538, 9)))

CollectionCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference'), CollectionCollectionReference, scope=CollectionCollectionReferenceList, documentation='A ddex:Composite containing a ddex:CollectionCollectionReference for a ddex:Collection (specific to this ddex:Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 543, 9)))

def _BuildAutomaton_8 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_8
    del _BuildAutomaton_8
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 538, 9))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'NumberOfCollections')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 538, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 543, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CollectionCollectionReferenceList._Automaton = _BuildAutomaton_8()




CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=CollectionDetailsByTerritory, documentation='A ddex:Territory to which the ddex:Collection details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 557, 12)))

CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=CollectionDetailsByTerritory, documentation='A ddex:Territory to which the ddex:Collection details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 562, 12)))

CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=CollectionDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Title of the ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 568, 9)))

CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Contributor'), ResourceContributor, scope=CollectionDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Contributor to the ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 573, 9)))

CollectionDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsComplete'), pyxb.binding.datatypes.boolean, scope=CollectionDetailsByTerritory, documentation='The ddex:Flag indicating whether the ddex:Collection is complete (=True) or not (=False). Only one of the Elements ddex:IsComplete here and in the Collection is valid for a given Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 579, 9)))

def _BuildAutomaton_9 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_9
    del _BuildAutomaton_9
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 568, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 573, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 579, 9))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 557, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 562, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 568, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Contributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 573, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CollectionDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IsComplete')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 579, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CollectionDetailsByTerritory._Automaton = _BuildAutomaton_9()




CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'GRid'), pyxb.binding.datatypes.string, scope=CollectionId, documentation="The ddex:GRid identifying the ddex:Collection. This is the preferred ddex:Element and is mandatory if a ddex:GRid is available. A ddex:GRid comprises four parts: the xs:string 'A1', followed by five alphanumeric characters, ten alphanumeric characters and and one alphanumeric character.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 591, 9)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=CollectionId, documentation='The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:Collection. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 596, 9)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISAN'), pyxb.binding.datatypes.string, scope=CollectionId, documentation='The ddex:ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the ddex:Collection. An ddex:ISAN comprises four blocks of four hexadecimal charaters followed by a check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 601, 9)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VISAN'), pyxb.binding.datatypes.string, scope=CollectionId, documentation='The V-ISAN (Version ddex:Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the ddex:Collection. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 606, 9)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ICPN'), ICPN, scope=CollectionId, documentation='A ddex:Composite containing details of the ddex:ICPN used as proxy for identification of the ddex:Collection. Only applicable when the ddex:Collection is an abstraction of a complete ddex:PhysicalProduct. An ddex:ICPN comprises 12 or 13 digits, depending whether it is an ddex:EAN (13) or a ddex:UPC (12).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 611, 9)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=CollectionId, documentation='A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 616, 9)))

CollectionId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=CollectionId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Collection (usually one per society involved in the messaging).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 621, 9)))

def _BuildAutomaton_10 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_10
    del _BuildAutomaton_10
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 591, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 596, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 601, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 606, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 611, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 616, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 621, 9))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'GRid')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 591, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 596, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 601, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'VISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 606, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'ICPN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 611, 9))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 616, 9))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CollectionId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 621, 9))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CollectionId._Automaton = _BuildAutomaton_10()




CollectionList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Collection'), Collection, scope=CollectionList, documentation='A ddex:Composite containing details of a ddex:Collection contained in a ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 639, 9)))

def _BuildAutomaton_11 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_11
    del _BuildAutomaton_11
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionList._UseForTag(pyxb.namespace.ExpandedName(None, 'Collection')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 639, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CollectionList._Automaton = _BuildAutomaton_11()




CollectionResourceReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CollectionResourceReference'), STD_ANON_2, scope=CollectionResourceReferenceList, documentation='A ddex:Reference for a ddex:Resource (specific to this ddex:Message). This is a ddex:LocalResourceAnchorReference starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 656, 9)))

def _BuildAutomaton_12 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_12
    del _BuildAutomaton_12
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CollectionResourceReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'CollectionResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 656, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CollectionResourceReferenceList._Automaton = _BuildAutomaton_12()




CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISWC'), pyxb.binding.datatypes.string, scope=CreationId, documentation="The ddex:ISWC (International Standard Musical ddex:Work Code defined in ISO 15707) identifying the ddex:MusicalWork. An ddex:ISWC comprises three parts: the letter 'T', followed by nine digits and then one check digit.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 772, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OpusNumber'), pyxb.binding.datatypes.string, scope=CreationId, documentation='The ddexC:MusicalWorkId identifying the ddex:MusicalWork within the catalog of its ddex:Composer (typically of classical music) as an opus number.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 777, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ComposerCatalogNumber'), pyxb.binding.datatypes.string, scope=CreationId, documentation="A ddexC:MusicalWorkId identifying a ddex:MusicalWork within the catalog of its ddex:Composer (typically of classical music) according to a standardized numbering (e.g. 'K' numbers for Koechel's catalog of Mozart).", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 782, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=CreationId, documentation='The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:Resource. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 788, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISMN'), pyxb.binding.datatypes.string, scope=CreationId, documentation="The ddex:ISMN (International Standard Music Number defined in ISO 10957) for the ddex:Resource. An ddex:ISMN is a thirteen-digit number. Pre-2008 ddex:ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ('M') with '979-0'.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 793, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISAN'), pyxb.binding.datatypes.string, scope=CreationId, documentation='The ddex:ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the ddex:Resource. An ddex:ISAN comprises four blocks of four hexadecimal charaters followed by a check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 798, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VISAN'), pyxb.binding.datatypes.string, scope=CreationId, documentation='The V-ISAN (Version ddex:Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the ddex:Resource. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 803, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISBN'), pyxb.binding.datatypes.string, scope=CreationId, documentation="The ddex:ISBN (International Standard Book Number defined in ISO 2108) for the ddex:Resource. An ddex:ISBN is a 13-digit number. Pre-2007, ddex:ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix '978' and re-calculating the check character.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 808, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISSN'), pyxb.binding.datatypes.string, scope=CreationId, documentation='The ddex:ISSN (International Standard Serial Number defined in ISO 3297) for the ddex:Resource. An ddex:ISSN comprises two groups of four digits, separated by a hyphen and a control digit.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 813, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SICI'), pyxb.binding.datatypes.string, scope=CreationId, documentation='The ddex:SICI (Serial Item and Contribution ddex:Identifier defined in ANSI/NISO Z39.56-199)  for the ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 818, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=CreationId, documentation='A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 823, 9)))

CreationId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=CreationId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Creation.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 828, 9)))

def _BuildAutomaton_13 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_13
    del _BuildAutomaton_13
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 772, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 777, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 782, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 788, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 793, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 798, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 803, 9))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 808, 9))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 813, 9))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 818, 9))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 823, 9))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 828, 9))
    counters.add(cc_11)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISWC')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 772, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'OpusNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 777, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'ComposerCatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 782, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 788, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISMN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 793, 9))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 798, 9))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'VISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 803, 9))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISBN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 808, 9))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISSN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 813, 9))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'SICI')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 818, 9))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 823, 9))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(CreationId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 828, 9))
    st_11 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_11, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CreationId._Automaton = _BuildAutomaton_13()




Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueUseType'), CueUseType, scope=Cue, documentation='A ddex:Composite containing details of a ddex:UseType of the ddexC:Cue. It can be expected that this element will be contractually mandatory in many communications of cue sheets to music rights societies.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 841, 9)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueThemeType'), CueThemeType, scope=Cue, documentation='A ddex:Composite containing details of a ddex:ThemeType for the ddex:Creation referenced in the ddexC:Cue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 846, 9)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueVocalType'), CueVocalType, scope=Cue, documentation='A ddex:Composite containing details of a ddex:VocalType for the ddex:Creation referenced in the ddexC:Cue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 851, 9)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsDance'), pyxb.binding.datatypes.boolean, scope=Cue, documentation='A ddex:Flag indicating whether a ddex:Creation contains dancing (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 856, 9)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueVisualPerceptionType'), CueVisualPerceptionType, scope=Cue, documentation='A ddex:Composite containing details of a ddex:VisualPerceptionType for the ddex:Creation referenced in the ddexC:Cue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 861, 9)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueOrigin'), CueOrigin, scope=Cue, documentation='A ddex:Composite containing details of a ddex:CueOrigin for the ddexC:Cue. It can be expected that this element will be contractually mandatory in many communications of cue sheets to music rights societies.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 867, 9)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueCreationReference'), CueCreationReference, scope=Cue, documentation='A ddex:Composite containing a ddex:CueCreationReference for a ddex:Creation (specific to this ddex:Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 873, 12)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferencedCreationType'), _ImportedBinding__ddex.CreationType, scope=Cue, documentation='A ddex:Type of the ddex:Creation referenced in the ddexC:Cue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 880, 15)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferencedCreationId'), CreationId, scope=Cue, documentation='A ddex:Composite containing details of a ddex:CreationIds.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 885, 15)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferencedCreationTitle'), Title, scope=Cue, documentation='A ddex:Composite containing details of a ddex:Title of the ddex:Creation referenced in the ddexC:Cue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 890, 15)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferencedCreationContributor'), ResourceContributor, scope=Cue, documentation='A ddex:Composite containing details a ddex:Contributor of the ddex:Creation referenced in the ddexC:Cue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 896, 15)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HasMusicalContent'), pyxb.binding.datatypes.boolean, scope=Cue, documentation='A ddex:Flag indicating whether whether the ddex:Creation referenced in the ddexC:Cue contains musical content such as a ddex:SoundRecording or a ddex:MusicalWork (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 904, 9)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartTime'), pyxb.binding.datatypes.duration, scope=Cue, documentation='The start time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 909, 9)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=Cue, documentation='The ddex:Duration of the use of the ddex:Creation that is referenced in the ddex:CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 914, 9)))

Cue._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndTime'), pyxb.binding.datatypes.duration, scope=Cue, documentation='The end time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 919, 9)))

def _BuildAutomaton_14 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_14
    del _BuildAutomaton_14
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 841, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 846, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 851, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 856, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 861, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 867, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 880, 15))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 885, 15))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 890, 15))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 896, 15))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 904, 9))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 909, 9))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 914, 9))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 919, 9))
    counters.add(cc_13)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'CueUseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 841, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'CueThemeType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 846, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'CueVocalType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 851, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'IsDance')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 856, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'CueVisualPerceptionType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 861, 9))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'CueOrigin')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 867, 9))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'CueCreationReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 873, 12))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferencedCreationType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 880, 15))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferencedCreationId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 885, 15))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferencedCreationTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 890, 15))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferencedCreationContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 896, 15))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'HasMusicalContent')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 904, 9))
    st_11 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'StartTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 909, 9))
    st_12 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 914, 9))
    st_13 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(Cue._UseForTag(pyxb.namespace.ExpandedName(None, 'EndTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 919, 9))
    st_14 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_13, True) ]))
    st_14._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Cue._Automaton = _BuildAutomaton_14()




CueCreationReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueWorkReference'), STD_ANON_3, scope=CueCreationReference, documentation='A ddex:Reference for a ddex:Work (specific to this ddex:Message). This is a ddex:LocalMusicalWorkAnchorReference starting with the letter W.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 932, 12)))

CueCreationReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueResourceReference'), STD_ANON_4, scope=CueCreationReference, documentation='A ddex:Reference for a ddex:Resource (specific to this ddex:Message). This is a ddex:LocalResourceAnchorReference starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 942, 12)))

def _BuildAutomaton_15 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_15
    del _BuildAutomaton_15
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CueCreationReference._UseForTag(pyxb.namespace.ExpandedName(None, 'CueWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 932, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CueCreationReference._UseForTag(pyxb.namespace.ExpandedName(None, 'CueResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 942, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CueCreationReference._Automaton = _BuildAutomaton_15()




CueSheet._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueSheetId'), ProprietaryId, scope=CueSheet, documentation='A ddex:Composite containing details of a ddex:CueSheetId of the ddexC:CueSheet.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 979, 9)))

CueSheet._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueSheetReference'), STD_ANON_5, scope=CueSheet, documentation='The ddex:Identifier (specific to the ddex:Message) of the ddexC:CueSheet within the ddex:Release which contains it. This is a ddex:LocalCueSheetAnchor starting with the letter Q.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 985, 9)))

CueSheet._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueSheetType'), CueSheetType, scope=CueSheet, documentation='A ddex:Composite containing details of a ddex:Type of the ddexC:CueSheet.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 995, 9)))

CueSheet._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Cue'), Cue, scope=CueSheet, documentation='A ddex:Composite containing details of a ddex:Cue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1000, 9)))

def _BuildAutomaton_16 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_16
    del _BuildAutomaton_16
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 979, 9))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CueSheet._UseForTag(pyxb.namespace.ExpandedName(None, 'CueSheetId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 979, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CueSheet._UseForTag(pyxb.namespace.ExpandedName(None, 'CueSheetReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 985, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CueSheet._UseForTag(pyxb.namespace.ExpandedName(None, 'CueSheetType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 995, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CueSheet._UseForTag(pyxb.namespace.ExpandedName(None, 'Cue')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1000, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CueSheet._Automaton = _BuildAutomaton_16()




CueSheetList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CueSheet'), CueSheet, scope=CueSheetList, documentation='A ddex:Composite containing details of a ddex:CueSheet contained in a ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1012, 9)))

def _BuildAutomaton_17 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_17
    del _BuildAutomaton_17
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CueSheetList._UseForTag(pyxb.namespace.ExpandedName(None, 'CueSheet')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1012, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CueSheetList._Automaton = _BuildAutomaton_17()




DSP._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=DSP, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1120, 12)))

DSP._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=DSP, documentation='A ddex:Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1126, 15)))

DSP._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TradingName'), Name, scope=DSP, documentation='A ddex:Composite containing a ddex:TradingName of the ddexC:DSP.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1138, 9)))

DSP._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'URL'), pyxb.binding.datatypes.string, scope=DSP, documentation="A ddex:URL for the DSP's web site.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1143, 9)))

DSP._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=DSP, documentation='The ddex:Territory from which the ddexC:DSP operates (represented by an ISO 3166-1 iso3166a2:TerritoryCode). This ddex:Territory may differ from the one in which ddex:SalesTransactions occur.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1148, 9)))

def _BuildAutomaton_18 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_18
    del _BuildAutomaton_18
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1131, 15))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1138, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1143, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1148, 9))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1120, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1126, 15))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1131, 15))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'TradingName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1138, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'URL')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1143, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(DSP._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1148, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
DSP._Automaton = _BuildAutomaton_18()




DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=DurationByUseType, documentation='The ddex:Duration specified for the ddex:UseType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1274, 9)))

DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=DurationByUseType, documentation='A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1279, 9)))

DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=DurationByUseType, documentation='A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1284, 9)))

DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=DurationByUseType, documentation='A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1290, 9)))

DurationByUseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=DurationByUseType, documentation='A ddex:Composite containing details of a ddex:Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1296, 9)))

def _BuildAutomaton_19 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_19
    del _BuildAutomaton_19
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1284, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1290, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1296, 9))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1274, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1279, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1284, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1290, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(DurationByUseType._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1296, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
DurationByUseType._Automaton = _BuildAutomaton_19()




ErnMessageInBatch._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageType'), _ImportedBinding__ddex.ErnMessageType, scope=ErnMessageInBatch, documentation='The ddex:Type of ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1308, 9)))

ErnMessageInBatch._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageId'), pyxb.binding.datatypes.string, scope=ErnMessageInBatch, documentation='An ddex:Identifier of the ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1313, 9)))

ErnMessageInBatch._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'URL'), pyxb.binding.datatypes.string, scope=ErnMessageInBatch, documentation='A ddex:URL of the ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1318, 9)))

ErnMessageInBatch._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IncludedReleaseId'), ReleaseId, scope=ErnMessageInBatch, documentation='A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid should always be used.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1323, 9)))

ErnMessageInBatch._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DeliveryType'), MessageActionType, scope=ErnMessageInBatch, documentation='A ddex:Composite containing details of the ddex:Type of action that the ddex:MessageSender applies to the ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1328, 9)))

ErnMessageInBatch._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProductType'), ProductType, scope=ErnMessageInBatch, documentation='A ddex:Composite containing details of the ddex:Type of a ddex:Product defining which kinds of ddex:Products are within the delivered batch. Each batch may only contain one type of ddex:Products.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1333, 9)))

ErnMessageInBatch._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HashSum'), HashSum, scope=ErnMessageInBatch, documentation='A ddex:Composite containing a ddex:HashSum of the ddexC:File and information about the algorithm with which it has been generated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1339, 12)))

ErnMessageInBatch._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Signature'), pyxb.binding.datatypes.string, scope=ErnMessageInBatch, documentation='A digital signature in accordance with DDEX-DSIG.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1344, 12)))

def _BuildAutomaton_20 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_20
    del _BuildAutomaton_20
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1338, 9))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ErnMessageInBatch._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1308, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ErnMessageInBatch._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1313, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ErnMessageInBatch._UseForTag(pyxb.namespace.ExpandedName(None, 'URL')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1318, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ErnMessageInBatch._UseForTag(pyxb.namespace.ExpandedName(None, 'IncludedReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1323, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ErnMessageInBatch._UseForTag(pyxb.namespace.ExpandedName(None, 'DeliveryType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1328, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ErnMessageInBatch._UseForTag(pyxb.namespace.ExpandedName(None, 'ProductType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1333, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ErnMessageInBatch._UseForTag(pyxb.namespace.ExpandedName(None, 'HashSum')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1339, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ErnMessageInBatch._UseForTag(pyxb.namespace.ExpandedName(None, 'Signature')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1344, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ErnMessageInBatch._Automaton = _BuildAutomaton_20()




ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'URL'), pyxb.binding.datatypes.string, scope=ExternalResourceLink, documentation='A ddex:URL of the linked external ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1463, 9)))

ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ValidityPeriod'), Period, scope=ExternalResourceLink, documentation='A ddex:Composite containing details about the ddex:Period of ddex:Time during which the ddexC:ExternalResourceLink is active.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1468, 9)))

ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExternalLink'), pyxb.binding.datatypes.string, scope=ExternalResourceLink, documentation='The ddex:Identifier which provides a communication link to the related external ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1473, 9)))

ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExternallyLinkedResourceType'), ExternallyLinkedResourceType, scope=ExternalResourceLink, documentation='A ddex:Composite containing details of the ddex:Type of a ddex:Resource pointed to by the ddexC:ExternalResourceLink.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1478, 9)))

ExternalResourceLink._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FileFormat'), pyxb.binding.datatypes.string, scope=ExternalResourceLink, documentation='The ddex:FileFormat of the external ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1484, 9)))

def _BuildAutomaton_21 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_21
    del _BuildAutomaton_21
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1468, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1473, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1478, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1484, 9))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'URL')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1463, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'ValidityPeriod')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1468, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'ExternalLink')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1473, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'ExternallyLinkedResourceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1478, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ExternalResourceLink._UseForTag(pyxb.namespace.ExpandedName(None, 'FileFormat')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1484, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ExternalResourceLink._Automaton = _BuildAutomaton_21()




File._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FileName'), pyxb.binding.datatypes.string, scope=File, documentation='A ddex:Name of the ddexC:File.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1517, 15)))

File._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FilePath'), pyxb.binding.datatypes.string, scope=File, documentation='A location of the ddexC:File.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1522, 15)))

File._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'URL'), pyxb.binding.datatypes.string, scope=File, documentation='A ddex:URL of the ddex:File.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1528, 12)))

File._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HashSum'), HashSum, scope=File, documentation='A ddex:Composite containing a ddex:HashSum of the ddexC:File and information about the algorithm with which it has been generated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1534, 9)))

def _BuildAutomaton_22 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_22
    del _BuildAutomaton_22
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1522, 15))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1534, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(File._UseForTag(pyxb.namespace.ExpandedName(None, 'FileName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1517, 15))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(File._UseForTag(pyxb.namespace.ExpandedName(None, 'FilePath')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1522, 15))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(File._UseForTag(pyxb.namespace.ExpandedName(None, 'URL')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1528, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(File._UseForTag(pyxb.namespace.ExpandedName(None, 'HashSum')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1534, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
File._Automaton = _BuildAutomaton_22()




Fingerprint._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Fingerprint'), pyxb.binding.datatypes.string, scope=Fingerprint, documentation='The value of the ddexC:Fingerprint.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1546, 9)))

Fingerprint._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FingerprintAlgorithmType'), FingerprintAlgorithmType, scope=Fingerprint, documentation='A ddex:Composite containing details of the ddex:Type of FingerprintAlgorithm governing the ddexC:Fingerprint.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1551, 9)))

Fingerprint._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FingerprintAlgorithmVersion'), pyxb.binding.datatypes.string, scope=Fingerprint, documentation='The ddex:Identifier of the ddex:Version of the FingerprintAlgorithm.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1556, 9)))

Fingerprint._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FingerprintAlgorithmParameter'), pyxb.binding.datatypes.string, scope=Fingerprint, documentation='A parameter of the FingerprintAlgorithm.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1561, 9)))

def _BuildAutomaton_23 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_23
    del _BuildAutomaton_23
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1556, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1561, 9))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(Fingerprint._UseForTag(pyxb.namespace.ExpandedName(None, 'Fingerprint')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1546, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Fingerprint._UseForTag(pyxb.namespace.ExpandedName(None, 'FingerprintAlgorithmType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1551, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Fingerprint._UseForTag(pyxb.namespace.ExpandedName(None, 'FingerprintAlgorithmVersion')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1556, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Fingerprint._UseForTag(pyxb.namespace.ExpandedName(None, 'FingerprintAlgorithmParameter')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1561, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Fingerprint._Automaton = _BuildAutomaton_23()




FulfillmentDate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FulfillmentDate'), pyxb.binding.datatypes.date, scope=FulfillmentDate, documentation='A Date after which an end user can receive the ddex:Resource (in ISO 8601:2004 format: YYYY-MM-DD). If no ddexC:FulfillmentDate is provided the ddexC:FulfillmentDate is the ddex:StartDate of the respective ddex:Deal. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1606, 9)))

FulfillmentDate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceReleaseReference'), STD_ANON_6, scope=FulfillmentDate, documentation='The ddex:Identifier (specific to the ddex:Message) of a ddex:Release for a ddex:Resource. This is a ddex:LocalReleaseAnchorReference starting with the letter R.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1611, 9)))

def _BuildAutomaton_24 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_24
    del _BuildAutomaton_24
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1611, 9))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(FulfillmentDate._UseForTag(pyxb.namespace.ExpandedName(None, 'FulfillmentDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1606, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(FulfillmentDate._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceReleaseReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1611, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
FulfillmentDate._Automaton = _BuildAutomaton_24()




Genre._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'GenreText'), Description, scope=Genre, documentation='A ddex:Composite containing a ddex:Description of a genre or style (such as Musical, literary or audio-visual) with which a ddex:Creation is associated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1628, 9)))

Genre._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SubGenre'), Description, scope=Genre, documentation='A ddex:Composite containing a ddex:Description of a secondary genre or style with which a ddex:Creation is associated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1633, 9)))

def _BuildAutomaton_25 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_25
    del _BuildAutomaton_25
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1633, 9))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Genre._UseForTag(pyxb.namespace.ExpandedName(None, 'GenreText')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1628, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Genre._UseForTag(pyxb.namespace.ExpandedName(None, 'SubGenre')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1633, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Genre._Automaton = _BuildAutomaton_25()




HashSum._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HashSum'), pyxb.binding.datatypes.string, scope=HashSum, documentation='The value of the ddexC:HashSum.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1688, 9)))

HashSum._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HashSumAlgorithmType'), HashSumAlgorithmType, scope=HashSum, documentation='A ddex:Composite containing details of the ddex:Type of ddex:HashSumAlgorithm governing the ddexC:HashSum.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1693, 9)))

def _BuildAutomaton_26 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_26
    del _BuildAutomaton_26
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(HashSum._UseForTag(pyxb.namespace.ExpandedName(None, 'HashSum')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1688, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(HashSum._UseForTag(pyxb.namespace.ExpandedName(None, 'HashSumAlgorithmType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1693, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
HashSum._Automaton = _BuildAutomaton_26()




HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=HostSoundCarrier, documentation='A ddex:Composite containing details of ddex:ReleaseIds of the ddexC:HostSoundCarrier. If available, a ddex:GRid has to be used. If the ddexC:HostSoundCarrier contains only one ddex:SoundRecording, the ddex:ISRC of the ddex:SoundRecording may be used instead.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1724, 9)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=HostSoundCarrier, documentation='A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddexC:HostSoundCarrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1729, 9)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=HostSoundCarrier, documentation='A ddex:Composite containing details of a ddex:Title of the ddexC:HostSoundCarrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1734, 9)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), Artist, scope=HostSoundCarrier, documentation='A ddex:Composite containing details of the ddex:DisplayArtist for the ddexC:HostSoundCarrier. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1739, 9)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany'), AdministratingRecordCompany, scope=HostSoundCarrier, documentation='A ddex:Composite containing details of the ddex:AdministratingRecordCompany for the Rights in the ddexC:HostSoundCarrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1744, 9)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TrackNumber'), pyxb.binding.datatypes.string, scope=HostSoundCarrier, documentation='The ddex:TrackNumber of the ddex:SoundRecording within the ddexC:HostSoundCarrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1750, 9)))

HostSoundCarrier._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VolumeNumberInSet'), pyxb.binding.datatypes.string, scope=HostSoundCarrier, documentation="The ddex:SequenceNumber within the ddex:Set of the volume containing the ddex:SoundRecording, where the ddexC:HostSoundCarrier is a ddex:Set (such as a 'box set' of CDs).", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1755, 9)))

def _BuildAutomaton_27 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_27
    del _BuildAutomaton_27
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1724, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1729, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1734, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1739, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1744, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1750, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1755, 9))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1724, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1729, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1734, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1739, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1744, 9))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'TrackNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1750, 9))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(HostSoundCarrier._UseForTag(pyxb.namespace.ExpandedName(None, 'VolumeNumberInSet')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1755, 9))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
HostSoundCarrier._Automaton = _BuildAutomaton_27()




ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=ImageDetailsByTerritory, documentation='A ddex:Territory to which the ddex:Image details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1806, 12)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=ImageDetailsByTerritory, documentation='A ddex:Territory to which the ddex:Image details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1811, 12)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=ImageDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Contributor to the ddex:Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1817, 9)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=ImageDetailsByTerritory, documentation='A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1823, 9)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=ImageDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:CLine for the ddex:Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1829, 9)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Description'), Description, scope=ImageDetailsByTerritory, documentation='A ddex:Composite containing a ddex:Description of the subject of the ddex:Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1834, 9)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), CourtesyLine, scope=ImageDetailsByTerritory, documentation='A ddex:Composite containing an ddex:Annotation which acknowledges record companies and/or other Parties giving permission for ddex:Artists or others featured on the ddex:Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1839, 9)))

ImageDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=ImageDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Image was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1844, 9)))

def _BuildAutomaton_28 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_28
    del _BuildAutomaton_28
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1817, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1823, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1829, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1834, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1839, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1844, 9))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1806, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1811, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1817, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1823, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1829, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Description')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1834, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CourtesyLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1839, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(ImageDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1844, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ImageDetailsByTerritory._Automaton = _BuildAutomaton_28()




ImageId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=ImageId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Image.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1861, 9)))

def _BuildAutomaton_29 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_29
    del _BuildAutomaton_29
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ImageId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1861, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ImageId._Automaton = _BuildAutomaton_29()




IndirectResourceContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=IndirectResourceContributor, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1898, 12)))

IndirectResourceContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=IndirectResourceContributor, documentation='A ddex:Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1904, 15)))

IndirectResourceContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributorRole'), MusicalWorkContributorRole, scope=IndirectResourceContributor, documentation='A ddex:Composite containing details of a role played by the indirect ddex:Contributor.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1916, 9)))

def _BuildAutomaton_30 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_30
    del _BuildAutomaton_30
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1909, 15))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1916, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(IndirectResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1898, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(IndirectResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1904, 15))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(IndirectResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1909, 15))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(IndirectResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributorRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 1916, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
IndirectResourceContributor._Automaton = _BuildAutomaton_30()




MessageAuditTrail._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageAuditTrailEvent'), MessageAuditTrailEvent, scope=MessageAuditTrail, documentation='A ddex:Composite containing details of a ddex:Party handling the ddex:Message and the ddex:Time at which the handling took place.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2062, 9)))

def _BuildAutomaton_31 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_31
    del _BuildAutomaton_31
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessageAuditTrail._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageAuditTrailEvent')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2062, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessageAuditTrail._Automaton = _BuildAutomaton_31()




MessageAuditTrailEvent._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessagingPartyDescriptor'), MessagingParty, scope=MessageAuditTrailEvent, documentation='A ddex:Composite containing details of a ddex:MessagingParty.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2080, 9)))

MessageAuditTrailEvent._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DateTime'), pyxb.binding.datatypes.dateTime, scope=MessageAuditTrailEvent, documentation='The ddex:DateTime at which the ddex:Message was handled by the ddex:MessagingParty (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2085, 9)))

def _BuildAutomaton_32 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_32
    del _BuildAutomaton_32
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageAuditTrailEvent._UseForTag(pyxb.namespace.ExpandedName(None, 'MessagingPartyDescriptor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2080, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessageAuditTrailEvent._UseForTag(pyxb.namespace.ExpandedName(None, 'DateTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2085, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessageAuditTrailEvent._Automaton = _BuildAutomaton_32()




MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageThreadId'), pyxb.binding.datatypes.string, scope=MessageHeader, documentation="A xs:string used to uniquely identify the thread of ddex:Messages of which the current ddex:Message is a part. One example of such a 'thread' is the chain of NewReleaseMessages being sent from ddex:ReleaseCreator to wholesale ddex:ReleaseDistributor 1 to retail ddex:DSP when communicating information about the same Release(s). A common ddex:MessageThreadId will allow all these messages to be tied together.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2097, 9)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageId'), pyxb.binding.datatypes.string, scope=MessageHeader, documentation='A xs:string used to uniquely identify the current ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2102, 9)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageFileName'), pyxb.binding.datatypes.string, scope=MessageHeader, documentation='The ddex:FileName, possibly including the ddex:FilePath, of the XML ddex:File containing the current ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2107, 9)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageSender'), MessagingParty, scope=MessageHeader, documentation='A ddex:Composite containing details of the ddex:MessageSender.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2112, 9)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SentOnBehalfOf'), MessagingParty, scope=MessageHeader, documentation='A ddex:Composite containing details of the ddex:Party on whose behalf the ddex:Message is sent.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2117, 9)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageRecipient'), MessagingParty, scope=MessageHeader, documentation='A ddex:Composite containing details of the ddex:MessageRecipient.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2122, 9)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageCreatedDateTime'), pyxb.binding.datatypes.dateTime, scope=MessageHeader, documentation='The ddex:DateTime on which the ddex:Message was created (the only allowed format is ISO 8601:2004: YYYY-MM-DDThh:mm:ssTZD).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2127, 9)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageAuditTrail'), MessageAuditTrail, scope=MessageHeader, documentation='A ddex:Composite containing information about Parties in between the original ddex:MessageSender and ultimate ddex:MessageRecipient.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2132, 9)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Comment'), Comment, scope=MessageHeader, documentation='A ddex:Composite containing a human-readable ddex:Comment about the ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2137, 9)))

MessageHeader._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MessageControlType'), _ImportedBinding__ddex.MessageControlType, scope=MessageHeader, documentation='The indicator used to distinguish a live ddex:Message from a test ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2142, 9)))

def _BuildAutomaton_33 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_33
    del _BuildAutomaton_33
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2107, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2117, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2132, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2137, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2142, 9))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageThreadId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2097, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2102, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageFileName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2107, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageSender')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2112, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'SentOnBehalfOf')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2117, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageRecipient')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2122, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageCreatedDateTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2127, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageAuditTrail')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2132, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'Comment')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2137, 9))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(MessageHeader._UseForTag(pyxb.namespace.ExpandedName(None, 'MessageControlType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2142, 9))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessageHeader._Automaton = _BuildAutomaton_33()




MessageNotificationPeriod._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartDate'), pyxb.binding.datatypes.date, scope=MessageNotificationPeriod, documentation='The Date that marks the beginning of the ddex:Period (in ISO 8601:2004 format: YYYY-MM-DD). This cannot be a Date in the future.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2159, 9)))

MessageNotificationPeriod._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndDate'), pyxb.binding.datatypes.date, scope=MessageNotificationPeriod, documentation='The Date that marks the end of the ddex:Period (in ISO 8601:2004 format: YYYY-MM-DD). This cannot be a Date in the future.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2164, 9)))

def _BuildAutomaton_34 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_34
    del _BuildAutomaton_34
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MessageNotificationPeriod._UseForTag(pyxb.namespace.ExpandedName(None, 'StartDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2159, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessageNotificationPeriod._UseForTag(pyxb.namespace.ExpandedName(None, 'EndDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2164, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessageNotificationPeriod._Automaton = _BuildAutomaton_34()




MessagingParty._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=MessagingParty, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party handling the ddex:Message. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2176, 9)))

MessagingParty._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=MessagingParty, documentation='A ddex:Composite containing details of the ddex:PartyNames for the ddex:Party handling the ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2181, 9)))

MessagingParty._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TradingName'), Name, scope=MessagingParty, documentation='A ddex:Composite containing a ddex:TradingName for the ddex:Party handling the ddex:Message.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2186, 9)))

def _BuildAutomaton_35 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_35
    del _BuildAutomaton_35
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2181, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2186, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MessagingParty._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2176, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MessagingParty._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2181, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MessagingParty._UseForTag(pyxb.namespace.ExpandedName(None, 'TradingName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2186, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MessagingParty._Automaton = _BuildAutomaton_35()




MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=MidiDetailsByTerritory, documentation='A ddex:Territory to which the ddex:MIDI details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2204, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=MidiDetailsByTerritory, documentation='A ddex:Territory to which the ddex:MIDI details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2209, 12)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Title of the ddex:MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2215, 9)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), Artist, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:DisplayArtist for the ddex:MIDI. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2220, 9)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Contributor to the ddex:MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2225, 9)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2231, 9)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2237, 9)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LabelName'), LabelName, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing the ddex:Name of the ddex:Label under which the ddex:Release is to be marketed.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2242, 9)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsController'), RightsController, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing details of ddex:RightsController of Rights in the ddex:MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2247, 9)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), EventDate, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:MIDI was re-mastered (usually digitally).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2253, 9)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:MIDI was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2258, 9)))

MidiDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=MidiDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:CLine for the ddex:MIDI.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2263, 9)))

def _BuildAutomaton_36 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_36
    del _BuildAutomaton_36
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2215, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2220, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2225, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2231, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2237, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2242, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2247, 9))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2253, 9))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2258, 9))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2263, 9))
    counters.add(cc_9)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2204, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2209, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2215, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2220, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2225, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2231, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2237, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2242, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsController')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2247, 9))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RemasteredDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2253, 9))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2258, 9))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(MidiDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2263, 9))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MidiDetailsByTerritory._Automaton = _BuildAutomaton_36()




MidiId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=MidiId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the Midi.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2280, 9)))

def _BuildAutomaton_37 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_37
    del _BuildAutomaton_37
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MidiId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2280, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MidiId._Automaton = _BuildAutomaton_37()




MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkId'), MusicalWorkId, scope=MusicalWork, documentation='A ddex:Composite containing details of a ddex:MusicalWorkId of the ddexC:MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2316, 9)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkReference'), STD_ANON_7, scope=MusicalWork, documentation='The ddex:Identifier (specific to the ddex:Message) of the ddexC:MusicalWork within the ddex:Release which contains it. This is a ddex:LocalMusicalWorkAnchor starting with the letter W.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2321, 9)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=MusicalWork, documentation='A ddex:Composite containing details of a ddex:ReferenceTitle of the ddexC:MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2331, 9)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=MusicalWork, documentation='A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the ddexC:MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2336, 9)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor'), MusicalWorkContributor, scope=MusicalWork, documentation='A ddex:Composite containing details a ddex:MusicalWorkContributor to the ddexC:MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2341, 9)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkType'), MusicalWorkType, scope=MusicalWork, documentation='A ddex:Composite containing details of the ddex:Type of the ddexC:MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2347, 9)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShare'), RightShare, scope=MusicalWork, documentation='A ddex:Composite containing details of a ddex:RightShare for the ddexC:MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2353, 9)))

MusicalWork._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkDetailsByTerritory'), MusicalWorkDetailsByTerritory, scope=MusicalWork, documentation='A ddex:Composite containing details of ddex:Descriptors and other attributes of the ddexC:MusicalWork which may vary according to ddex:Territory of release. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2358, 9)))

def _BuildAutomaton_38 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_38
    del _BuildAutomaton_38
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2336, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2347, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2353, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2358, 9))
    counters.add(cc_3)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2316, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2321, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2331, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2336, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2341, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2347, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShare')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2353, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWork._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2358, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MusicalWork._Automaton = _BuildAutomaton_38()




MusicalWorkContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=MusicalWorkContributor, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2382, 12)))

MusicalWorkContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=MusicalWorkContributor, documentation='A ddex:Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2388, 15)))

MusicalWorkContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributorRole'), MusicalWorkContributorRole, scope=MusicalWorkContributor, documentation="A ddex:Composite containing details of a role played by the ddex:Contributor in relation to the ddex:MusicalWork. Note: This can be used in a ddex:DdexMessage in relation to any ddex:Work, ddex:Performance or ddex:Fixation any of which may form the whole or part of the ddex:Resource itself. Example: if an 'AssociatedPerformer' is shown as a ddex:Contributor to a ddex:MusicalWork it refers to a performer of a ddex:Resource (e.g. a ddex:SoundRecording) expressing the ddex:MusicalWork.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2400, 9)))

MusicalWorkContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SocietyAffiliation'), SocietyAffiliation, scope=MusicalWorkContributor, documentation='A ddex:Composite containing details of a society affiliation for the ddexC:MusicalWorkContributor.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2406, 9)))

def _BuildAutomaton_39 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_39
    del _BuildAutomaton_39
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2393, 15))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2400, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2406, 9))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2382, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2388, 15))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2393, 15))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributorRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2400, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'SocietyAffiliation')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2406, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MusicalWorkContributor._Automaton = _BuildAutomaton_39()




MusicalWorkDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=MusicalWorkDetailsByTerritory, documentation='A ddex:Territory to which the ddex:MusicalWork details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2444, 12)))

MusicalWorkDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=MusicalWorkDetailsByTerritory, documentation='A ddex:Territory to which the ddex:MusicalWork details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2449, 12)))

MusicalWorkDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor'), MusicalWorkContributor, scope=MusicalWorkDetailsByTerritory, documentation='A ddex:Composite containing details a ddex:MusicalWorkContributor to the ddex:MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2455, 9)))

def _BuildAutomaton_40 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_40
    del _BuildAutomaton_40
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWorkDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2444, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MusicalWorkDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2449, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MusicalWorkDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2455, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MusicalWorkDetailsByTerritory._Automaton = _BuildAutomaton_40()




MusicalWorkId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISWC'), pyxb.binding.datatypes.string, scope=MusicalWorkId, documentation="The ddex:ISWC (International Standard Musical ddex:Work Code defined in ISO 15707) identifying the ddex:MusicalWork. An ddex:ISWC comprises three parts: the letter 'T', followed by nine digits and then one check digit.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2473, 9)))

MusicalWorkId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OpusNumber'), pyxb.binding.datatypes.string, scope=MusicalWorkId, documentation='The ddexC:MusicalWorkId identifying the ddex:MusicalWork within the catalog of its ddex:Composer (typically of classical music) as an opus number.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2478, 9)))

MusicalWorkId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ComposerCatalogNumber'), pyxb.binding.datatypes.string, scope=MusicalWorkId, documentation="A ddexC:MusicalWorkId identifying a ddex:MusicalWork within the catalog of its ddex:Composer (typically of classical music) according to a standardized numbering (e.g. 'K' numbers for Koechel's catalog of Mozart).", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2483, 9)))

MusicalWorkId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=MusicalWorkId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2489, 9)))

def _BuildAutomaton_41 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_41
    del _BuildAutomaton_41
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2473, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2478, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2483, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2489, 9))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISWC')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2473, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkId._UseForTag(pyxb.namespace.ExpandedName(None, 'OpusNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2478, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkId._UseForTag(pyxb.namespace.ExpandedName(None, 'ComposerCatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2483, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(MusicalWorkId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2489, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
MusicalWorkId._Automaton = _BuildAutomaton_41()




NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Quantity'), pyxb.binding.datatypes.integer, scope=NumberOfSubscribers, documentation='The number of ddex:Consumers using the ddex:DSP service specified for the ddex:UseType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2554, 9)))

NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=NumberOfSubscribers, documentation='A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2559, 9)))

NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=NumberOfSubscribers, documentation='A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2564, 9)))

NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=NumberOfSubscribers, documentation='A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2570, 9)))

NumberOfSubscribers._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=NumberOfSubscribers, documentation='A ddex:Composite containing details of a ddex:Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2576, 9)))

def _BuildAutomaton_42 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_42
    del _BuildAutomaton_42
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2564, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2570, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2576, 9))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'Quantity')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2554, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2559, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2564, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2570, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(NumberOfSubscribers._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2576, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
NumberOfSubscribers._Automaton = _BuildAutomaton_42()




PartyDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=PartyDescriptor, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2682, 9)))

PartyDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=PartyDescriptor, documentation='A ddex:Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2688, 12)))

def _BuildAutomaton_43 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_43
    del _BuildAutomaton_43
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2693, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PartyDescriptor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2682, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PartyDescriptor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2688, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(PartyDescriptor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2693, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PartyDescriptor._Automaton = _BuildAutomaton_43()




PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FullName'), Name, scope=PartyName, documentation='A ddex:Composite containing the complete ddex:Name of the ddex:Party, in its normal form of presentation (e.g. John H. Smith, Acme Music Inc, A ddex:Composite containing the Beatles).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2730, 9)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FullNameAsciiTranscribed'), pyxb.binding.datatypes.string, scope=PartyName, documentation='The ddex:FullName transcribed using 7-bit ddex:ASCII code.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2735, 9)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FullNameIndexed'), Name, scope=PartyName, documentation='A ddex:Composite containing the complete ddex:Name of the ddex:Party in the form in which it normally appears in an alphabetic index, with the ddex:KeyName first (e.g. Smith, John H.; Beatles, A ddex:Composite containing the).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2740, 9)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NamesBeforeKeyName'), Name, scope=PartyName, documentation="A ddex:Composite containing the Name(s) preceding the ddex:KeyName in the ddex:FullName (and that is placed after it in a ddex:FullNameIndexed). Examples: 'George' in 'George Michael'; 'John Fitzgerald' in 'John Fitzgerald Kennedy'. Not all ddex:PartyNames have a ddex:NamesBeforeKeyName (e.g. Madonna, EMI Music Inc).", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2745, 9)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'KeyName'), Name, scope=PartyName, documentation="A ddex:Composite containing the ddex:Part of a ddex:Name of the ddex:Party normally used to index an entry in an alphabetical list, such as 'Smith' (in John Smith) or 'Garcia Marquez' or 'Madonna' or 'Francis de Sales' (in Saint Francis de Sales). For persons, this normally corresponds to the 'family name' or names, which in Western name forms usually comes as a surname at the end of a ddex:FullName, and in Asian name forms often at the beginning of a ddex:FullName. ", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2750, 9)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NamesAfterKeyName'), Name, scope=PartyName, documentation="A ddex:Composite containing the Name(s) following the ddex:KeyName. Example:'Ibrahim' (in Anwar Ibrahim). This is common, e.g., in many Asian personal name forms where a ddex:FullName begins with the ddex:KeyName, which is followed by other names.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2755, 9)))

PartyName._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AbbreviatedName'), Name, scope=PartyName, documentation='A ddex:Composite containing a short version of the ddexC:PartyName (e.g. for use on devices with a small display).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2760, 9)))

def _BuildAutomaton_44 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_44
    del _BuildAutomaton_44
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2735, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2740, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2745, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2750, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2755, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2760, 9))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'FullName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2730, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'FullNameAsciiTranscribed')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2735, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'FullNameIndexed')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2740, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'NamesBeforeKeyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2745, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'KeyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2750, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'NamesAfterKeyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2755, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(PartyName._UseForTag(pyxb.namespace.ExpandedName(None, 'AbbreviatedName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2760, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PartyName._Automaton = _BuildAutomaton_44()




Period._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartDate'), EventDate, scope=Period, documentation='A ddex:Composite containing details of the Date and ddex:Place of an ddex:Event that marks the beginning of the ddexC:Period (in ISO 8601:2004 format: YYYY-MM-DD). The ddex:StartDate must be earlier than the ddex:EndDate if both are provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2778, 12)))

Period._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndDate'), EventDate, scope=Period, documentation='A ddex:Composite containing details of the Date and ddex:Place of an ddex:Event that marks the end of the ddexC:Period (in ISO 8601:2004 format: YYYY-MM-DD). The ddex:EndDate must be later than the ddex:StartDate if both are provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2783, 12)))

Period._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartDateTime'), EventDateTime, scope=Period, documentation='A ddex:Composite containing details of the ddex:DateTime and ddex:Place of an ddex:Event that marks the beginning of the ddexC:Period (in ISO 8601:2004 format: YYYY-DD-MMThh:mm:ss). The StartDateTime must be earlier than the EndDateTime if both are provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2790, 12)))

Period._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndDateTime'), EventDateTime, scope=Period, documentation='A ddex:Composite containing details of the ddex:DateTime and ddex:Place of an ddex:Event that marks the end of the ddexC:Period (in ISO 8601:2004 format: YYYY-DD-MMThh:mm:ss). The EndDateTime must be later than the StartDateTime if both are provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2795, 12)))

def _BuildAutomaton_45 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_45
    del _BuildAutomaton_45
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2778, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2783, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2790, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2795, 12))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Period._UseForTag(pyxb.namespace.ExpandedName(None, 'StartDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2778, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Period._UseForTag(pyxb.namespace.ExpandedName(None, 'EndDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2783, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Period._UseForTag(pyxb.namespace.ExpandedName(None, 'StartDateTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2790, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Period._UseForTag(pyxb.namespace.ExpandedName(None, 'EndDateTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2795, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Period._Automaton = _BuildAutomaton_45()




PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Description'), Description, scope=PriceInformation, documentation='A ddex:Composite containing a ddex:Description of the differences between multiple ddexC:PriceInformation ddex:Composites.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2836, 9)))

PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PriceRangeType'), PriceRangeType, scope=PriceInformation, documentation="A ddex:Composite containing a ddex:Type of ddex:Price according to its value range. Typical examples include 'budget' and 'front line'.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2841, 9)))

PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PriceType'), PriceType, scope=PriceInformation, documentation='A ddex:Composite containing further details of the ddex:Price. Often used to refine the ddex:PriceRangeType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2846, 9)))

PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'WholesalePricePerUnit'), Price, scope=PriceInformation, documentation='A ddex:Composite containing details of a wholesale ddex:Price for a single unit of Usage. Note that this ddex:Price applies to all ddex:UseTypes referenced in a DealTerm ddex:Composite.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2851, 9)))

PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'BulkOrderWholesalePricePerUnit'), Price, scope=PriceInformation, documentation='A ddex:Composite containing details of a wholesale ddex:Price for a single unit. Note that the size of a bulk order is defined in the contract between ddex:MessageSender and the ddex:MessageRecipient.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2856, 9)))

PriceInformation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SuggestedRetailPrice'), Price, scope=PriceInformation, documentation='A ddex:Composite containing details of a suggested retail ddex:Price.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2861, 9)))

def _BuildAutomaton_46 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_46
    del _BuildAutomaton_46
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2836, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2841, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2846, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2851, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2856, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2861, 9))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'Description')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2836, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'PriceRangeType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2841, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'PriceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2846, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'WholesalePricePerUnit')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2851, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'BulkOrderWholesalePricePerUnit')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2856, 9))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(PriceInformation._UseForTag(pyxb.namespace.ExpandedName(None, 'SuggestedRetailPrice')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2861, 9))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
PriceInformation._Automaton = _BuildAutomaton_46()




RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseType'), ReleaseType, scope=RecordCompanyMarketShareData, documentation='A ddex:Composite containing details of the form in which a ddex:ReleaseCreator anticipates offering the ddex:Release to ddex:Consumers.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3019, 9)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UnitsSoldTotal'), pyxb.binding.datatypes.integer, scope=RecordCompanyMarketShareData, documentation='The total number of ddex:Releases sold of the ddex:ReleaseType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3024, 9)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=RecordCompanyMarketShareData, documentation='A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3029, 9)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=RecordCompanyMarketShareData, documentation='A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3034, 9)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=RecordCompanyMarketShareData, documentation='A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3040, 9)))

RecordCompanyMarketShareData._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=RecordCompanyMarketShareData, documentation='A ddex:Composite containing details of a ddex:Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3046, 9)))

def _BuildAutomaton_47 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_47
    del _BuildAutomaton_47
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3019, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3029, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3034, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3040, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3046, 9))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3019, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'UnitsSoldTotal')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3024, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3029, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3034, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3040, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(RecordCompanyMarketShareData._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3046, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RecordCompanyMarketShareData._Automaton = _BuildAutomaton_47()




ReferenceTitle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TitleText'), TitleText, scope=ReferenceTitle, documentation='A ddex:Composite containing the text of the ddexC:ReferenceTitle.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3077, 9)))

ReferenceTitle._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SubTitle'), SubTitle, scope=ReferenceTitle, documentation='A ddex:Composite containing details of a ddex:SubTitle of the ddexC:ReferenceTitle, including ddex:Titles of ddex:Versions used to differentiate different versions of the same ddex:Title, as required by the ddex:GRid and ddex:ISRC ddex:ReferenceDescriptiveMetadataSets (where the SubTitle is called ddex:Version ddex:Title).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3082, 9)))

def _BuildAutomaton_48 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_48
    del _BuildAutomaton_48
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3082, 9))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReferenceTitle._UseForTag(pyxb.namespace.ExpandedName(None, 'TitleText')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3077, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ReferenceTitle._UseForTag(pyxb.namespace.ExpandedName(None, 'SubTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3082, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReferenceTitle._Automaton = _BuildAutomaton_48()




RelatedLicenseOrClaimId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimId'), RightsAgreementId, scope=RelatedLicenseOrClaimId, documentation='A ddex:Composite containing details of an ddex:Identifier of the ddex:License or ddex:Claim.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3099, 9)))

RelatedLicenseOrClaimId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimUpdateReason'), LicenseOrClaimUpdateReason, scope=RelatedLicenseOrClaimId, documentation='A ddex:Composite containing details of a reason for an updated mwl:LicenseOrClaim.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3104, 9)))

def _BuildAutomaton_49 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_49
    del _BuildAutomaton_49
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3099, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3104, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(RelatedLicenseOrClaimId._UseForTag(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3099, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(RelatedLicenseOrClaimId._UseForTag(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimUpdateReason')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3104, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
RelatedLicenseOrClaimId._Automaton = _BuildAutomaton_49()




RelatedLicenseOrClaimRequestId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimRequestId'), ProprietaryId, scope=RelatedLicenseOrClaimRequestId, documentation='A ddex:Composite containing details of an ddex:Identifier of mwl:LicenseOrClaimRequest.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3117, 9)))

RelatedLicenseOrClaimRequestId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimRequestUpdateReason'), LicenseOrClaimRequestUpdateReason, scope=RelatedLicenseOrClaimRequestId, documentation='A ddex:Composite containing details of a reason for an updated mwl:LicenseOrClaimRequest.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3122, 9)))

def _BuildAutomaton_50 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_50
    del _BuildAutomaton_50
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3117, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3122, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(RelatedLicenseOrClaimRequestId._UseForTag(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimRequestId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3117, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(RelatedLicenseOrClaimRequestId._UseForTag(pyxb.namespace.ExpandedName(None, 'LicenseOrClaimRequestUpdateReason')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3122, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
RelatedLicenseOrClaimRequestId._Automaton = _BuildAutomaton_50()




RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=RelatedRelease, documentation='A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid shall always to be used. If the ddex:Release contains only one ddex:SoundRecording, the ddex:ISRC of the ddex:SoundRecording may be used instead. If the ddex:Release is an abstraction of a complete ddex:PhysicalProduct (such as a CD ddex:Album), the ddex:ICPN of the ddex:PhysicalProduct may be used instead. More than one of these identifiers may be provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3135, 9)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=RelatedRelease, documentation='A ddex:Composite containing details of the ddex:ReferenceTitle of the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3140, 9)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory'), ReleaseSummaryDetailsByTerritory, scope=RelatedRelease, documentation='A ddex:Composite containing summary details of ddex:Descriptors and other attributes of the ddex:Release which may vary according to ddex:Territory of ddex:Release. ddex:Territory of ddex:Release may be the world.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3145, 9)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=RelatedRelease, documentation='A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3151, 9)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseRelationshipType'), ReleaseRelationshipType, scope=RelatedRelease, documentation='A ddex:Composite containing details of the ddex:Type of the relationship between the two ddex:Releases.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3156, 9)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseDate'), EventDate, scope=RelatedRelease, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the related ddex:Release is made available for Usage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3161, 9)))

RelatedRelease._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate'), EventDate, scope=RelatedRelease, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Release was or will be first made available for Usage, whether for physical or electronic/online distribution (in ISO 8601:2004 format: YYYY-MM-DD).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3166, 9)))

def _BuildAutomaton_51 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_51
    del _BuildAutomaton_51
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3140, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3145, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3151, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3161, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3166, 9))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3135, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3140, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3145, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3151, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseRelationshipType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3156, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3161, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(RelatedRelease._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3166, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RelatedRelease._Automaton = _BuildAutomaton_51()




ReleaseCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), pyxb.binding.datatypes.integer, scope=ReleaseCollectionReferenceList, documentation='The number of referenced ddexC:Collections (typically Chapters).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3216, 9)))

ReleaseCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseCollectionReference'), ReleaseCollectionReference, scope=ReleaseCollectionReferenceList, documentation='A ddex:Composite containing a ddex:ReleaseCollectionReference for a ddex:Collection (specific to this ddex:Message). The referenced ddex:Collection has to be of ddex:CollectionType ddex:Series, ddex:Season or ddex:Episode.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3221, 9)))

def _BuildAutomaton_52 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_52
    del _BuildAutomaton_52
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3216, 9))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'NumberOfCollections')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3216, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3221, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseCollectionReferenceList._Automaton = _BuildAutomaton_52()




ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=ReleaseDetailsByTerritory, documentation='A ddex:Territory to which the ddexC:ReleaseSummaryDetailsByTerritory apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3235, 12)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=ReleaseDetailsByTerritory, documentation='A ddex:Territory to which the ddexC:ReleaseSummaryDetailsByTerritory do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3240, 12)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtistName'), Name, scope=ReleaseDetailsByTerritory, documentation='A ddex:Composite containing the ddex:Name to be used by a ddex:DSP when presenting ddex:Artist details of the ddex:Release to a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3246, 9)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LabelName'), LabelName, scope=ReleaseDetailsByTerritory, documentation='A ddex:Composite containing the ddex:Name of the ddex:Label for the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3251, 9)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=ReleaseDetailsByTerritory, documentation='A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3256, 9)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=ReleaseDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Title of the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3261, 9)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), Artist, scope=ReleaseDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:DisplayArtist for the ddex:Release. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3266, 9)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsMultiArtistCompilation'), pyxb.binding.datatypes.boolean, scope=ReleaseDetailsByTerritory, documentation='The ddex:Flag indicating whether the ddex:Release is a multiartist compilation (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3271, 9)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany'), AdministratingRecordCompany, scope=ReleaseDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:AdministratingRecordCompany for the ddex:Release. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3276, 9)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseType'), ReleaseType, scope=ReleaseDetailsByTerritory, documentation='A ddex:Composite containing details of the form in which a ddex:ReleaseCreator anticipates offering the ddex:Release to ddex:Consumers. This overrides the ddex:ReleaseType specified globally for the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3282, 9)))

ReleaseDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RelatedRelease'), RelatedRelease, scope=ReleaseDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Release (or a ddex:PhysicalProduct or a ddex:DigitalProduct derived from such a ddex:Release) which is related to this ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3287, 9)))

def _BuildAutomaton_53 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_53
    del _BuildAutomaton_53
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3246, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3251, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3256, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3261, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3271, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3276, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3282, 9))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3287, 9))
    counters.add(cc_7)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3235, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3240, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtistName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3246, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3251, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3256, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3261, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3266, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IsMultiArtistCompilation')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3271, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'AdministratingRecordCompany')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3276, 9))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3282, 9))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RelatedRelease')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3287, 9))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    st_10._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseDetailsByTerritory._Automaton = _BuildAutomaton_53()




ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'GRid'), pyxb.binding.datatypes.string, scope=ReleaseId, documentation="The ddex:GRid identifying the ddex:Release. This is the preferred ddex:Element and is mandatory if a ddex:GRid is available. A ddex:GRid comprises four parts: the xs:string 'A1', followed by five alphanumeric characters, ten alphanumeric characters and and one alphanumeric character.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3305, 9)))

ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=ReleaseId, documentation='The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) used as proxy for identification of the ddex:Release. Only applicable when the ddex:Release only contains one ddex:SoundRecording or one ddex:MusicalWorkVideo. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3310, 9)))

ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ICPN'), ICPN, scope=ReleaseId, documentation='A ddex:Composite containing details of the ddex:ICPN used as proxy for identification of the ddex:Release. Only applicable when the ddex:Release is an abstraction of a complete ddex:PhysicalProduct. An ddex:ICPN comprises 12 or 13 digits, depending whether it is an ddex:EAN (13) or a ddex:UPC (12).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3315, 9)))

ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=ReleaseId, documentation='A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3320, 9)))

ReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=ReleaseId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3325, 9)))

def _BuildAutomaton_54 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_54
    del _BuildAutomaton_54
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3305, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3310, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3315, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3320, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3325, 9))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'GRid')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3305, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3310, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ICPN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3315, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3320, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3325, 9))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ReleaseId._Automaton = _BuildAutomaton_54()




ReleaseResourceReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseResourceReference'), ReleaseResourceReference, scope=ReleaseResourceReferenceList, documentation='A ddex:Composite containing a ddex:Reference for a ddex:Resource (specific to this ddex:Message). The ddex:LocalAnchorReference in this ddex:Composite is a xs:string starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3376, 9)))

def _BuildAutomaton_55 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_55
    del _BuildAutomaton_55
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseResourceReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3376, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseResourceReferenceList._Automaton = _BuildAutomaton_55()




ReleaseSummary._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=ReleaseSummary, documentation='A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid shall always to be used. If the ddex:Release contains only one ddex:SoundRecording, the ddex:ISRC of the ddex:SoundRecording may be used instead. If the ddex:Release is an abstraction of a complete ddex:PhysicalProduct (such as a CD ddex:Album), the ddex:ICPN of the ddex:PhysicalProduct may be used instead. More than one of these identifiers may be provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3389, 9)))

ReleaseSummary._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReferenceTitle'), ReferenceTitle, scope=ReleaseSummary, documentation='A ddex:Composite containing details of the ddex:ReferenceTitle of the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3394, 9)))

ReleaseSummary._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory'), ReleaseSummaryDetailsByTerritory, scope=ReleaseSummary, documentation='A ddex:Composite containing summary details of ddex:Descriptors and other attributes of the ddex:Release which may vary according to ddex:Territory of ddex:Release. ddex:Territory of ddex:Release may be the world.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3399, 9)))

ReleaseSummary._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=ReleaseSummary, documentation='A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3405, 9)))

def _BuildAutomaton_56 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_56
    del _BuildAutomaton_56
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3399, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3405, 9))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3389, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'ReferenceTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3394, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseSummaryDetailsByTerritory')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3399, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummary._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3405, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseSummary._Automaton = _BuildAutomaton_56()




ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=ReleaseSummaryDetailsByTerritory, documentation='A ddex:Territory to which the ddexC:ReleaseSummaryDetailsByTerritory apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3423, 12)))

ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=ReleaseSummaryDetailsByTerritory, documentation='A ddex:Territory to which the ddexC:ReleaseSummaryDetailsByTerritory do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3428, 12)))

ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtistName'), Name, scope=ReleaseSummaryDetailsByTerritory, documentation='A ddex:Composite containing the ddex:Name to be used by a ddex:DSP when presenting ddex:Artist details of the ddex:Release to a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3434, 9)))

ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LabelName'), LabelName, scope=ReleaseSummaryDetailsByTerritory, documentation='A ddex:Composite containing the ddex:Name of the ddex:Label for the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3439, 9)))

ReleaseSummaryDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=ReleaseSummaryDetailsByTerritory, documentation='A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3444, 9)))

def _BuildAutomaton_57 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_57
    del _BuildAutomaton_57
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3434, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3439, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3444, 9))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3423, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3428, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtistName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3434, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3439, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ReleaseSummaryDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3444, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ReleaseSummaryDetailsByTerritory._Automaton = _BuildAutomaton_57()




ResourceContainedResourceReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference'), STD_ANON_8, scope=ResourceContainedResourceReference, documentation='A ddex:Reference for a ddex:Resource (specific to this ddex:Message). This is a ddex:LocalResourceAnchorReference starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3532, 9)))

ResourceContainedResourceReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DurationUsed'), pyxb.binding.datatypes.duration, scope=ResourceContainedResourceReference, documentation='The total ddex:Duration of the ddex:Resource that has been used in a specified context (this may be less than the total ddex:Duration of the ddex:Resource) (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3542, 9)))

ResourceContainedResourceReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartPoint'), pyxb.binding.datatypes.decimal, scope=ResourceContainedResourceReference, documentation='The start point of the preview given in seconds from the start of the referenced ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3547, 9)))

ResourceContainedResourceReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Purpose'), Purpose, scope=ResourceContainedResourceReference, documentation='A ddex:Composite containing details of the ddex:Purpose of the usage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3552, 9)))

def _BuildAutomaton_58 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_58
    del _BuildAutomaton_58
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3542, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3547, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3552, 9))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReference._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3532, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReference._UseForTag(pyxb.namespace.ExpandedName(None, 'DurationUsed')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3542, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReference._UseForTag(pyxb.namespace.ExpandedName(None, 'StartPoint')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3547, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReference._UseForTag(pyxb.namespace.ExpandedName(None, 'Purpose')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3552, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceContainedResourceReference._Automaton = _BuildAutomaton_58()




ResourceContainedResourceReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference'), ResourceContainedResourceReference, scope=ResourceContainedResourceReferenceList, documentation='A ddex:Composite containing details of a ddex:ResourceContainedResourceReference.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3564, 9)))

def _BuildAutomaton_59 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_59
    del _BuildAutomaton_59
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceContainedResourceReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContainedResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3564, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceContainedResourceReferenceList._Automaton = _BuildAutomaton_59()




ResourceContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=ResourceContributor, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3578, 12)))

ResourceContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=ResourceContributor, documentation='A ddex:Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3584, 15)))

ResourceContributor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributorRole'), ResourceContributorRole, scope=ResourceContributor, documentation='A ddex:Composite containing details of a role played by the ddex:Contributor.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3596, 9)))

def _BuildAutomaton_60 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_60
    del _BuildAutomaton_60
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3589, 15))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3596, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3578, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3584, 15))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3589, 15))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ResourceContributor._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributorRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3596, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceContributor._Automaton = _BuildAutomaton_60()




ResourceGroupResourceReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceGroupResourceReference'), STD_ANON_9, scope=ResourceGroupResourceReferenceList, documentation='A ddex:Reference for a ddex:Resource (specific to this ddex:Message). This is a ddex:LocalResourceAnchorReference starting with the letter A.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3633, 9)))

def _BuildAutomaton_61 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_61
    del _BuildAutomaton_61
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceGroupResourceReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceGroupResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3633, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceGroupResourceReferenceList._Automaton = _BuildAutomaton_61()




ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:Resource. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3650, 9)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISMN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation="The ddex:ISMN (International Standard Music Number defined in ISO 10957) for the ddex:Resource. An ddex:ISMN is a thirteen-digit number. Pre-2008 ddex:ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ('M') with '979-0'.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3655, 9)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISAN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The ddex:ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the ddex:Resource. An ddex:ISAN comprises four blocks of four hexadecimal charaters followed by a check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3660, 9)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VISAN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The V-ISAN (Version ddex:Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the ddex:Resource. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3665, 9)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISBN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation="The ddex:ISBN (International Standard Book Number defined in ISO 2108) for the ddex:Resource. An ddex:ISBN is a 13-digit number. Pre-2007, ddex:ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix '978' and re-calculating the check character.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3670, 9)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISSN'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The ddex:ISSN (International Standard Serial Number defined in ISO 3297) for the ddex:Resource. An ddex:ISSN comprises two groups of four digits, separated by a hyphen and a control digit.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3675, 9)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SICI'), pyxb.binding.datatypes.string, scope=ResourceId, documentation='The ddex:SICI (Serial Item and Contribution ddex:Identifier defined in ANSI/NISO Z39.56-199)  for the ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3680, 9)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=ResourceId, documentation='A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3685, 9)))

ResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=ResourceId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3690, 9)))

def _BuildAutomaton_62 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_62
    del _BuildAutomaton_62
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3650, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3655, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3660, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3665, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3670, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3675, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3680, 9))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3685, 9))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3690, 9))
    counters.add(cc_8)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3650, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISMN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3655, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3660, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'VISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3665, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISBN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3670, 9))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISSN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3675, 9))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'SICI')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3680, 9))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3685, 9))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(ResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3690, 9))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ResourceId._Automaton = _BuildAutomaton_62()




ResourceMusicalWorkReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), pyxb.binding.datatypes.integer, scope=ResourceMusicalWorkReference, documentation='The number indicating the order of the ddex:MusicalWork in a group of ddex:MusicalWorks within a ddex:Medley, ddex:SoundRecording or other ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3708, 9)))

ResourceMusicalWorkReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DurationUsed'), pyxb.binding.datatypes.duration, scope=ResourceMusicalWorkReference, documentation='The total ddex:Duration of the ddex:MusicalWork that has been used in a specified context (this may be less than the total ddex:Duration of the ddex:MusicalWork) (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3713, 9)))

ResourceMusicalWorkReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IsFragment'), pyxb.binding.datatypes.boolean, scope=ResourceMusicalWorkReference, documentation='The ddex:Flag indicating whether the ddex:MusicalWork is a ddex:Fragment (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3718, 9)))

ResourceMusicalWorkReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference'), STD_ANON_10, scope=ResourceMusicalWorkReference, documentation='A ddex:Reference for a ddex:MusicalWork (specific to this ddex:Message). This is a ddex:LocalMusicalWorkAnchorReference starting with the letter W.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3723, 9)))

def _BuildAutomaton_63 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_63
    del _BuildAutomaton_63
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3708, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3713, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3718, 9))
    counters.add(cc_2)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReference._UseForTag(pyxb.namespace.ExpandedName(None, 'SequenceNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3708, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReference._UseForTag(pyxb.namespace.ExpandedName(None, 'DurationUsed')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3713, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReference._UseForTag(pyxb.namespace.ExpandedName(None, 'IsFragment')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3718, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReference._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3723, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceMusicalWorkReference._Automaton = _BuildAutomaton_63()




ResourceMusicalWorkReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference'), ResourceMusicalWorkReference, scope=ResourceMusicalWorkReferenceList, documentation='A ddex:Composite containing a ddex:ResourceMusicalWorkReference for a ddex:MusicalWork (specific to this ddex:Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3740, 9)))

def _BuildAutomaton_64 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_64
    del _BuildAutomaton_64
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ResourceMusicalWorkReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceMusicalWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3740, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ResourceMusicalWorkReferenceList._Automaton = _BuildAutomaton_64()




RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareId'), RightsAgreementId, scope=RightShare, documentation='A ddex:Composite containing details of ddex:Identifiers for the ddexC:RightShare.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3791, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareReference'), STD_ANON_11, scope=RightShare, documentation='The ddex:Identifier (specific to the ddex:Message) of the ddexC:RightShare within the ddex:Release which contains it. This is a ddex:LocalRightShareAnchor starting with the letter S.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3796, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareCreationReferenceList'), RightShareCreationReferenceList, scope=RightShare, documentation='A ddex:Composite containing details of one or more ddex:Creations contained in the ddexC:RightShare.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3806, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=RightShare, documentation='A ddex:Territory to which the ddexC:RightShare applies (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3813, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=RightShare, documentation='A ddex:Territory to which the ddexC:RightShare does not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3818, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsType'), RightsType, scope=RightShare, documentation='A ddex:Type of ddex:Right covered by the ddexC:RightShare. One of the ddex:Elements RightsType and ddex:UseType must be present. The RightsType is defined according to the jurisdiction of the ddex:Territory indicated in the iso3166a2:TerritoryCode ddex:XmlAttribute.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3824, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=RightShare, documentation='A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer. One of the ddex:Elements RightsType and ddex:UseType must be present.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3829, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=RightShare, documentation='A ddex:Composite containing details of a physical interface by which a ddex:Consumer uses a ddex:Service or ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3834, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=RightShare, documentation='A ddex:Composite containing details of a distribution channel used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3840, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=RightShare, documentation='A ddex:Composite containing details of a ddex:Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3846, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CommercialModelType'), CommercialModelType, scope=RightShare, documentation='A ddex:Composite containing details of the fundamental business model which applies (e.g. ddex:SubscriptionModel and ddex:PayAsYouGoModel). The ddex:CommercialModelType indicates how the ddex:Consumer pays for the ddex:Service or ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3851, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWorkRightsClaimType'), _ImportedBinding__ddex.MusicalWorkRightsClaimType, scope=RightShare, documentation='A ddex:Type of the ddex:RightsClaim related to a ddex:MusicalWork.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3857, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsController'), RightsController, scope=RightShare, documentation='A ddex:Composite containing details of a ddex:RightsController of Rights in a ddex:Creation.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3863, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ValidityPeriod'), Period, scope=RightShare, documentation='A ddex:Composite containing details about the ddex:Period of ddex:Time for which the ddexC:RightShare is valid.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3869, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PercentageUnknown'), pyxb.binding.datatypes.boolean, scope=RightShare, documentation='The ddex:Flag indicating whether the ddex:RightSharePercentage is unknown (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3875, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PercentageRate'), pyxb.binding.datatypes.string, scope=RightShare, documentation="The share of the licensed Rights owned by the ddex:RightsController. ddexC:RightShare information is given as a xs:decimal value (e.g. '0.125' represents 12.5%) or as a fraction (e.g. '1/8' represents 12.5%).", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3880, 12)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TariffReference'), TariffReference, scope=RightShare, documentation='A ddex:Composite containing details of a ddex:Reference to a ddex:TextDocument containing details of a ddex:Tariff (in the form of an ddex:Identifier, ddex:Name or ddex:Description) that is to be applied to the ddexC:RightShare.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3886, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LicenseStatus'), _ImportedBinding__ddex.LicenseStatus, scope=RightShare, documentation='The legal status of a ddex:License for the ddexC:RightShare.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3891, 9)))

RightShare._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HasFirstLicenseRefusal'), pyxb.binding.datatypes.boolean, scope=RightShare, documentation='The ddex:Flag indicating whether a ddex:RightsController retains the right of refusal regarding the granting of the first licence for creating a ddex:SoundRecording of a Musical ddex:Work (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3896, 9)))

def _BuildAutomaton_65 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_65
    del _BuildAutomaton_65
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3791, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3806, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3824, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3829, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3834, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3840, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3846, 9))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3851, 9))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3857, 9))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3863, 9))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3880, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3886, 9))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3891, 9))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3896, 9))
    counters.add(cc_13)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3791, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3796, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareCreationReferenceList')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3806, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3813, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3818, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3824, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3829, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3834, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3840, 9))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3846, 9))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'CommercialModelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3851, 9))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWorkRightsClaimType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3857, 9))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsController')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3863, 9))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'ValidityPeriod')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3869, 9))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'PercentageUnknown')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3875, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'PercentageRate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3880, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'TariffReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3886, 9))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'LicenseStatus')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3891, 9))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(RightShare._UseForTag(pyxb.namespace.ExpandedName(None, 'HasFirstLicenseRefusal')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3896, 9))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, True) ]))
    st_18._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RightShare._Automaton = _BuildAutomaton_65()




RightShareCreationReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareWorkReference'), STD_ANON_12, scope=RightShareCreationReferenceList, documentation='A ddex:Reference for a ddex:Work (specific to this ddex:Message) that is part of the ddex:RightShare. This is a ddex:LocalMusicalWorkAnchorReference starting with the letter W.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3913, 9)))

RightShareCreationReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareResourceReference'), STD_ANON_13, scope=RightShareCreationReferenceList, documentation='A ddex:Reference for a ddex:Resource (specific to this ddex:Message) that is part of the ddex:RightShare. This is a ddex:LocalResourceAnchorReference starting with the letter A. The ddex:RightShare covers the ddex:Works used in the Resource(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3923, 9)))

RightShareCreationReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareReleaseReference'), STD_ANON_14, scope=RightShareCreationReferenceList, documentation='A ddex:Reference for a ddex:Release (specific to this ddex:Message) that is part of the ddex:RightShare. This is a ddex:LocalReleaseAnchorReference starting with the letter R. The ddex:RightShare covers the ddex:Works used in the Release(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3933, 9)))

def _BuildAutomaton_66 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_66
    del _BuildAutomaton_66
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3913, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3923, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3933, 9))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(RightShareCreationReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareWorkReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3913, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(RightShareCreationReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareResourceReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3923, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(RightShareCreationReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareReleaseReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3933, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
RightShareCreationReferenceList._Automaton = _BuildAutomaton_66()




RightsAgreementId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MWLI'), pyxb.binding.datatypes.string, scope=RightsAgreementId, documentation="A ddex:MusicalWork ddex:License ddex:Identifier identifying a ddex:License. If the ddex:Composite is meant to describe a ddex:Claim, ddex:RightShare or contract, then the ddex:License relates to that ddex:Claim, ddex:RightShare or contract. A ddex:MWLI comprises four parts: one of the xs:strings 'M1' or 'M2' or 'M3' or 'M4', followed by five alphanumeric characters, ten alphanumeric characters and one alphanumeric check character.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3950, 9)))

RightsAgreementId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=RightsAgreementId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:License, ddex:Claim, ddex:RightShare or contract.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3955, 9)))

def _BuildAutomaton_67 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_67
    del _BuildAutomaton_67
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3950, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3955, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(RightsAgreementId._UseForTag(pyxb.namespace.ExpandedName(None, 'MWLI')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3950, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(RightsAgreementId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3955, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
RightsAgreementId._Automaton = _BuildAutomaton_67()




RightsController._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=RightsController, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3969, 12)))

RightsController._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=RightsController, documentation='A ddex:Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3975, 15)))

RightsController._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsControllerRole'), _ImportedBinding__ddex.RightsControllerRole, scope=RightsController, documentation='A role that describes the ddex:Party involved in the administration of ddex:Rights.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3987, 9)))

RightsController._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightShareUnknown'), pyxb.binding.datatypes.boolean, scope=RightsController, documentation='The ddex:Flag indicating whether the ddex:RightSharePercentage is unknown (=True) or not (=False).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3994, 12)))

RightsController._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightSharePercentage'), pyxb.binding.datatypes.string, scope=RightsController, documentation="The share of the licensed Rights owned by the ddexC:RightsController. ddex:RightShare information is given as a xs:decimal value (e.g. '0.125' represents 12.5%). If no information is given, 100% is assumed.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3999, 12)))

def _BuildAutomaton_68 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_68
    del _BuildAutomaton_68
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3980, 15))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3987, 9))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3969, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3975, 15))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3980, 15))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsControllerRole')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3987, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'RightShareUnknown')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3994, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(RightsController._UseForTag(pyxb.namespace.ExpandedName(None, 'RightSharePercentage')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 3999, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    transitions = []
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
RightsController._Automaton = _BuildAutomaton_68()




SalesReportingProxyReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=SalesReportingProxyReleaseId, documentation='A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid should always be used.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4069, 9)))

SalesReportingProxyReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Reason'), Reason, scope=SalesReportingProxyReleaseId, documentation='A ddex:Composite containing the textual ddex:Description of the reason for the ddex:Identifier being used as a proxy.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4074, 9)))

SalesReportingProxyReleaseId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReasonType'), ReasonType, scope=SalesReportingProxyReleaseId, documentation='A ddex:Composite containing details of a ReasonType.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4079, 9)))

def _BuildAutomaton_69 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_69
    del _BuildAutomaton_69
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4074, 9))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SalesReportingProxyReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4069, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SalesReportingProxyReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'Reason')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4074, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SalesReportingProxyReleaseId._UseForTag(pyxb.namespace.ExpandedName(None, 'ReasonType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4079, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SalesReportingProxyReleaseId._Automaton = _BuildAutomaton_69()




SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=SheetMusicDetailsByTerritory, documentation='A ddex:Territory to which the ddex:SheetMusic details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4130, 12)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=SheetMusicDetailsByTerritory, documentation='A ddex:Territory to which the ddex:SheetMusic details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4135, 12)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=SheetMusicDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Title of the ddex:SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4141, 9)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=SheetMusicDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Contributor to the ddex:SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4146, 9)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=SheetMusicDetailsByTerritory, documentation='A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4152, 9)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=SheetMusicDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:CLine for the ddex:SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4158, 9)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), CourtesyLine, scope=SheetMusicDetailsByTerritory, documentation='A ddex:Composite containing an ddex:Annotation which acknowledges record companies and/or other Parties giving permission for ddex:Artists or others featured in the ddex:SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4163, 9)))

SheetMusicDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=SheetMusicDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SheetMusic was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4168, 9)))

def _BuildAutomaton_70 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_70
    del _BuildAutomaton_70
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4141, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4146, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4152, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4158, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4163, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4168, 9))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4130, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4135, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4141, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4146, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4152, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4158, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CourtesyLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4163, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4168, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SheetMusicDetailsByTerritory._Automaton = _BuildAutomaton_70()




SheetMusicId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISMN'), pyxb.binding.datatypes.string, scope=SheetMusicId, documentation="The ddex:ISMN (International Standard Music Number defined in ISO 10957) for the ddex:SheetMusic. An ddex:ISMN is a thirteen-digit number. Pre-2008 ddex:ISMNs, which had 10 characters and are now deprecated, are converted by replacing the initial letter ('M') with '979-0'.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4185, 9)))

SheetMusicId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=SheetMusicId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:SheetMusic.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4190, 9)))

def _BuildAutomaton_71 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_71
    del _BuildAutomaton_71
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4185, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4190, 9))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISMN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4185, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SheetMusicId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4190, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SheetMusicId._Automaton = _BuildAutomaton_71()




SocietyAffiliation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=SocietyAffiliation, documentation='A ddex:Territory to which the affiliation details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4228, 12)))

SocietyAffiliation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=SocietyAffiliation, documentation='A ddex:Territory to which the affiliation details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4233, 12)))

SocietyAffiliation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicRightsSociety'), PartyDescriptor, scope=SocietyAffiliation, documentation='A ddex:Composite containing details of a ddex:MusicRightsSociety.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4239, 9)))

def _BuildAutomaton_72 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_72
    del _BuildAutomaton_72
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SocietyAffiliation._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4228, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SocietyAffiliation._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4233, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SocietyAffiliation._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicRightsSociety')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4239, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SocietyAffiliation._Automaton = _BuildAutomaton_72()




SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=SoftwareDetailsByTerritory, documentation='A ddex:Territory to which the ddex:Software details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4252, 12)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=SoftwareDetailsByTerritory, documentation='A ddex:Territory to which the ddex:Software details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4257, 12)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=SoftwareDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Contributor to the ddex:Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4263, 9)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=SoftwareDetailsByTerritory, documentation='A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4269, 9)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLine'), PLine, scope=SoftwareDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:PLine for the ddex:Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4275, 9)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=SoftwareDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:CLine for the ddex:Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4280, 9)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), CourtesyLine, scope=SoftwareDetailsByTerritory, documentation='A ddex:Composite containing an ddex:Annotation which acknowledges record companies and/or other Parties giving permission for ddex:Artists or others featured in the ddex:Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4285, 9)))

SoftwareDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=SoftwareDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Software was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4290, 9)))

def _BuildAutomaton_73 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_73
    del _BuildAutomaton_73
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4263, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4269, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4275, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4280, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4285, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4290, 9))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4252, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4257, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4263, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4269, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'PLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4275, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4280, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CourtesyLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4285, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(SoftwareDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4290, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoftwareDetailsByTerritory._Automaton = _BuildAutomaton_73()




SoftwareId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=SoftwareId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Software.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4307, 9)))

def _BuildAutomaton_74 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_74
    del _BuildAutomaton_74
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoftwareId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4307, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoftwareId._Automaton = _BuildAutomaton_74()




SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SequenceNumber'), pyxb.binding.datatypes.integer, scope=SoundRecordingCollectionReference, documentation='The number indicating the order of the ddex:Collection in a group of ddex:Collections within a ddex:Medley, ddex:SoundRecording or other ddex:Collection.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4367, 9)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference'), STD_ANON_15, scope=SoundRecordingCollectionReference, documentation='A ddex:Reference for a ddex:Collection (specific to this ddex:Message). This is a ddex:LocalCollectionAnchorReference starting with the letter X. The referenced ddex:Collection has to be of ddex:CollectionType ddex:Series, ddex:Season or ddex:Episode.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4372, 9)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'StartTime'), pyxb.binding.datatypes.duration, scope=SoundRecordingCollectionReference, documentation='The start time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4382, 9)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Duration'), pyxb.binding.datatypes.duration, scope=SoundRecordingCollectionReference, documentation='The ddex:Duration of the use of the ddex:Creation that is referenced in the ddex:CueCreationReference (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4387, 9)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EndTime'), pyxb.binding.datatypes.duration, scope=SoundRecordingCollectionReference, documentation='The end time of the ddex:Creation, measured from the start of the ddex:Resource from which the ddex:CueSheet is referenced (using the ISO 8601:2004 PT[[hhH]mmM]ssS format, where lower case characters indicate variables, upper case characters are part of the xs:string, e.g. one hour, two minutes and three seconds would be PT1H2M3S).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4392, 9)))

SoundRecordingCollectionReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType'), _ImportedBinding__ddex.ReleaseResourceType, scope=SoundRecordingCollectionReference, documentation='A ddex:Type of ddex:Collection in the context of a ddex:Video. This is represented in an XML schema as an XML ddex:Attribute.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4397, 9)))

def _BuildAutomaton_75 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_75
    del _BuildAutomaton_75
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4367, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4382, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4387, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4392, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4397, 9))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'SequenceNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4367, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4372, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'StartTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4382, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'Duration')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4387, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'EndTime')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4392, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReference._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseResourceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4397, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoundRecordingCollectionReference._Automaton = _BuildAutomaton_75()




SoundRecordingCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NumberOfCollections'), pyxb.binding.datatypes.integer, scope=SoundRecordingCollectionReferenceList, documentation='The number of referenced ddexC:Collections (typically Chapters).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4409, 9)))

SoundRecordingCollectionReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference'), SoundRecordingCollectionReference, scope=SoundRecordingCollectionReferenceList, documentation='A ddex:Composite containing a ddex:SoundRecordingCollectionReference for a ddex:Collection (specific to this ddex:Message).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4414, 9)))

def _BuildAutomaton_76 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_76
    del _BuildAutomaton_76
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4409, 9))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'NumberOfCollections')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4409, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoundRecordingCollectionReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'SoundRecordingCollectionReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4414, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoundRecordingCollectionReferenceList._Automaton = _BuildAutomaton_76()




SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Territory to which the ddex:SoundRecording details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4428, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Territory to which the ddex:SoundRecording details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4433, 12)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Title of the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4439, 9)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), Artist, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:DisplayArtist for the ddex:SoundRecording. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4444, 9)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Contributor to the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4449, 9)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4455, 9)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4461, 9)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LabelName'), LabelName, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing the ddex:Name of the ddex:Label under which the ddex:Release is to be marketed.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4466, 9)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsController'), RightsController, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing details of ddex:RightsController of Rights in the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4471, 9)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), EventDate, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SoundRecording was re-mastered (usually digitally).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4477, 9)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SoundRecording was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4482, 9)))

SoundRecordingDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLine'), PLine, scope=SoundRecordingDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:PLine for the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4487, 9)))

def _BuildAutomaton_77 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_77
    del _BuildAutomaton_77
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4439, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4444, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4449, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4455, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4461, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4466, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4471, 9))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4477, 9))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4482, 9))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4487, 9))
    counters.add(cc_9)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4428, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4433, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4439, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4444, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4449, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4455, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4461, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4466, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsController')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4471, 9))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RemasteredDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4477, 9))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4482, 9))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'PLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4487, 9))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SoundRecordingDetailsByTerritory._Automaton = _BuildAutomaton_77()




SoundRecordingId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=SoundRecordingId, documentation='The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:SoundRecording. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4504, 9)))

SoundRecordingId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=SoundRecordingId, documentation='A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4509, 9)))

SoundRecordingId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=SoundRecordingId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:SoundRecording (usually one per society involved in the messaging).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4514, 9)))

def _BuildAutomaton_78 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_78
    del _BuildAutomaton_78
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4504, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4509, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4514, 9))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4504, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4509, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SoundRecordingId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4514, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SoundRecordingId._Automaton = _BuildAutomaton_78()




TaxRate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Rate'), pyxb.binding.datatypes.decimal, scope=TaxRate, documentation='The ddexC:TaxRate as a percentage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4645, 9)))

TaxRate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TaxType'), TaxType, scope=TaxRate, documentation='A ddex:Composite containing details of the ddex:Type of ddex:Tax.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4650, 9)))

TaxRate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TaxScope'), TaxScope, scope=TaxRate, documentation='A ddex:Composite containing details of the ddex:Type of ddex:Tax according to its scope.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4655, 9)))

def _BuildAutomaton_79 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_79
    del _BuildAutomaton_79
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(TaxRate._UseForTag(pyxb.namespace.ExpandedName(None, 'Rate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4645, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(TaxRate._UseForTag(pyxb.namespace.ExpandedName(None, 'TaxType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4650, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(TaxRate._UseForTag(pyxb.namespace.ExpandedName(None, 'TaxScope')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4655, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
TaxRate._Automaton = _BuildAutomaton_79()




TechnicalInstantiation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DrmEnforcementType'), _ImportedBinding__ddex.DrmEnforcementType, scope=TechnicalInstantiation, documentation='A ddex:Type of DRM enforcement.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4705, 9)))

TechnicalInstantiation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VideoDefinitionType'), _ImportedBinding__ddex.VideoDefinitionType, scope=TechnicalInstantiation, documentation='A ddex:Type of resolution (or definition) in which a ddex:Video is provided.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4710, 9)))

TechnicalInstantiation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CodingType'), _ImportedBinding__ddex.CodingType, scope=TechnicalInstantiation, documentation='A ddex:Type of coding used to encode a ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4715, 9)))

TechnicalInstantiation._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'BitRate'), BitRate, scope=TechnicalInstantiation, documentation='A ddex:Composite containing the ddex:BitRate for the audio data and a ddex:UnitOfMeasure (the default is ddex:kbps).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4720, 9)))

def _BuildAutomaton_80 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_80
    del _BuildAutomaton_80
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4705, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4710, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4715, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4720, 9))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(TechnicalInstantiation._UseForTag(pyxb.namespace.ExpandedName(None, 'DrmEnforcementType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4705, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(TechnicalInstantiation._UseForTag(pyxb.namespace.ExpandedName(None, 'VideoDefinitionType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4710, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(TechnicalInstantiation._UseForTag(pyxb.namespace.ExpandedName(None, 'CodingType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4715, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(TechnicalInstantiation._UseForTag(pyxb.namespace.ExpandedName(None, 'BitRate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4720, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
TechnicalInstantiation._Automaton = _BuildAutomaton_80()




TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=TextDetailsByTerritory, documentation='A ddex:Territory to which the ddex:Text details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4757, 12)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=TextDetailsByTerritory, documentation='A ddex:Territory to which the ddex:Text details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4762, 12)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=TextDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Contributor to the ddex:Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4768, 9)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=TextDetailsByTerritory, documentation='A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4774, 9)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=TextDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:CLine for the ddex:Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4780, 9)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CourtesyLine'), CourtesyLine, scope=TextDetailsByTerritory, documentation='A ddex:Composite containing an ddex:Annotation which acknowledges record companies and/or other Parties giving permission for ddex:Artists or others featured in the ddex:Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4785, 9)))

TextDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=TextDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:Text was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4790, 9)))

def _BuildAutomaton_81 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_81
    del _BuildAutomaton_81
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4768, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4774, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4780, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4785, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4790, 9))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4757, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4762, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4768, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4774, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4780, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CourtesyLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4785, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(TextDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4790, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
TextDetailsByTerritory._Automaton = _BuildAutomaton_81()




TextId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISBN'), pyxb.binding.datatypes.string, scope=TextId, documentation="The ddex:ISBN (International Standard Book Number defined in ISO 2108) for the ddex:Text. An ddex:ISBN is a 13-digit number. Pre-2007, ddex:ISBNs, which had 10-digits and are now deprecated, are converted by adding the prefix '978' and re-calculating the check character.", location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4807, 9)))

TextId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISSN'), pyxb.binding.datatypes.string, scope=TextId, documentation='The ddex:ISSN (International Standard Serial Number defined in ISO 3297) identifying the ddex:Text. An ddex:ISSN comprises two groups of four digits, separated by a hyphen and a control digit.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4812, 9)))

TextId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SICI'), pyxb.binding.datatypes.string, scope=TextId, documentation='The ddex:SICI (Serial Item and Contribution ddex:Identifier defined in ANSI/NISO Z39.56-199)  for the ddex:Text.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4817, 9)))

TextId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=TextId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Text (usually one per society involved in the messaging).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4822, 9)))

def _BuildAutomaton_82 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_82
    del _BuildAutomaton_82
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4807, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4812, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4817, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4822, 9))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(TextId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISBN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4807, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(TextId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISSN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4812, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(TextId._UseForTag(pyxb.namespace.ExpandedName(None, 'SICI')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4817, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(TextId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4822, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
TextId._Automaton = _BuildAutomaton_82()




TotalRoyaltyAmount._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseType'), ReleaseType, scope=TotalRoyaltyAmount, documentation='A ddex:Composite containing details of the ddex:ReleaseType for which the ddex:RoyaltyAmount is calculated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4900, 9)))

TotalRoyaltyAmount._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsType'), RightsType, scope=TotalRoyaltyAmount, documentation='A ddex:Composite containing details of the RightsType for which the ddex:RoyaltyAmount is calculated.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4905, 9)))

TotalRoyaltyAmount._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RoyaltyAmount'), RoyaltyAmount, scope=TotalRoyaltyAmount, documentation='A ddex:Composite containing details of the ddex:RoyaltyAmount due.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4910, 9)))

def _BuildAutomaton_83 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_83
    del _BuildAutomaton_83
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4900, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4905, 9))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(TotalRoyaltyAmount._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4900, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(TotalRoyaltyAmount._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4905, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(TotalRoyaltyAmount._UseForTag(pyxb.namespace.ExpandedName(None, 'RoyaltyAmount')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4910, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
TotalRoyaltyAmount._Automaton = _BuildAutomaton_83()




Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UseType'), UseType, scope=Usage, documentation='A ddex:Composite containing details of a nature of a ddex:Service, or a ddex:Release, as used by a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4941, 9)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserInterfaceType'), UserInterfaceType, scope=Usage, documentation='A ddex:Composite containing details of a physical interface by which a ddex:Consumer is intended to use a ddex:Service or ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4946, 9)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DistributionChannelType'), DistributionChannelType, scope=Usage, documentation='A ddex:Composite containing details of a distribution channel intended to be used to disseminate a ddex:Service or ddex:Release to a ddex:Consumer.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4952, 9)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CarrierType'), CarrierType, scope=Usage, documentation='A ddex:Composite containing details of a ddex:Carrier.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4958, 9)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TechnicalInstantiation'), TechnicalInstantiation, scope=Usage, documentation='A ddex:Composite containing technical details of the ddex:Release.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4963, 9)))

Usage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'NumberOfUsages'), pyxb.binding.datatypes.integer, scope=Usage, documentation='The number of times a ddex:Release can be used under the terms of the ddex:Deal.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4968, 9)))

def _BuildAutomaton_84 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_84
    del _BuildAutomaton_84
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4946, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4952, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4958, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4963, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4968, 9))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'UseType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4941, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'UserInterfaceType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4946, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'DistributionChannelType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4952, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'CarrierType')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4958, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'TechnicalInstantiation')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4963, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(Usage._UseForTag(pyxb.namespace.ExpandedName(None, 'NumberOfUsages')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4968, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Usage._Automaton = _BuildAutomaton_84()




UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=UserDefinedResourceDetailsByTerritory, documentation='A ddex:Territory to which the ddex:UserDefinedResource details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5000, 12)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=UserDefinedResourceDetailsByTerritory, documentation='A ddex:Territory to which the ddex:UserDefinedResource details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5005, 12)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=UserDefinedResourceDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Contributor to the ddex:UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5011, 9)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=UserDefinedResourceDetailsByTerritory, documentation='A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5017, 9)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserDefinedValue'), UserDefinedValue, scope=UserDefinedResourceDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:UserDefinedValue.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5023, 9)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLine'), PLine, scope=UserDefinedResourceDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:PLine for the ddex:UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5029, 9)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=UserDefinedResourceDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:CLine for the ddex:UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5034, 9)))

UserDefinedResourceDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=UserDefinedResourceDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:UserDefinedResource was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5039, 9)))

def _BuildAutomaton_85 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_85
    del _BuildAutomaton_85
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5011, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5017, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5023, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5029, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5034, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5039, 9))
    counters.add(cc_5)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5000, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5005, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5011, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5017, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'UserDefinedValue')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5023, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'PLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5029, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5034, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5039, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
UserDefinedResourceDetailsByTerritory._Automaton = _BuildAutomaton_85()




UserDefinedResourceId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=UserDefinedResourceId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:UserDefinedResource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5056, 9)))

def _BuildAutomaton_86 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_86
    del _BuildAutomaton_86
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(UserDefinedResourceId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5056, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
UserDefinedResourceId._Automaton = _BuildAutomaton_86()




VideoCueSheetReference._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VideoCueSheetReference'), STD_ANON_16, scope=VideoCueSheetReference, documentation='A ddex:Reference for a ddex:CueSheet (specific to this ddex:Message). This is a ddex:LocalCueSheetAnchorReference starting with the letter Q.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5154, 9)))

def _BuildAutomaton_87 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_87
    del _BuildAutomaton_87
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoCueSheetReference._UseForTag(pyxb.namespace.ExpandedName(None, 'VideoCueSheetReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5154, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoCueSheetReference._Automaton = _BuildAutomaton_87()




VideoCueSheetReferenceList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VideoCueSheetReference'), STD_ANON_17, scope=VideoCueSheetReferenceList, documentation='A ddex:Reference for a ddex:CueSheet (specific to this ddex:Message). This is a ddex:LocalCueSheetAnchorReference starting with the letter Q.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5171, 9)))

def _BuildAutomaton_88 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_88
    del _BuildAutomaton_88
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoCueSheetReferenceList._UseForTag(pyxb.namespace.ExpandedName(None, 'VideoCueSheetReference')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5171, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoCueSheetReferenceList._Automaton = _BuildAutomaton_88()




VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TerritoryCode'), TerritoryCode, scope=VideoDetailsByTerritory, documentation='A ddex:Territory to which the ddex:SoundRecording details apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:ExcludedTerritory shall be present, but not both. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5189, 12)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode'), TerritoryCode, scope=VideoDetailsByTerritory, documentation='A ddex:Territory to which the ddex:SoundRecording details do not apply (represented by an ISO 3166-1 iso3166a2:TerritoryCode). Either this ddex:Element or ddex:Territory shall be present, but not both.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5194, 12)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Title'), Title, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Title of the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5200, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DisplayArtist'), Artist, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:DisplayArtist for the ddex:SoundRecording. The ddex:DisplayArtist may be described through ddex:Name, ddex:Identifier and Roles.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5205, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ResourceContributor'), ResourceContributor, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of a ddex:Contributor to the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5210, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor'), IndirectResourceContributor, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of an indirect ddex:Contributor to the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5216, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsAgreementId'), RightsAgreementId, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of ddex:Identifiers of a ddex:License, ddex:Claim, ddex:RightShare or contract for the MusicalWork(s) used in the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5222, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LabelName'), LabelName, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing the ddex:Name of the ddex:Label under which the ddex:Release is to be marketed.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5227, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RightsController'), RightsController, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of ddex:RightsController of Rights in the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5232, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RemasteredDate'), EventDate, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SoundRecording was re-mastered (usually digitally).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5238, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate'), EventDate, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of the Date and ddex:Place of the ddex:Event in which the ddex:SoundRecording was originally published, whether for physical or electronic/online distribution.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5243, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLine'), PLine, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:PLine for the ddex:SoundRecording.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5248, 9)))

VideoDetailsByTerritory._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CLine'), CLine, scope=VideoDetailsByTerritory, documentation='A ddex:Composite containing details of the ddex:CLine for the ddex:Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5253, 9)))

def _BuildAutomaton_89 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_89
    del _BuildAutomaton_89
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5200, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5205, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5210, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5216, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5222, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5227, 9))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5232, 9))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5238, 9))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5243, 9))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5248, 9))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5253, 9))
    counters.add(cc_10)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'TerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5189, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ExcludedTerritoryCode')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5194, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'Title')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5200, 9))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'DisplayArtist')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5205, 9))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'ResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5210, 9))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'IndirectResourceContributor')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5216, 9))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsAgreementId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5222, 9))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'LabelName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5227, 9))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RightsController')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5232, 9))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'RemasteredDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5238, 9))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'OriginalResourceReleaseDate')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5243, 9))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'PLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5248, 9))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(VideoDetailsByTerritory._UseForTag(pyxb.namespace.ExpandedName(None, 'CLine')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5253, 9))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, True) ]))
    st_12._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoDetailsByTerritory._Automaton = _BuildAutomaton_89()




VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISRC'), pyxb.binding.datatypes.string, scope=VideoId, documentation='The ddex:ISRC (International Standard ddex:Recording Code as defined in  ISO 3901) for the ddex:Video. An ddex:ISRC comprises four parts: two characters, followed by three alphanumeric characters, then two digits and five digits. ', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5270, 9)))

VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ISAN'), pyxb.binding.datatypes.string, scope=VideoId, documentation='The ddex:ISAN (International Standard Audiovisual Number as defined in ISO 15706) for the ddex:Video. An ddex:ISAN comprises four blocks of four hexadecimal charaters followed by a check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5275, 9)))

VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VISAN'), pyxb.binding.datatypes.string, scope=VideoId, documentation='The V-ISAN (Version ddex:Identifier of a International Standard Audiovisual Number as defined in ISO 15706-2) for the ddex:Video. A V-ISAN comprises four blocks of four hexadecimal charaters followed by a check character, followed by two further blocks of four hexadecimal characters, followed by a further check character.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5280, 9)))

VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CatalogNumber'), CatalogNumber, scope=VideoId, documentation='A ddex:Composite containing details of the ddex:CatalogNumber of the ddex:Video.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5285, 9)))

VideoId._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ProprietaryId'), ProprietaryId, scope=VideoId, documentation='A ddex:Composite containing details of a ddex:ProprietaryIdentifier of the ddex:Video (usually one per society involved in the messaging).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5290, 9)))

def _BuildAutomaton_90 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_90
    del _BuildAutomaton_90
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5270, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5275, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5280, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5285, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5290, 9))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISRC')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5270, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'ISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5275, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'VISAN')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5280, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'CatalogNumber')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5285, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(VideoId._UseForTag(pyxb.namespace.ExpandedName(None, 'ProprietaryId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5290, 9))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoId._Automaton = _BuildAutomaton_90()




WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=WebPage, documentation='A ddex:Composite containing details of the ddex:PartyId for a ddex:Party owning the ddexC:WebPage. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5327, 9)))

WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ReleaseId'), ReleaseId, scope=WebPage, documentation='A ddex:Composite containing details of ddex:ReleaseIds. If available, a ddex:GRid should always be used.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5332, 9)))

WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PageName'), Name, scope=WebPage, documentation='A ddex:Composite containing the ddex:Name of the ddex:WebPage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5337, 9)))

WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'URL'), pyxb.binding.datatypes.string, scope=WebPage, documentation='A ddex:URL of the ddex:WebPage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5342, 9)))

WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'UserName'), pyxb.binding.datatypes.string, scope=WebPage, documentation='An ddex:Identifier of a computer user who is granted maintenance access to the ddex:WebPage.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5347, 9)))

WebPage._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Password'), pyxb.binding.datatypes.string, scope=WebPage, documentation='A ddex:Password needed to grant a user maintenance access to the ddex:WebPage in combination with the ddex:UserName.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5352, 9)))

def _BuildAutomaton_91 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_91
    del _BuildAutomaton_91
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5327, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5332, 9))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5337, 9))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5342, 9))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5347, 9))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5352, 9))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5327, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'ReleaseId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5332, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'PageName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5337, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'URL')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5342, 9))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'UserName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5347, 9))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(WebPage._UseForTag(pyxb.namespace.ExpandedName(None, 'Password')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5352, 9))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
WebPage._Automaton = _BuildAutomaton_91()




WorkList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MusicalWork'), MusicalWork, scope=WorkList, documentation='A ddex:Composite containing details of a ddex:MusicalWork contained in a ddex:Resource.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5364, 9)))

def _BuildAutomaton_92 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_92
    del _BuildAutomaton_92
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(WorkList._UseForTag(pyxb.namespace.ExpandedName(None, 'MusicalWork')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 5364, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
WorkList._Automaton = _BuildAutomaton_92()




AdministratingRecordCompany._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyId'), PartyId, scope=AdministratingRecordCompany, documentation='A ddex:Composite containing details of the ddex:PartyId for the ddex:Party. If no ddex:Namespace is given, the ddex:Identifier is a ddex:DdexPartyId (DPID). Note that DPIDs are not normally used to identify ddex:Artists, ddex:Producers or other ddex:Creators.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 37, 9)))

AdministratingRecordCompany._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PartyName'), PartyName, scope=AdministratingRecordCompany, documentation='A ddex:Composite containing details of the PartyName(s).', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 43, 12)))

def _BuildAutomaton_93 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_93
    del _BuildAutomaton_93
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 48, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AdministratingRecordCompany._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 37, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AdministratingRecordCompany._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyName')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 43, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AdministratingRecordCompany._UseForTag(pyxb.namespace.ExpandedName(None, 'PartyId')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 48, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AdministratingRecordCompany._Automaton = _BuildAutomaton_93()




PLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Year'), pyxb.binding.datatypes.gYear, scope=PLine, documentation='The ddex:Year of the ddexC:PLine.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2631, 9)))

PLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLineCompany'), pyxb.binding.datatypes.string, scope=PLine, documentation='The ddex:Name of the company releasing the ddex:Creation. This may be an owner or a licensee of the ddex:Creation.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2636, 9)))

PLine._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLineText'), pyxb.binding.datatypes.string, scope=PLine, documentation='The text of the ddexC:PLine. (Note: DDEX expects to deprecate the use of the PLineText element in a subsequent version of this standard. It will be deprecated once users of the standard are able to provide PLine information in a structured form.)', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2641, 9)))

def _BuildAutomaton_94 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_94
    del _BuildAutomaton_94
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2631, 9))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2636, 9))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PLine._UseForTag(pyxb.namespace.ExpandedName(None, 'Year')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2631, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(PLine._UseForTag(pyxb.namespace.ExpandedName(None, 'PLineCompany')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2636, 9))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(PLine._UseForTag(pyxb.namespace.ExpandedName(None, 'PLineText')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 2641, 9))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
PLine._Automaton = _BuildAutomaton_94()




Title._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TitleText'), TitleText, scope=Title, documentation='A ddex:Composite containing the text of the ddexC:Title.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4859, 9)))

Title._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SubTitle'), TypedSubTitle, scope=Title, documentation='A ddex:Composite containing details of a ddex:SubTitle of the ddexC:Title, including ddex:Titles of ddex:Versions used to differentiate different versions of the same ddex:Title, as required by the ddex:GRid and ddex:ISRC ddex:ReferenceDescriptiveMetadataSets.', location=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4864, 9)))

def _BuildAutomaton_95 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_95
    del _BuildAutomaton_95
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4864, 9))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(Title._UseForTag(pyxb.namespace.ExpandedName(None, 'TitleText')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4859, 9))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Title._UseForTag(pyxb.namespace.ExpandedName(None, 'SubTitle')), pyxb.utils.utility.Location('http://ddex.net/xml/20120214/ddexC.xsd', 4864, 9))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
Title._Automaton = _BuildAutomaton_95()

